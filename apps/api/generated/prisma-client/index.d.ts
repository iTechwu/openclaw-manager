
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserInfo
 * 
 */
export type UserInfo = $Result.DefaultSelection<Prisma.$UserInfoPayload>
/**
 * Model PersonaTemplate
 * PersonaTemplate - äººæ ¼æ¨¡æ¿
 * æ”¯æŒç³»ç»Ÿé¢„è®¾æ¨¡æ¿å’Œç”¨æˆ·è‡ªå®šä¹‰æ¨¡æ¿
 * å›¾æ ‡æ”¯æŒä¸¤ç§å½¢å¼ï¼ˆäºŒé€‰ä¸€ï¼‰ï¼š
 * - emoji: emoji å­—ç¬¦ä¸²ï¼ˆå¦‚ "ğŸ¤–"ï¼‰
 * - avatarFileId: ä¸Šä¼ çš„å¤´åƒæ–‡ä»¶ IDï¼ˆå…³è” FileSourceï¼‰
 */
export type PersonaTemplate = $Result.DefaultSelection<Prisma.$PersonaTemplatePayload>
/**
 * Model WechatAuth
 * 
 */
export type WechatAuth = $Result.DefaultSelection<Prisma.$WechatAuthPayload>
/**
 * Model GoogleAuth
 * 
 */
export type GoogleAuth = $Result.DefaultSelection<Prisma.$GoogleAuthPayload>
/**
 * Model DiscordAuth
 * 
 */
export type DiscordAuth = $Result.DefaultSelection<Prisma.$DiscordAuthPayload>
/**
 * Model MobileAuth
 * 
 */
export type MobileAuth = $Result.DefaultSelection<Prisma.$MobileAuthPayload>
/**
 * Model EmailAuth
 * 
 */
export type EmailAuth = $Result.DefaultSelection<Prisma.$EmailAuthPayload>
/**
 * Model RiskDetectionRecord
 * 
 */
export type RiskDetectionRecord = $Result.DefaultSelection<Prisma.$RiskDetectionRecordPayload>
/**
 * Model SystemTaskQueue
 * 
 */
export type SystemTaskQueue = $Result.DefaultSelection<Prisma.$SystemTaskQueuePayload>
/**
 * Model FileSource
 * 
 */
export type FileSource = $Result.DefaultSelection<Prisma.$FileSourcePayload>
/**
 * Model CountryCode
 * 
 */
export type CountryCode = $Result.DefaultSelection<Prisma.$CountryCodePayload>
/**
 * Model Bot
 * Bot - æœºå™¨äººå®ä½“
 * ç®¡ç† AI æœºå™¨äººçš„ç”Ÿå‘½å‘¨æœŸå’Œé…ç½®
 * æ³¨æ„ï¼šaiProviderã€modelã€channelType å­—æ®µå·²ç§»é™¤ï¼Œè¿™äº›å€¼ä» BotProviderKey å’Œ BotChannel åŠ¨æ€æ´¾ç”Ÿ
 */
export type Bot = $Result.DefaultSelection<Prisma.$BotPayload>
/**
 * Model ProviderKey
 * ProviderKey - AI æä¾›å•† API å¯†é’¥
 * å­˜å‚¨åŠ å¯†çš„ API å¯†é’¥ï¼Œæ”¯æŒå¤šæä¾›å•†å’Œæ ‡ç­¾è·¯ç”±
 * ProviderKey - API å¯†é’¥é…ç½®
 * å­˜å‚¨ç”¨æˆ·é…ç½®çš„å„ç±» AI æœåŠ¡å•† API å¯†é’¥
 * æ”¯æŒ OpenAIã€Anthropicã€Googleã€DeepSeek ç­‰ä¸»æµæœåŠ¡å•†ï¼Œä»¥åŠè‡ªå®šä¹‰æœåŠ¡å•†
 */
export type ProviderKey = $Result.DefaultSelection<Prisma.$ProviderKeyPayload>
/**
 * Model BotProviderKey
 * BotProviderKey - Bot ä¸ ProviderKey çš„å…³è”è¡¨
 * å­˜å‚¨ Bot ä¸ ProviderKey çš„å…³è”å…³ç³»ï¼Œä»¥åŠè¯¥å…³è”å…è®¸ä½¿ç”¨çš„æ¨¡å‹åˆ—è¡¨
 */
export type BotProviderKey = $Result.DefaultSelection<Prisma.$BotProviderKeyPayload>
/**
 * Model BotUsageLog
 * BotUsageLog - Bot API ä½¿ç”¨æ—¥å¿—
 * è®°å½•æ¯æ¬¡ API è°ƒç”¨çš„ä½¿ç”¨æƒ…å†µ
 */
export type BotUsageLog = $Result.DefaultSelection<Prisma.$BotUsageLogPayload>
/**
 * Model ProxyToken
 * ProxyToken - Zero-Trust æ¨¡å¼çš„ä»£ç†ä»¤ç‰Œ
 * Bot å®¹å™¨ä½¿ç”¨æ­¤ä»¤ç‰Œé€šè¿‡ Proxy è®¿é—® AI APIï¼Œè€Œä¸ç›´æ¥æŒæœ‰ API Key
 * æ ¸å¿ƒå®‰å…¨åŸåˆ™ï¼šBot å®¹å™¨æ°¸è¿œä¸æŒæœ‰çœŸå®çš„ API Key
 */
export type ProxyToken = $Result.DefaultSelection<Prisma.$ProxyTokenPayload>
/**
 * Model Message
 * User Message System
 * ç”¨æˆ·æ¶ˆæ¯ç³»ç»Ÿ - æ”¯æŒç³»ç»Ÿé€šçŸ¥ã€ç”¨æˆ·é—´æ¶ˆæ¯ç­‰
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageRecipient
 * Message Recipient - æ¶ˆæ¯æ¥æ”¶è®°å½•
 * è®°å½•æ¯ä¸ªç”¨æˆ·æ¥æ”¶åˆ°çš„æ¶ˆæ¯åŠå…¶é˜…è¯»çŠ¶æ€
 */
export type MessageRecipient = $Result.DefaultSelection<Prisma.$MessageRecipientPayload>
/**
 * Model OperateLog
 * OperateLog - æ“ä½œæ—¥å¿—
 * è®°å½•ç”¨æˆ·çš„æ“ä½œè¡Œä¸ºï¼Œç”¨äºå®¡è®¡å’Œè¿½è¸ª
 */
export type OperateLog = $Result.DefaultSelection<Prisma.$OperateLogPayload>
/**
 * Model ChannelDefinition
 * ChannelDefinition - æ¸ é“å®šä¹‰
 * å­˜å‚¨å„ç§æ¶ˆæ¯æ¸ é“çš„é…ç½®ä¿¡æ¯ï¼ŒåŒ…æ‹¬æ‰€éœ€çš„å‡­è¯å­—æ®µ
 */
export type ChannelDefinition = $Result.DefaultSelection<Prisma.$ChannelDefinitionPayload>
/**
 * Model ChannelCredentialField
 * ChannelCredentialField - æ¸ é“å‡­è¯å­—æ®µ
 * å®šä¹‰æ¯ä¸ªæ¸ é“æ‰€éœ€çš„å‡­è¯å­—æ®µé…ç½®
 */
export type ChannelCredentialField = $Result.DefaultSelection<Prisma.$ChannelCredentialFieldPayload>
/**
 * Model Plugin
 * Plugin - æ’ä»¶å®šä¹‰
 * å­˜å‚¨æ’ä»¶çš„å…ƒæ•°æ®å’Œé…ç½®æ¨¡æ¿
 */
export type Plugin = $Result.DefaultSelection<Prisma.$PluginPayload>
/**
 * Model BotPlugin
 * BotPlugin - Bot ä¸ Plugin çš„å…³è”è¡¨
 * è®°å½• Bot å®‰è£…çš„æ’ä»¶åŠå…¶é…ç½®
 */
export type BotPlugin = $Result.DefaultSelection<Prisma.$BotPluginPayload>
/**
 * Model SkillType
 * SkillType - æŠ€èƒ½ç±»å‹/åˆ†ç±»
 * ç”¨äºå¯¹æŠ€èƒ½è¿›è¡Œåˆ†ç±»ç®¡ç†ï¼Œæ”¯æŒä¸­è‹±æ–‡åç§°
 */
export type SkillType = $Result.DefaultSelection<Prisma.$SkillTypePayload>
/**
 * Model Skill
 * Skill - è‡ªå®šä¹‰æŠ€èƒ½å®šä¹‰
 * ç”¨æˆ·å¯ä»¥åˆ›å»ºè‡ªå®šä¹‰æŠ€èƒ½ä¾› Bot ä½¿ç”¨
 * æ”¯æŒç³»ç»Ÿé¢„è®¾ã€ç”¨æˆ·è‡ªå®šä¹‰å’Œå¤–éƒ¨åŒæ­¥ï¼ˆå¦‚ OpenClawï¼‰
 */
export type Skill = $Result.DefaultSelection<Prisma.$SkillPayload>
/**
 * Model BotSkill
 * BotSkill - Bot ä¸ Skill çš„å…³è”è¡¨
 * è®°å½• Bot å®‰è£…çš„æŠ€èƒ½åŠå…¶é…ç½®
 */
export type BotSkill = $Result.DefaultSelection<Prisma.$BotSkillPayload>
/**
 * Model ModelPricing
 * ModelPricing - AI æ¨¡å‹å®šä»·ä¸èƒ½åŠ›ç›®å½•
 * å­˜å‚¨å„ AI æ¨¡å‹çš„å®šä»·ä¿¡æ¯ã€èƒ½åŠ›è¯„åˆ†å’Œç‰¹æ€§æ”¯æŒï¼Œç”¨äºæˆæœ¬ä¼°ç®—å’Œæ™ºèƒ½è·¯ç”±
 * ä»·æ ¼å•ä½ï¼šç¾å…ƒ/ç™¾ä¸‡ tokens
 */
export type ModelPricing = $Result.DefaultSelection<Prisma.$ModelPricingPayload>
/**
 * Model BotModelRouting
 * BotModelRouting - Bot æ¨¡å‹è·¯ç”±é…ç½®
 * å­˜å‚¨ Bot çš„æ¨¡å‹è·¯ç”±è§„åˆ™ï¼Œæ”¯æŒåŠŸèƒ½è·¯ç”±ã€è´Ÿè½½å‡è¡¡ã€æ•…éšœè½¬ç§»
 */
export type BotModelRouting = $Result.DefaultSelection<Prisma.$BotModelRoutingPayload>
/**
 * Model BotChannel
 * BotChannel - Bot æ¸ é“é…ç½®
 * å­˜å‚¨ Bot çš„æ¸ é“è¿æ¥é…ç½®ï¼ŒåŒ…æ‹¬åŠ å¯†çš„å‡­è¯
 * ä¸€ä¸ª Bot å¯ä»¥è¿æ¥å¤šä¸ªæ¸ é“ï¼ˆå¦‚åŒæ—¶è¿æ¥é£ä¹¦å’Œ Telegramï¼‰
 */
export type BotChannel = $Result.DefaultSelection<Prisma.$BotChannelPayload>
/**
 * Model CapabilityTag
 * CapabilityTag - èƒ½åŠ›æ ‡ç­¾
 * å®šä¹‰è·¯ç”±èƒ½åŠ›æ ‡ç­¾åŠå…¶è¦æ±‚ï¼Œç”¨äºæ™ºèƒ½è·¯ç”±å†³ç­–
 */
export type CapabilityTag = $Result.DefaultSelection<Prisma.$CapabilityTagPayload>
/**
 * Model FallbackChain
 * FallbackChain - Fallback é“¾é…ç½®
 * å®šä¹‰æ¨¡å‹é™çº§ç­–ç•¥ï¼Œæ”¯æŒå¤šæ¨¡å‹æ•…éšœè½¬ç§»
 */
export type FallbackChain = $Result.DefaultSelection<Prisma.$FallbackChainPayload>
/**
 * Model CostStrategy
 * CostStrategy - æˆæœ¬ç­–ç•¥é…ç½®
 * å®šä¹‰æˆæœ¬ä¼˜åŒ–ç­–ç•¥ï¼Œç”¨äºæ¨¡å‹é€‰æ‹©å†³ç­–
 */
export type CostStrategy = $Result.DefaultSelection<Prisma.$CostStrategyPayload>
/**
 * Model BotRoutingConfig
 * BotRoutingConfig - Bot è·¯ç”±é…ç½®
 * å­˜å‚¨ Bot çš„æ™ºèƒ½è·¯ç”±ã€Fallback å’Œæˆæœ¬æ§åˆ¶é…ç½®
 */
export type BotRoutingConfig = $Result.DefaultSelection<Prisma.$BotRoutingConfigPayload>
/**
 * Model ComplexityRoutingConfig
 * ComplexityRoutingConfig - å¤æ‚åº¦è·¯ç”±é…ç½®
 * å­˜å‚¨åŸºäºæ¶ˆæ¯å¤æ‚åº¦çš„æ¨¡å‹è·¯ç”±é…ç½®
 */
export type ComplexityRoutingConfig = $Result.DefaultSelection<Prisma.$ComplexityRoutingConfigPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SexType: {
  UNKNOWN: 'UNKNOWN',
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type SexType = (typeof SexType)[keyof typeof SexType]


export const TaskType: {
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const FileBucketVendor: {
  oss: 'oss',
  us3: 'us3',
  qiniu: 'qiniu',
  s3: 's3',
  gcs: 'gcs',
  tos: 'tos',
  tencent: 'tencent',
  ksyun: 'ksyun'
};

export type FileBucketVendor = (typeof FileBucketVendor)[keyof typeof FileBucketVendor]


export const FileEnvType: {
  dev: 'dev',
  test: 'test',
  prod: 'prod',
  produs: 'produs',
  prodap: 'prodap'
};

export type FileEnvType = (typeof FileEnvType)[keyof typeof FileEnvType]


export const BotStatus: {
  draft: 'draft',
  created: 'created',
  starting: 'starting',
  running: 'running',
  stopped: 'stopped',
  error: 'error'
};

export type BotStatus = (typeof BotStatus)[keyof typeof BotStatus]


export const HealthStatus: {
  HEALTHY: 'HEALTHY',
  UNHEALTHY: 'UNHEALTHY',
  UNKNOWN: 'UNKNOWN'
};

export type HealthStatus = (typeof HealthStatus)[keyof typeof HealthStatus]


export const OperateType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  START: 'START',
  STOP: 'STOP',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT'
};

export type OperateType = (typeof OperateType)[keyof typeof OperateType]


export const OperateTarget: {
  BOT: 'BOT',
  PROVIDER_KEY: 'PROVIDER_KEY',
  USER: 'USER',
  PERSONA_TEMPLATE: 'PERSONA_TEMPLATE',
  SYSTEM: 'SYSTEM'
};

export type OperateTarget = (typeof OperateTarget)[keyof typeof OperateTarget]


export const PluginCategory: {
  BROWSER: 'BROWSER',
  FILESYSTEM: 'FILESYSTEM',
  DATABASE: 'DATABASE',
  API: 'API',
  COMMUNICATION: 'COMMUNICATION',
  DEVELOPMENT: 'DEVELOPMENT',
  CUSTOM: 'CUSTOM'
};

export type PluginCategory = (typeof PluginCategory)[keyof typeof PluginCategory]


export const ChannelConnectionStatus: {
  DISCONNECTED: 'DISCONNECTED',
  CONNECTING: 'CONNECTING',
  CONNECTED: 'CONNECTED',
  ERROR: 'ERROR'
};

export type ChannelConnectionStatus = (typeof ChannelConnectionStatus)[keyof typeof ChannelConnectionStatus]


export const ModelRoutingType: {
  FUNCTION_ROUTE: 'FUNCTION_ROUTE',
  LOAD_BALANCE: 'LOAD_BALANCE',
  FAILOVER: 'FAILOVER'
};

export type ModelRoutingType = (typeof ModelRoutingType)[keyof typeof ModelRoutingType]

}

export type SexType = $Enums.SexType

export const SexType: typeof $Enums.SexType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type FileBucketVendor = $Enums.FileBucketVendor

export const FileBucketVendor: typeof $Enums.FileBucketVendor

export type FileEnvType = $Enums.FileEnvType

export const FileEnvType: typeof $Enums.FileEnvType

export type BotStatus = $Enums.BotStatus

export const BotStatus: typeof $Enums.BotStatus

export type HealthStatus = $Enums.HealthStatus

export const HealthStatus: typeof $Enums.HealthStatus

export type OperateType = $Enums.OperateType

export const OperateType: typeof $Enums.OperateType

export type OperateTarget = $Enums.OperateTarget

export const OperateTarget: typeof $Enums.OperateTarget

export type PluginCategory = $Enums.PluginCategory

export const PluginCategory: typeof $Enums.PluginCategory

export type ChannelConnectionStatus = $Enums.ChannelConnectionStatus

export const ChannelConnectionStatus: typeof $Enums.ChannelConnectionStatus

export type ModelRoutingType = $Enums.ModelRoutingType

export const ModelRoutingType: typeof $Enums.ModelRoutingType

/**
 * ##  Prisma Client Ê²Ë¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserInfos
 * const userInfos = await prisma.userInfo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client Ê²Ë¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserInfos
   * const userInfos = await prisma.userInfo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userInfo`: Exposes CRUD operations for the **UserInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInfos
    * const userInfos = await prisma.userInfo.findMany()
    * ```
    */
  get userInfo(): Prisma.UserInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personaTemplate`: Exposes CRUD operations for the **PersonaTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonaTemplates
    * const personaTemplates = await prisma.personaTemplate.findMany()
    * ```
    */
  get personaTemplate(): Prisma.PersonaTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wechatAuth`: Exposes CRUD operations for the **WechatAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WechatAuths
    * const wechatAuths = await prisma.wechatAuth.findMany()
    * ```
    */
  get wechatAuth(): Prisma.WechatAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.googleAuth`: Exposes CRUD operations for the **GoogleAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleAuths
    * const googleAuths = await prisma.googleAuth.findMany()
    * ```
    */
  get googleAuth(): Prisma.GoogleAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discordAuth`: Exposes CRUD operations for the **DiscordAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordAuths
    * const discordAuths = await prisma.discordAuth.findMany()
    * ```
    */
  get discordAuth(): Prisma.DiscordAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mobileAuth`: Exposes CRUD operations for the **MobileAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobileAuths
    * const mobileAuths = await prisma.mobileAuth.findMany()
    * ```
    */
  get mobileAuth(): Prisma.MobileAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAuth`: Exposes CRUD operations for the **EmailAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAuths
    * const emailAuths = await prisma.emailAuth.findMany()
    * ```
    */
  get emailAuth(): Prisma.EmailAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskDetectionRecord`: Exposes CRUD operations for the **RiskDetectionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskDetectionRecords
    * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany()
    * ```
    */
  get riskDetectionRecord(): Prisma.RiskDetectionRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemTaskQueue`: Exposes CRUD operations for the **SystemTaskQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemTaskQueues
    * const systemTaskQueues = await prisma.systemTaskQueue.findMany()
    * ```
    */
  get systemTaskQueue(): Prisma.SystemTaskQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileSource`: Exposes CRUD operations for the **FileSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileSources
    * const fileSources = await prisma.fileSource.findMany()
    * ```
    */
  get fileSource(): Prisma.FileSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countryCode`: Exposes CRUD operations for the **CountryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryCodes
    * const countryCodes = await prisma.countryCode.findMany()
    * ```
    */
  get countryCode(): Prisma.CountryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bot`: Exposes CRUD operations for the **Bot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bot.findMany()
    * ```
    */
  get bot(): Prisma.BotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerKey`: Exposes CRUD operations for the **ProviderKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderKeys
    * const providerKeys = await prisma.providerKey.findMany()
    * ```
    */
  get providerKey(): Prisma.ProviderKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botProviderKey`: Exposes CRUD operations for the **BotProviderKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotProviderKeys
    * const botProviderKeys = await prisma.botProviderKey.findMany()
    * ```
    */
  get botProviderKey(): Prisma.BotProviderKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botUsageLog`: Exposes CRUD operations for the **BotUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotUsageLogs
    * const botUsageLogs = await prisma.botUsageLog.findMany()
    * ```
    */
  get botUsageLog(): Prisma.BotUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxyToken`: Exposes CRUD operations for the **ProxyToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyTokens
    * const proxyTokens = await prisma.proxyToken.findMany()
    * ```
    */
  get proxyToken(): Prisma.ProxyTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageRecipient`: Exposes CRUD operations for the **MessageRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageRecipients
    * const messageRecipients = await prisma.messageRecipient.findMany()
    * ```
    */
  get messageRecipient(): Prisma.MessageRecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operateLog`: Exposes CRUD operations for the **OperateLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperateLogs
    * const operateLogs = await prisma.operateLog.findMany()
    * ```
    */
  get operateLog(): Prisma.OperateLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelDefinition`: Exposes CRUD operations for the **ChannelDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelDefinitions
    * const channelDefinitions = await prisma.channelDefinition.findMany()
    * ```
    */
  get channelDefinition(): Prisma.ChannelDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelCredentialField`: Exposes CRUD operations for the **ChannelCredentialField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelCredentialFields
    * const channelCredentialFields = await prisma.channelCredentialField.findMany()
    * ```
    */
  get channelCredentialField(): Prisma.ChannelCredentialFieldDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.plugin`: Exposes CRUD operations for the **Plugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Plugins
    * const plugins = await prisma.plugin.findMany()
    * ```
    */
  get plugin(): Prisma.PluginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botPlugin`: Exposes CRUD operations for the **BotPlugin** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotPlugins
    * const botPlugins = await prisma.botPlugin.findMany()
    * ```
    */
  get botPlugin(): Prisma.BotPluginDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skillType`: Exposes CRUD operations for the **SkillType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SkillTypes
    * const skillTypes = await prisma.skillType.findMany()
    * ```
    */
  get skillType(): Prisma.SkillTypeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.skill`: Exposes CRUD operations for the **Skill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Skills
    * const skills = await prisma.skill.findMany()
    * ```
    */
  get skill(): Prisma.SkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botSkill`: Exposes CRUD operations for the **BotSkill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotSkills
    * const botSkills = await prisma.botSkill.findMany()
    * ```
    */
  get botSkill(): Prisma.BotSkillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.modelPricing`: Exposes CRUD operations for the **ModelPricing** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ModelPricings
    * const modelPricings = await prisma.modelPricing.findMany()
    * ```
    */
  get modelPricing(): Prisma.ModelPricingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botModelRouting`: Exposes CRUD operations for the **BotModelRouting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotModelRoutings
    * const botModelRoutings = await prisma.botModelRouting.findMany()
    * ```
    */
  get botModelRouting(): Prisma.BotModelRoutingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botChannel`: Exposes CRUD operations for the **BotChannel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotChannels
    * const botChannels = await prisma.botChannel.findMany()
    * ```
    */
  get botChannel(): Prisma.BotChannelDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.capabilityTag`: Exposes CRUD operations for the **CapabilityTag** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CapabilityTags
    * const capabilityTags = await prisma.capabilityTag.findMany()
    * ```
    */
  get capabilityTag(): Prisma.CapabilityTagDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fallbackChain`: Exposes CRUD operations for the **FallbackChain** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FallbackChains
    * const fallbackChains = await prisma.fallbackChain.findMany()
    * ```
    */
  get fallbackChain(): Prisma.FallbackChainDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.costStrategy`: Exposes CRUD operations for the **CostStrategy** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CostStrategies
    * const costStrategies = await prisma.costStrategy.findMany()
    * ```
    */
  get costStrategy(): Prisma.CostStrategyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botRoutingConfig`: Exposes CRUD operations for the **BotRoutingConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotRoutingConfigs
    * const botRoutingConfigs = await prisma.botRoutingConfig.findMany()
    * ```
    */
  get botRoutingConfig(): Prisma.BotRoutingConfigDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.complexityRoutingConfig`: Exposes CRUD operations for the **ComplexityRoutingConfig** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ComplexityRoutingConfigs
    * const complexityRoutingConfigs = await prisma.complexityRoutingConfig.findMany()
    * ```
    */
  get complexityRoutingConfig(): Prisma.ComplexityRoutingConfigDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserInfo: 'UserInfo',
    PersonaTemplate: 'PersonaTemplate',
    WechatAuth: 'WechatAuth',
    GoogleAuth: 'GoogleAuth',
    DiscordAuth: 'DiscordAuth',
    MobileAuth: 'MobileAuth',
    EmailAuth: 'EmailAuth',
    RiskDetectionRecord: 'RiskDetectionRecord',
    SystemTaskQueue: 'SystemTaskQueue',
    FileSource: 'FileSource',
    CountryCode: 'CountryCode',
    Bot: 'Bot',
    ProviderKey: 'ProviderKey',
    BotProviderKey: 'BotProviderKey',
    BotUsageLog: 'BotUsageLog',
    ProxyToken: 'ProxyToken',
    Message: 'Message',
    MessageRecipient: 'MessageRecipient',
    OperateLog: 'OperateLog',
    ChannelDefinition: 'ChannelDefinition',
    ChannelCredentialField: 'ChannelCredentialField',
    Plugin: 'Plugin',
    BotPlugin: 'BotPlugin',
    SkillType: 'SkillType',
    Skill: 'Skill',
    BotSkill: 'BotSkill',
    ModelPricing: 'ModelPricing',
    BotModelRouting: 'BotModelRouting',
    BotChannel: 'BotChannel',
    CapabilityTag: 'CapabilityTag',
    FallbackChain: 'FallbackChain',
    CostStrategy: 'CostStrategy',
    BotRoutingConfig: 'BotRoutingConfig',
    ComplexityRoutingConfig: 'ComplexityRoutingConfig'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userInfo" | "personaTemplate" | "wechatAuth" | "googleAuth" | "discordAuth" | "mobileAuth" | "emailAuth" | "riskDetectionRecord" | "systemTaskQueue" | "fileSource" | "countryCode" | "bot" | "providerKey" | "botProviderKey" | "botUsageLog" | "proxyToken" | "message" | "messageRecipient" | "operateLog" | "channelDefinition" | "channelCredentialField" | "plugin" | "botPlugin" | "skillType" | "skill" | "botSkill" | "modelPricing" | "botModelRouting" | "botChannel" | "capabilityTag" | "fallbackChain" | "costStrategy" | "botRoutingConfig" | "complexityRoutingConfig"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserInfo: {
        payload: Prisma.$UserInfoPayload<ExtArgs>
        fields: Prisma.UserInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          findFirst: {
            args: Prisma.UserInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          findMany: {
            args: Prisma.UserInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          create: {
            args: Prisma.UserInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          createMany: {
            args: Prisma.UserInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          delete: {
            args: Prisma.UserInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          update: {
            args: Prisma.UserInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          deleteMany: {
            args: Prisma.UserInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          upsert: {
            args: Prisma.UserInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          aggregate: {
            args: Prisma.UserInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInfo>
          }
          groupBy: {
            args: Prisma.UserInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInfoCountArgs<ExtArgs>
            result: $Utils.Optional<UserInfoCountAggregateOutputType> | number
          }
        }
      }
      PersonaTemplate: {
        payload: Prisma.$PersonaTemplatePayload<ExtArgs>
        fields: Prisma.PersonaTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonaTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonaTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          findFirst: {
            args: Prisma.PersonaTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonaTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          findMany: {
            args: Prisma.PersonaTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          create: {
            args: Prisma.PersonaTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          createMany: {
            args: Prisma.PersonaTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonaTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          delete: {
            args: Prisma.PersonaTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          update: {
            args: Prisma.PersonaTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PersonaTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonaTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonaTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          upsert: {
            args: Prisma.PersonaTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          aggregate: {
            args: Prisma.PersonaTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonaTemplate>
          }
          groupBy: {
            args: Prisma.PersonaTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonaTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonaTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PersonaTemplateCountAggregateOutputType> | number
          }
        }
      }
      WechatAuth: {
        payload: Prisma.$WechatAuthPayload<ExtArgs>
        fields: Prisma.WechatAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WechatAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WechatAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          findFirst: {
            args: Prisma.WechatAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WechatAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          findMany: {
            args: Prisma.WechatAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          create: {
            args: Prisma.WechatAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          createMany: {
            args: Prisma.WechatAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WechatAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          delete: {
            args: Prisma.WechatAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          update: {
            args: Prisma.WechatAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          deleteMany: {
            args: Prisma.WechatAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WechatAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WechatAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          upsert: {
            args: Prisma.WechatAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          aggregate: {
            args: Prisma.WechatAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWechatAuth>
          }
          groupBy: {
            args: Prisma.WechatAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<WechatAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.WechatAuthCountArgs<ExtArgs>
            result: $Utils.Optional<WechatAuthCountAggregateOutputType> | number
          }
        }
      }
      GoogleAuth: {
        payload: Prisma.$GoogleAuthPayload<ExtArgs>
        fields: Prisma.GoogleAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoogleAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          findFirst: {
            args: Prisma.GoogleAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          findMany: {
            args: Prisma.GoogleAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          create: {
            args: Prisma.GoogleAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          createMany: {
            args: Prisma.GoogleAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoogleAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          delete: {
            args: Prisma.GoogleAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          update: {
            args: Prisma.GoogleAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          deleteMany: {
            args: Prisma.GoogleAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoogleAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          upsert: {
            args: Prisma.GoogleAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          aggregate: {
            args: Prisma.GoogleAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogleAuth>
          }
          groupBy: {
            args: Prisma.GoogleAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleAuthCountArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthCountAggregateOutputType> | number
          }
        }
      }
      DiscordAuth: {
        payload: Prisma.$DiscordAuthPayload<ExtArgs>
        fields: Prisma.DiscordAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscordAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscordAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          findFirst: {
            args: Prisma.DiscordAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscordAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          findMany: {
            args: Prisma.DiscordAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          create: {
            args: Prisma.DiscordAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          createMany: {
            args: Prisma.DiscordAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscordAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          delete: {
            args: Prisma.DiscordAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          update: {
            args: Prisma.DiscordAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          deleteMany: {
            args: Prisma.DiscordAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscordAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscordAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          upsert: {
            args: Prisma.DiscordAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          aggregate: {
            args: Prisma.DiscordAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscordAuth>
          }
          groupBy: {
            args: Prisma.DiscordAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscordAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscordAuthCountArgs<ExtArgs>
            result: $Utils.Optional<DiscordAuthCountAggregateOutputType> | number
          }
        }
      }
      MobileAuth: {
        payload: Prisma.$MobileAuthPayload<ExtArgs>
        fields: Prisma.MobileAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobileAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobileAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          findFirst: {
            args: Prisma.MobileAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobileAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          findMany: {
            args: Prisma.MobileAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          create: {
            args: Prisma.MobileAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          createMany: {
            args: Prisma.MobileAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MobileAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          delete: {
            args: Prisma.MobileAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          update: {
            args: Prisma.MobileAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          deleteMany: {
            args: Prisma.MobileAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MobileAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MobileAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          upsert: {
            args: Prisma.MobileAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          aggregate: {
            args: Prisma.MobileAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMobileAuth>
          }
          groupBy: {
            args: Prisma.MobileAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<MobileAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobileAuthCountArgs<ExtArgs>
            result: $Utils.Optional<MobileAuthCountAggregateOutputType> | number
          }
        }
      }
      EmailAuth: {
        payload: Prisma.$EmailAuthPayload<ExtArgs>
        fields: Prisma.EmailAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          findFirst: {
            args: Prisma.EmailAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          findMany: {
            args: Prisma.EmailAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          create: {
            args: Prisma.EmailAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          createMany: {
            args: Prisma.EmailAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          delete: {
            args: Prisma.EmailAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          update: {
            args: Prisma.EmailAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          deleteMany: {
            args: Prisma.EmailAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          upsert: {
            args: Prisma.EmailAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          aggregate: {
            args: Prisma.EmailAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAuth>
          }
          groupBy: {
            args: Prisma.EmailAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAuthCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAuthCountAggregateOutputType> | number
          }
        }
      }
      RiskDetectionRecord: {
        payload: Prisma.$RiskDetectionRecordPayload<ExtArgs>
        fields: Prisma.RiskDetectionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskDetectionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          findFirst: {
            args: Prisma.RiskDetectionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          findMany: {
            args: Prisma.RiskDetectionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          create: {
            args: Prisma.RiskDetectionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          createMany: {
            args: Prisma.RiskDetectionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          delete: {
            args: Prisma.RiskDetectionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          update: {
            args: Prisma.RiskDetectionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          deleteMany: {
            args: Prisma.RiskDetectionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskDetectionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          upsert: {
            args: Prisma.RiskDetectionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          aggregate: {
            args: Prisma.RiskDetectionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskDetectionRecord>
          }
          groupBy: {
            args: Prisma.RiskDetectionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskDetectionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskDetectionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<RiskDetectionRecordCountAggregateOutputType> | number
          }
        }
      }
      SystemTaskQueue: {
        payload: Prisma.$SystemTaskQueuePayload<ExtArgs>
        fields: Prisma.SystemTaskQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemTaskQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          findFirst: {
            args: Prisma.SystemTaskQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemTaskQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          findMany: {
            args: Prisma.SystemTaskQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          create: {
            args: Prisma.SystemTaskQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          createMany: {
            args: Prisma.SystemTaskQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemTaskQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          delete: {
            args: Prisma.SystemTaskQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          update: {
            args: Prisma.SystemTaskQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          deleteMany: {
            args: Prisma.SystemTaskQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemTaskQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          upsert: {
            args: Prisma.SystemTaskQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          aggregate: {
            args: Prisma.SystemTaskQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemTaskQueue>
          }
          groupBy: {
            args: Prisma.SystemTaskQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemTaskQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemTaskQueueCountArgs<ExtArgs>
            result: $Utils.Optional<SystemTaskQueueCountAggregateOutputType> | number
          }
        }
      }
      FileSource: {
        payload: Prisma.$FileSourcePayload<ExtArgs>
        fields: Prisma.FileSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          findFirst: {
            args: Prisma.FileSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          findMany: {
            args: Prisma.FileSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          create: {
            args: Prisma.FileSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          createMany: {
            args: Prisma.FileSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          delete: {
            args: Prisma.FileSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          update: {
            args: Prisma.FileSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          deleteMany: {
            args: Prisma.FileSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          upsert: {
            args: Prisma.FileSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          aggregate: {
            args: Prisma.FileSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileSource>
          }
          groupBy: {
            args: Prisma.FileSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileSourceCountArgs<ExtArgs>
            result: $Utils.Optional<FileSourceCountAggregateOutputType> | number
          }
        }
      }
      CountryCode: {
        payload: Prisma.$CountryCodePayload<ExtArgs>
        fields: Prisma.CountryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          findFirst: {
            args: Prisma.CountryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          findMany: {
            args: Prisma.CountryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          create: {
            args: Prisma.CountryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          createMany: {
            args: Prisma.CountryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          delete: {
            args: Prisma.CountryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          update: {
            args: Prisma.CountryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          deleteMany: {
            args: Prisma.CountryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          upsert: {
            args: Prisma.CountryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          aggregate: {
            args: Prisma.CountryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryCode>
          }
          groupBy: {
            args: Prisma.CountryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCodeCountAggregateOutputType> | number
          }
        }
      }
      Bot: {
        payload: Prisma.$BotPayload<ExtArgs>
        fields: Prisma.BotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findFirst: {
            args: Prisma.BotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findMany: {
            args: Prisma.BotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          create: {
            args: Prisma.BotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          createMany: {
            args: Prisma.BotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          delete: {
            args: Prisma.BotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          update: {
            args: Prisma.BotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          deleteMany: {
            args: Prisma.BotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          upsert: {
            args: Prisma.BotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          aggregate: {
            args: Prisma.BotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBot>
          }
          groupBy: {
            args: Prisma.BotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotCountArgs<ExtArgs>
            result: $Utils.Optional<BotCountAggregateOutputType> | number
          }
        }
      }
      ProviderKey: {
        payload: Prisma.$ProviderKeyPayload<ExtArgs>
        fields: Prisma.ProviderKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          findFirst: {
            args: Prisma.ProviderKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          findMany: {
            args: Prisma.ProviderKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          create: {
            args: Prisma.ProviderKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          createMany: {
            args: Prisma.ProviderKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          delete: {
            args: Prisma.ProviderKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          update: {
            args: Prisma.ProviderKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          deleteMany: {
            args: Prisma.ProviderKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          upsert: {
            args: Prisma.ProviderKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          aggregate: {
            args: Prisma.ProviderKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderKey>
          }
          groupBy: {
            args: Prisma.ProviderKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderKeyCountAggregateOutputType> | number
          }
        }
      }
      BotProviderKey: {
        payload: Prisma.$BotProviderKeyPayload<ExtArgs>
        fields: Prisma.BotProviderKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotProviderKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotProviderKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          findFirst: {
            args: Prisma.BotProviderKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotProviderKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          findMany: {
            args: Prisma.BotProviderKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          create: {
            args: Prisma.BotProviderKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          createMany: {
            args: Prisma.BotProviderKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotProviderKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          delete: {
            args: Prisma.BotProviderKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          update: {
            args: Prisma.BotProviderKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          deleteMany: {
            args: Prisma.BotProviderKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotProviderKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotProviderKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          upsert: {
            args: Prisma.BotProviderKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          aggregate: {
            args: Prisma.BotProviderKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotProviderKey>
          }
          groupBy: {
            args: Prisma.BotProviderKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotProviderKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotProviderKeyCountArgs<ExtArgs>
            result: $Utils.Optional<BotProviderKeyCountAggregateOutputType> | number
          }
        }
      }
      BotUsageLog: {
        payload: Prisma.$BotUsageLogPayload<ExtArgs>
        fields: Prisma.BotUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          findFirst: {
            args: Prisma.BotUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          findMany: {
            args: Prisma.BotUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          create: {
            args: Prisma.BotUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          createMany: {
            args: Prisma.BotUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          delete: {
            args: Prisma.BotUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          update: {
            args: Prisma.BotUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.BotUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.BotUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          aggregate: {
            args: Prisma.BotUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotUsageLog>
          }
          groupBy: {
            args: Prisma.BotUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<BotUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ProxyToken: {
        payload: Prisma.$ProxyTokenPayload<ExtArgs>
        fields: Prisma.ProxyTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          findFirst: {
            args: Prisma.ProxyTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          findMany: {
            args: Prisma.ProxyTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          create: {
            args: Prisma.ProxyTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          createMany: {
            args: Prisma.ProxyTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          delete: {
            args: Prisma.ProxyTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          update: {
            args: Prisma.ProxyTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          deleteMany: {
            args: Prisma.ProxyTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          upsert: {
            args: Prisma.ProxyTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          aggregate: {
            args: Prisma.ProxyTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxyToken>
          }
          groupBy: {
            args: Prisma.ProxyTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyTokenCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyTokenCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageRecipient: {
        payload: Prisma.$MessageRecipientPayload<ExtArgs>
        fields: Prisma.MessageRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          findFirst: {
            args: Prisma.MessageRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          findMany: {
            args: Prisma.MessageRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          create: {
            args: Prisma.MessageRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          createMany: {
            args: Prisma.MessageRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          delete: {
            args: Prisma.MessageRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          update: {
            args: Prisma.MessageRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          deleteMany: {
            args: Prisma.MessageRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          upsert: {
            args: Prisma.MessageRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          aggregate: {
            args: Prisma.MessageRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRecipient>
          }
          groupBy: {
            args: Prisma.MessageRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<MessageRecipientCountAggregateOutputType> | number
          }
        }
      }
      OperateLog: {
        payload: Prisma.$OperateLogPayload<ExtArgs>
        fields: Prisma.OperateLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperateLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperateLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          findFirst: {
            args: Prisma.OperateLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperateLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          findMany: {
            args: Prisma.OperateLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          create: {
            args: Prisma.OperateLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          createMany: {
            args: Prisma.OperateLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperateLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          delete: {
            args: Prisma.OperateLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          update: {
            args: Prisma.OperateLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          deleteMany: {
            args: Prisma.OperateLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperateLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperateLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          upsert: {
            args: Prisma.OperateLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          aggregate: {
            args: Prisma.OperateLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperateLog>
          }
          groupBy: {
            args: Prisma.OperateLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperateLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperateLogCountArgs<ExtArgs>
            result: $Utils.Optional<OperateLogCountAggregateOutputType> | number
          }
        }
      }
      ChannelDefinition: {
        payload: Prisma.$ChannelDefinitionPayload<ExtArgs>
        fields: Prisma.ChannelDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          findFirst: {
            args: Prisma.ChannelDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          findMany: {
            args: Prisma.ChannelDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          create: {
            args: Prisma.ChannelDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          createMany: {
            args: Prisma.ChannelDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          delete: {
            args: Prisma.ChannelDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          update: {
            args: Prisma.ChannelDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.ChannelDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          aggregate: {
            args: Prisma.ChannelDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelDefinition>
          }
          groupBy: {
            args: Prisma.ChannelDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelDefinitionCountAggregateOutputType> | number
          }
        }
      }
      ChannelCredentialField: {
        payload: Prisma.$ChannelCredentialFieldPayload<ExtArgs>
        fields: Prisma.ChannelCredentialFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelCredentialFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          findFirst: {
            args: Prisma.ChannelCredentialFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          findMany: {
            args: Prisma.ChannelCredentialFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          create: {
            args: Prisma.ChannelCredentialFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          createMany: {
            args: Prisma.ChannelCredentialFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          delete: {
            args: Prisma.ChannelCredentialFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          update: {
            args: Prisma.ChannelCredentialFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          deleteMany: {
            args: Prisma.ChannelCredentialFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelCredentialFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          upsert: {
            args: Prisma.ChannelCredentialFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          aggregate: {
            args: Prisma.ChannelCredentialFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelCredentialField>
          }
          groupBy: {
            args: Prisma.ChannelCredentialFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelCredentialFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCredentialFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCredentialFieldCountAggregateOutputType> | number
          }
        }
      }
      Plugin: {
        payload: Prisma.$PluginPayload<ExtArgs>
        fields: Prisma.PluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findFirst: {
            args: Prisma.PluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          findMany: {
            args: Prisma.PluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          create: {
            args: Prisma.PluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          createMany: {
            args: Prisma.PluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PluginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          delete: {
            args: Prisma.PluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          update: {
            args: Prisma.PluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          deleteMany: {
            args: Prisma.PluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PluginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>[]
          }
          upsert: {
            args: Prisma.PluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PluginPayload>
          }
          aggregate: {
            args: Prisma.PluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePlugin>
          }
          groupBy: {
            args: Prisma.PluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<PluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.PluginCountArgs<ExtArgs>
            result: $Utils.Optional<PluginCountAggregateOutputType> | number
          }
        }
      }
      BotPlugin: {
        payload: Prisma.$BotPluginPayload<ExtArgs>
        fields: Prisma.BotPluginFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotPluginFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotPluginFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          findFirst: {
            args: Prisma.BotPluginFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotPluginFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          findMany: {
            args: Prisma.BotPluginFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>[]
          }
          create: {
            args: Prisma.BotPluginCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          createMany: {
            args: Prisma.BotPluginCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotPluginCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>[]
          }
          delete: {
            args: Prisma.BotPluginDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          update: {
            args: Prisma.BotPluginUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          deleteMany: {
            args: Prisma.BotPluginDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotPluginUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotPluginUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>[]
          }
          upsert: {
            args: Prisma.BotPluginUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPluginPayload>
          }
          aggregate: {
            args: Prisma.BotPluginAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotPlugin>
          }
          groupBy: {
            args: Prisma.BotPluginGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotPluginGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotPluginCountArgs<ExtArgs>
            result: $Utils.Optional<BotPluginCountAggregateOutputType> | number
          }
        }
      }
      SkillType: {
        payload: Prisma.$SkillTypePayload<ExtArgs>
        fields: Prisma.SkillTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          findFirst: {
            args: Prisma.SkillTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          findMany: {
            args: Prisma.SkillTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>[]
          }
          create: {
            args: Prisma.SkillTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          createMany: {
            args: Prisma.SkillTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillTypeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>[]
          }
          delete: {
            args: Prisma.SkillTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          update: {
            args: Prisma.SkillTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          deleteMany: {
            args: Prisma.SkillTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillTypeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>[]
          }
          upsert: {
            args: Prisma.SkillTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillTypePayload>
          }
          aggregate: {
            args: Prisma.SkillTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkillType>
          }
          groupBy: {
            args: Prisma.SkillTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillTypeCountArgs<ExtArgs>
            result: $Utils.Optional<SkillTypeCountAggregateOutputType> | number
          }
        }
      }
      Skill: {
        payload: Prisma.$SkillPayload<ExtArgs>
        fields: Prisma.SkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findFirst: {
            args: Prisma.SkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          findMany: {
            args: Prisma.SkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          create: {
            args: Prisma.SkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          createMany: {
            args: Prisma.SkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          delete: {
            args: Prisma.SkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          update: {
            args: Prisma.SkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          deleteMany: {
            args: Prisma.SkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>[]
          }
          upsert: {
            args: Prisma.SkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SkillPayload>
          }
          aggregate: {
            args: Prisma.SkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSkill>
          }
          groupBy: {
            args: Prisma.SkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<SkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.SkillCountArgs<ExtArgs>
            result: $Utils.Optional<SkillCountAggregateOutputType> | number
          }
        }
      }
      BotSkill: {
        payload: Prisma.$BotSkillPayload<ExtArgs>
        fields: Prisma.BotSkillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotSkillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotSkillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          findFirst: {
            args: Prisma.BotSkillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotSkillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          findMany: {
            args: Prisma.BotSkillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>[]
          }
          create: {
            args: Prisma.BotSkillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          createMany: {
            args: Prisma.BotSkillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotSkillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>[]
          }
          delete: {
            args: Prisma.BotSkillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          update: {
            args: Prisma.BotSkillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          deleteMany: {
            args: Prisma.BotSkillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotSkillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotSkillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>[]
          }
          upsert: {
            args: Prisma.BotSkillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotSkillPayload>
          }
          aggregate: {
            args: Prisma.BotSkillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotSkill>
          }
          groupBy: {
            args: Prisma.BotSkillGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotSkillGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotSkillCountArgs<ExtArgs>
            result: $Utils.Optional<BotSkillCountAggregateOutputType> | number
          }
        }
      }
      ModelPricing: {
        payload: Prisma.$ModelPricingPayload<ExtArgs>
        fields: Prisma.ModelPricingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ModelPricingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ModelPricingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          findFirst: {
            args: Prisma.ModelPricingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ModelPricingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          findMany: {
            args: Prisma.ModelPricingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>[]
          }
          create: {
            args: Prisma.ModelPricingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          createMany: {
            args: Prisma.ModelPricingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ModelPricingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>[]
          }
          delete: {
            args: Prisma.ModelPricingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          update: {
            args: Prisma.ModelPricingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          deleteMany: {
            args: Prisma.ModelPricingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ModelPricingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ModelPricingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>[]
          }
          upsert: {
            args: Prisma.ModelPricingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ModelPricingPayload>
          }
          aggregate: {
            args: Prisma.ModelPricingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModelPricing>
          }
          groupBy: {
            args: Prisma.ModelPricingGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingGroupByOutputType>[]
          }
          count: {
            args: Prisma.ModelPricingCountArgs<ExtArgs>
            result: $Utils.Optional<ModelPricingCountAggregateOutputType> | number
          }
        }
      }
      BotModelRouting: {
        payload: Prisma.$BotModelRoutingPayload<ExtArgs>
        fields: Prisma.BotModelRoutingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotModelRoutingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotModelRoutingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          findFirst: {
            args: Prisma.BotModelRoutingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotModelRoutingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          findMany: {
            args: Prisma.BotModelRoutingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>[]
          }
          create: {
            args: Prisma.BotModelRoutingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          createMany: {
            args: Prisma.BotModelRoutingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotModelRoutingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>[]
          }
          delete: {
            args: Prisma.BotModelRoutingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          update: {
            args: Prisma.BotModelRoutingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          deleteMany: {
            args: Prisma.BotModelRoutingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotModelRoutingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotModelRoutingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>[]
          }
          upsert: {
            args: Prisma.BotModelRoutingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotModelRoutingPayload>
          }
          aggregate: {
            args: Prisma.BotModelRoutingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotModelRouting>
          }
          groupBy: {
            args: Prisma.BotModelRoutingGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotModelRoutingGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotModelRoutingCountArgs<ExtArgs>
            result: $Utils.Optional<BotModelRoutingCountAggregateOutputType> | number
          }
        }
      }
      BotChannel: {
        payload: Prisma.$BotChannelPayload<ExtArgs>
        fields: Prisma.BotChannelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotChannelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotChannelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          findFirst: {
            args: Prisma.BotChannelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotChannelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          findMany: {
            args: Prisma.BotChannelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>[]
          }
          create: {
            args: Prisma.BotChannelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          createMany: {
            args: Prisma.BotChannelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotChannelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>[]
          }
          delete: {
            args: Prisma.BotChannelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          update: {
            args: Prisma.BotChannelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          deleteMany: {
            args: Prisma.BotChannelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotChannelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotChannelUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>[]
          }
          upsert: {
            args: Prisma.BotChannelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotChannelPayload>
          }
          aggregate: {
            args: Prisma.BotChannelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotChannel>
          }
          groupBy: {
            args: Prisma.BotChannelGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotChannelGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotChannelCountArgs<ExtArgs>
            result: $Utils.Optional<BotChannelCountAggregateOutputType> | number
          }
        }
      }
      CapabilityTag: {
        payload: Prisma.$CapabilityTagPayload<ExtArgs>
        fields: Prisma.CapabilityTagFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CapabilityTagFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CapabilityTagFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          findFirst: {
            args: Prisma.CapabilityTagFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CapabilityTagFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          findMany: {
            args: Prisma.CapabilityTagFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>[]
          }
          create: {
            args: Prisma.CapabilityTagCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          createMany: {
            args: Prisma.CapabilityTagCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CapabilityTagCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>[]
          }
          delete: {
            args: Prisma.CapabilityTagDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          update: {
            args: Prisma.CapabilityTagUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          deleteMany: {
            args: Prisma.CapabilityTagDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CapabilityTagUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CapabilityTagUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>[]
          }
          upsert: {
            args: Prisma.CapabilityTagUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CapabilityTagPayload>
          }
          aggregate: {
            args: Prisma.CapabilityTagAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCapabilityTag>
          }
          groupBy: {
            args: Prisma.CapabilityTagGroupByArgs<ExtArgs>
            result: $Utils.Optional<CapabilityTagGroupByOutputType>[]
          }
          count: {
            args: Prisma.CapabilityTagCountArgs<ExtArgs>
            result: $Utils.Optional<CapabilityTagCountAggregateOutputType> | number
          }
        }
      }
      FallbackChain: {
        payload: Prisma.$FallbackChainPayload<ExtArgs>
        fields: Prisma.FallbackChainFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FallbackChainFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FallbackChainFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          findFirst: {
            args: Prisma.FallbackChainFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FallbackChainFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          findMany: {
            args: Prisma.FallbackChainFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>[]
          }
          create: {
            args: Prisma.FallbackChainCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          createMany: {
            args: Prisma.FallbackChainCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FallbackChainCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>[]
          }
          delete: {
            args: Prisma.FallbackChainDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          update: {
            args: Prisma.FallbackChainUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          deleteMany: {
            args: Prisma.FallbackChainDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FallbackChainUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FallbackChainUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>[]
          }
          upsert: {
            args: Prisma.FallbackChainUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FallbackChainPayload>
          }
          aggregate: {
            args: Prisma.FallbackChainAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFallbackChain>
          }
          groupBy: {
            args: Prisma.FallbackChainGroupByArgs<ExtArgs>
            result: $Utils.Optional<FallbackChainGroupByOutputType>[]
          }
          count: {
            args: Prisma.FallbackChainCountArgs<ExtArgs>
            result: $Utils.Optional<FallbackChainCountAggregateOutputType> | number
          }
        }
      }
      CostStrategy: {
        payload: Prisma.$CostStrategyPayload<ExtArgs>
        fields: Prisma.CostStrategyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CostStrategyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CostStrategyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          findFirst: {
            args: Prisma.CostStrategyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CostStrategyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          findMany: {
            args: Prisma.CostStrategyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>[]
          }
          create: {
            args: Prisma.CostStrategyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          createMany: {
            args: Prisma.CostStrategyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CostStrategyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>[]
          }
          delete: {
            args: Prisma.CostStrategyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          update: {
            args: Prisma.CostStrategyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          deleteMany: {
            args: Prisma.CostStrategyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CostStrategyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CostStrategyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>[]
          }
          upsert: {
            args: Prisma.CostStrategyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CostStrategyPayload>
          }
          aggregate: {
            args: Prisma.CostStrategyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCostStrategy>
          }
          groupBy: {
            args: Prisma.CostStrategyGroupByArgs<ExtArgs>
            result: $Utils.Optional<CostStrategyGroupByOutputType>[]
          }
          count: {
            args: Prisma.CostStrategyCountArgs<ExtArgs>
            result: $Utils.Optional<CostStrategyCountAggregateOutputType> | number
          }
        }
      }
      BotRoutingConfig: {
        payload: Prisma.$BotRoutingConfigPayload<ExtArgs>
        fields: Prisma.BotRoutingConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotRoutingConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotRoutingConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          findFirst: {
            args: Prisma.BotRoutingConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotRoutingConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          findMany: {
            args: Prisma.BotRoutingConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>[]
          }
          create: {
            args: Prisma.BotRoutingConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          createMany: {
            args: Prisma.BotRoutingConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotRoutingConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>[]
          }
          delete: {
            args: Prisma.BotRoutingConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          update: {
            args: Prisma.BotRoutingConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          deleteMany: {
            args: Prisma.BotRoutingConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotRoutingConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotRoutingConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>[]
          }
          upsert: {
            args: Prisma.BotRoutingConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotRoutingConfigPayload>
          }
          aggregate: {
            args: Prisma.BotRoutingConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotRoutingConfig>
          }
          groupBy: {
            args: Prisma.BotRoutingConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotRoutingConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotRoutingConfigCountArgs<ExtArgs>
            result: $Utils.Optional<BotRoutingConfigCountAggregateOutputType> | number
          }
        }
      }
      ComplexityRoutingConfig: {
        payload: Prisma.$ComplexityRoutingConfigPayload<ExtArgs>
        fields: Prisma.ComplexityRoutingConfigFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ComplexityRoutingConfigFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ComplexityRoutingConfigFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          findFirst: {
            args: Prisma.ComplexityRoutingConfigFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ComplexityRoutingConfigFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          findMany: {
            args: Prisma.ComplexityRoutingConfigFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>[]
          }
          create: {
            args: Prisma.ComplexityRoutingConfigCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          createMany: {
            args: Prisma.ComplexityRoutingConfigCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ComplexityRoutingConfigCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>[]
          }
          delete: {
            args: Prisma.ComplexityRoutingConfigDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          update: {
            args: Prisma.ComplexityRoutingConfigUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          deleteMany: {
            args: Prisma.ComplexityRoutingConfigDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ComplexityRoutingConfigUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ComplexityRoutingConfigUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>[]
          }
          upsert: {
            args: Prisma.ComplexityRoutingConfigUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ComplexityRoutingConfigPayload>
          }
          aggregate: {
            args: Prisma.ComplexityRoutingConfigAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateComplexityRoutingConfig>
          }
          groupBy: {
            args: Prisma.ComplexityRoutingConfigGroupByArgs<ExtArgs>
            result: $Utils.Optional<ComplexityRoutingConfigGroupByOutputType>[]
          }
          count: {
            args: Prisma.ComplexityRoutingConfigCountArgs<ExtArgs>
            result: $Utils.Optional<ComplexityRoutingConfigCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    userInfo?: UserInfoOmit
    personaTemplate?: PersonaTemplateOmit
    wechatAuth?: WechatAuthOmit
    googleAuth?: GoogleAuthOmit
    discordAuth?: DiscordAuthOmit
    mobileAuth?: MobileAuthOmit
    emailAuth?: EmailAuthOmit
    riskDetectionRecord?: RiskDetectionRecordOmit
    systemTaskQueue?: SystemTaskQueueOmit
    fileSource?: FileSourceOmit
    countryCode?: CountryCodeOmit
    bot?: BotOmit
    providerKey?: ProviderKeyOmit
    botProviderKey?: BotProviderKeyOmit
    botUsageLog?: BotUsageLogOmit
    proxyToken?: ProxyTokenOmit
    message?: MessageOmit
    messageRecipient?: MessageRecipientOmit
    operateLog?: OperateLogOmit
    channelDefinition?: ChannelDefinitionOmit
    channelCredentialField?: ChannelCredentialFieldOmit
    plugin?: PluginOmit
    botPlugin?: BotPluginOmit
    skillType?: SkillTypeOmit
    skill?: SkillOmit
    botSkill?: BotSkillOmit
    modelPricing?: ModelPricingOmit
    botModelRouting?: BotModelRoutingOmit
    botChannel?: BotChannelOmit
    capabilityTag?: CapabilityTagOmit
    fallbackChain?: FallbackChainOmit
    costStrategy?: CostStrategyOmit
    botRoutingConfig?: BotRoutingConfigOmit
    complexityRoutingConfig?: ComplexityRoutingConfigOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserInfoCountOutputType
   */

  export type UserInfoCountOutputType = {
    sentMessages: number
    receivedMessages: number
    bots: number
    providerKeys: number
    personaTemplates: number
    operateLogs: number
  }

  export type UserInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | UserInfoCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserInfoCountOutputTypeCountReceivedMessagesArgs
    bots?: boolean | UserInfoCountOutputTypeCountBotsArgs
    providerKeys?: boolean | UserInfoCountOutputTypeCountProviderKeysArgs
    personaTemplates?: boolean | UserInfoCountOutputTypeCountPersonaTemplatesArgs
    operateLogs?: boolean | UserInfoCountOutputTypeCountOperateLogsArgs
  }

  // Custom InputTypes
  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfoCountOutputType
     */
    select?: UserInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderKeyWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountPersonaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountOperateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperateLogWhereInput
  }


  /**
   * Count Type PersonaTemplateCountOutputType
   */

  export type PersonaTemplateCountOutputType = {
    bots: number
  }

  export type PersonaTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | PersonaTemplateCountOutputTypeCountBotsArgs
  }

  // Custom InputTypes
  /**
   * PersonaTemplateCountOutputType without action
   */
  export type PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplateCountOutputType
     */
    select?: PersonaTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonaTemplateCountOutputType without action
   */
  export type PersonaTemplateCountOutputTypeCountBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }


  /**
   * Count Type FileSourceCountOutputType
   */

  export type FileSourceCountOutputType = {
    userAvatars: number
    personaTemplates: number
    botAvatars: number
  }

  export type FileSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAvatars?: boolean | FileSourceCountOutputTypeCountUserAvatarsArgs
    personaTemplates?: boolean | FileSourceCountOutputTypeCountPersonaTemplatesArgs
    botAvatars?: boolean | FileSourceCountOutputTypeCountBotAvatarsArgs
  }

  // Custom InputTypes
  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSourceCountOutputType
     */
    select?: FileSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountUserAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInfoWhereInput
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountPersonaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountBotAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }


  /**
   * Count Type BotCountOutputType
   */

  export type BotCountOutputType = {
    providerKeys: number
    usageLogs: number
    plugins: number
    skills: number
    channels: number
    modelRoutings: number
  }

  export type BotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providerKeys?: boolean | BotCountOutputTypeCountProviderKeysArgs
    usageLogs?: boolean | BotCountOutputTypeCountUsageLogsArgs
    plugins?: boolean | BotCountOutputTypeCountPluginsArgs
    skills?: boolean | BotCountOutputTypeCountSkillsArgs
    channels?: boolean | BotCountOutputTypeCountChannelsArgs
    modelRoutings?: boolean | BotCountOutputTypeCountModelRoutingsArgs
  }

  // Custom InputTypes
  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotCountOutputType
     */
    select?: BotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountPluginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotPluginWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotSkillWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountChannelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotChannelWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountModelRoutingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotModelRoutingWhereInput
  }


  /**
   * Count Type ProviderKeyCountOutputType
   */

  export type ProviderKeyCountOutputType = {
    botProviderKeys: number
    usageLogs: number
    proxyTokens: number
  }

  export type ProviderKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    botProviderKeys?: boolean | ProviderKeyCountOutputTypeCountBotProviderKeysArgs
    usageLogs?: boolean | ProviderKeyCountOutputTypeCountUsageLogsArgs
    proxyTokens?: boolean | ProviderKeyCountOutputTypeCountProxyTokensArgs
  }

  // Custom InputTypes
  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKeyCountOutputType
     */
    select?: ProviderKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountBotProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountProxyTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyTokenWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    recipients: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | MessageCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
  }


  /**
   * Count Type ChannelDefinitionCountOutputType
   */

  export type ChannelDefinitionCountOutputType = {
    credentialFields: number
  }

  export type ChannelDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credentialFields?: boolean | ChannelDefinitionCountOutputTypeCountCredentialFieldsArgs
  }

  // Custom InputTypes
  /**
   * ChannelDefinitionCountOutputType without action
   */
  export type ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinitionCountOutputType
     */
    select?: ChannelDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelDefinitionCountOutputType without action
   */
  export type ChannelDefinitionCountOutputTypeCountCredentialFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCredentialFieldWhereInput
  }


  /**
   * Count Type PluginCountOutputType
   */

  export type PluginCountOutputType = {
    installations: number
  }

  export type PluginCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | PluginCountOutputTypeCountInstallationsArgs
  }

  // Custom InputTypes
  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PluginCountOutputType
     */
    select?: PluginCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PluginCountOutputType without action
   */
  export type PluginCountOutputTypeCountInstallationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotPluginWhereInput
  }


  /**
   * Count Type SkillTypeCountOutputType
   */

  export type SkillTypeCountOutputType = {
    skills: number
  }

  export type SkillTypeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | SkillTypeCountOutputTypeCountSkillsArgs
  }

  // Custom InputTypes
  /**
   * SkillTypeCountOutputType without action
   */
  export type SkillTypeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillTypeCountOutputType
     */
    select?: SkillTypeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillTypeCountOutputType without action
   */
  export type SkillTypeCountOutputTypeCountSkillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
  }


  /**
   * Count Type SkillCountOutputType
   */

  export type SkillCountOutputType = {
    installations: number
  }

  export type SkillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | SkillCountOutputTypeCountInstallationsArgs
  }

  // Custom InputTypes
  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillCountOutputType
     */
    select?: SkillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SkillCountOutputType without action
   */
  export type SkillCountOutputTypeCountInstallationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotSkillWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserInfo
   */

  export type AggregateUserInfo = {
    _count: UserInfoCountAggregateOutputType | null
    _min: UserInfoMinAggregateOutputType | null
    _max: UserInfoMaxAggregateOutputType | null
  }

  export type UserInfoMinAggregateOutputType = {
    id: string | null
    nickname: string | null
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType | null
    locale: string | null
    isAnonymity: boolean | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
  }

  export type UserInfoMaxAggregateOutputType = {
    id: string | null
    nickname: string | null
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType | null
    locale: string | null
    isAnonymity: boolean | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
  }

  export type UserInfoCountAggregateOutputType = {
    id: number
    nickname: number
    code: number
    avatarFileId: number
    sex: number
    locale: number
    isAnonymity: number
    isAdmin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    deviceId: number
    wechatOpenid: number
    wechatUnionId: number
    googleSub: number
    discordId: number
    mobile: number
    email: number
    _all: number
  }


  export type UserInfoMinAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
  }

  export type UserInfoMaxAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
  }

  export type UserInfoCountAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
    _all?: true
  }

  export type UserInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInfo to aggregate.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInfos
    **/
    _count?: true | UserInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInfoMaxAggregateInputType
  }

  export type GetUserInfoAggregateType<T extends UserInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInfo[P]>
      : GetScalarType<T[P], AggregateUserInfo[P]>
  }




  export type UserInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInfoWhereInput
    orderBy?: UserInfoOrderByWithAggregationInput | UserInfoOrderByWithAggregationInput[]
    by: UserInfoScalarFieldEnum[] | UserInfoScalarFieldEnum
    having?: UserInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInfoCountAggregateInputType | true
    _min?: UserInfoMinAggregateInputType
    _max?: UserInfoMaxAggregateInputType
  }

  export type UserInfoGroupByOutputType = {
    id: string
    nickname: string
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType
    locale: string | null
    isAnonymity: boolean
    isAdmin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
    _count: UserInfoCountAggregateOutputType | null
    _min: UserInfoMinAggregateOutputType | null
    _max: UserInfoMaxAggregateOutputType | null
  }

  type GetUserInfoGroupByPayload<T extends UserInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInfoGroupByOutputType[P]>
            : GetScalarType<T[P], UserInfoGroupByOutputType[P]>
        }
      >
    >


  export type UserInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
    wechatAuth?: boolean | UserInfo$wechatAuthArgs<ExtArgs>
    googleAuth?: boolean | UserInfo$googleAuthArgs<ExtArgs>
    discordAuth?: boolean | UserInfo$discordAuthArgs<ExtArgs>
    mobileAuth?: boolean | UserInfo$mobileAuthArgs<ExtArgs>
    emailAuth?: boolean | UserInfo$emailAuthArgs<ExtArgs>
    sentMessages?: boolean | UserInfo$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | UserInfo$receivedMessagesArgs<ExtArgs>
    bots?: boolean | UserInfo$botsArgs<ExtArgs>
    providerKeys?: boolean | UserInfo$providerKeysArgs<ExtArgs>
    personaTemplates?: boolean | UserInfo$personaTemplatesArgs<ExtArgs>
    operateLogs?: boolean | UserInfo$operateLogsArgs<ExtArgs>
    _count?: boolean | UserInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectScalar = {
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
  }

  export type UserInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nickname" | "code" | "avatarFileId" | "sex" | "locale" | "isAnonymity" | "isAdmin" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt" | "deviceId" | "wechatOpenid" | "wechatUnionId" | "googleSub" | "discordId" | "mobile" | "email", ExtArgs["result"]["userInfo"]>
  export type UserInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
    wechatAuth?: boolean | UserInfo$wechatAuthArgs<ExtArgs>
    googleAuth?: boolean | UserInfo$googleAuthArgs<ExtArgs>
    discordAuth?: boolean | UserInfo$discordAuthArgs<ExtArgs>
    mobileAuth?: boolean | UserInfo$mobileAuthArgs<ExtArgs>
    emailAuth?: boolean | UserInfo$emailAuthArgs<ExtArgs>
    sentMessages?: boolean | UserInfo$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | UserInfo$receivedMessagesArgs<ExtArgs>
    bots?: boolean | UserInfo$botsArgs<ExtArgs>
    providerKeys?: boolean | UserInfo$providerKeysArgs<ExtArgs>
    personaTemplates?: boolean | UserInfo$personaTemplatesArgs<ExtArgs>
    operateLogs?: boolean | UserInfo$operateLogsArgs<ExtArgs>
    _count?: boolean | UserInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }
  export type UserInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }

  export type $UserInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInfo"
    objects: {
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      wechatAuth: Prisma.$WechatAuthPayload<ExtArgs> | null
      googleAuth: Prisma.$GoogleAuthPayload<ExtArgs> | null
      discordAuth: Prisma.$DiscordAuthPayload<ExtArgs> | null
      mobileAuth: Prisma.$MobileAuthPayload<ExtArgs> | null
      emailAuth: Prisma.$EmailAuthPayload<ExtArgs> | null
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessageRecipientPayload<ExtArgs>[]
      bots: Prisma.$BotPayload<ExtArgs>[]
      providerKeys: Prisma.$ProviderKeyPayload<ExtArgs>[]
      personaTemplates: Prisma.$PersonaTemplatePayload<ExtArgs>[]
      operateLogs: Prisma.$OperateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nickname: string
      code: string | null
      avatarFileId: string | null
      sex: $Enums.SexType
      locale: string | null
      isAnonymity: boolean
      isAdmin: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      deviceId: string | null
      wechatOpenid: string | null
      wechatUnionId: string | null
      googleSub: string | null
      discordId: string | null
      mobile: string | null
      email: string | null
    }, ExtArgs["result"]["userInfo"]>
    composites: {}
  }

  type UserInfoGetPayload<S extends boolean | null | undefined | UserInfoDefaultArgs> = $Result.GetResult<Prisma.$UserInfoPayload, S>

  type UserInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInfoCountAggregateInputType | true
    }

  export interface UserInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInfo'], meta: { name: 'UserInfo' } }
    /**
     * Find zero or one UserInfo that matches the filter.
     * @param {UserInfoFindUniqueArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInfoFindUniqueArgs>(args: SelectSubset<T, UserInfoFindUniqueArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInfoFindUniqueOrThrowArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindFirstArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInfoFindFirstArgs>(args?: SelectSubset<T, UserInfoFindFirstArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindFirstOrThrowArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInfos
     * const userInfos = await prisma.userInfo.findMany()
     * 
     * // Get first 10 UserInfos
     * const userInfos = await prisma.userInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInfoFindManyArgs>(args?: SelectSubset<T, UserInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInfo.
     * @param {UserInfoCreateArgs} args - Arguments to create a UserInfo.
     * @example
     * // Create one UserInfo
     * const UserInfo = await prisma.userInfo.create({
     *   data: {
     *     // ... data to create a UserInfo
     *   }
     * })
     * 
     */
    create<T extends UserInfoCreateArgs>(args: SelectSubset<T, UserInfoCreateArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInfos.
     * @param {UserInfoCreateManyArgs} args - Arguments to create many UserInfos.
     * @example
     * // Create many UserInfos
     * const userInfo = await prisma.userInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInfoCreateManyArgs>(args?: SelectSubset<T, UserInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInfos and returns the data saved in the database.
     * @param {UserInfoCreateManyAndReturnArgs} args - Arguments to create many UserInfos.
     * @example
     * // Create many UserInfos
     * const userInfo = await prisma.userInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInfos and only return the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInfo.
     * @param {UserInfoDeleteArgs} args - Arguments to delete one UserInfo.
     * @example
     * // Delete one UserInfo
     * const UserInfo = await prisma.userInfo.delete({
     *   where: {
     *     // ... filter to delete one UserInfo
     *   }
     * })
     * 
     */
    delete<T extends UserInfoDeleteArgs>(args: SelectSubset<T, UserInfoDeleteArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInfo.
     * @param {UserInfoUpdateArgs} args - Arguments to update one UserInfo.
     * @example
     * // Update one UserInfo
     * const userInfo = await prisma.userInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInfoUpdateArgs>(args: SelectSubset<T, UserInfoUpdateArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInfos.
     * @param {UserInfoDeleteManyArgs} args - Arguments to filter UserInfos to delete.
     * @example
     * // Delete a few UserInfos
     * const { count } = await prisma.userInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInfoDeleteManyArgs>(args?: SelectSubset<T, UserInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInfos
     * const userInfo = await prisma.userInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInfoUpdateManyArgs>(args: SelectSubset<T, UserInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInfos and returns the data updated in the database.
     * @param {UserInfoUpdateManyAndReturnArgs} args - Arguments to update many UserInfos.
     * @example
     * // Update many UserInfos
     * const userInfo = await prisma.userInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInfos and only return the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInfo.
     * @param {UserInfoUpsertArgs} args - Arguments to update or create a UserInfo.
     * @example
     * // Update or create a UserInfo
     * const userInfo = await prisma.userInfo.upsert({
     *   create: {
     *     // ... data to create a UserInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInfo we want to update
     *   }
     * })
     */
    upsert<T extends UserInfoUpsertArgs>(args: SelectSubset<T, UserInfoUpsertArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoCountArgs} args - Arguments to filter UserInfos to count.
     * @example
     * // Count the number of UserInfos
     * const count = await prisma.userInfo.count({
     *   where: {
     *     // ... the filter for the UserInfos we want to count
     *   }
     * })
    **/
    count<T extends UserInfoCountArgs>(
      args?: Subset<T, UserInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInfoAggregateArgs>(args: Subset<T, UserInfoAggregateArgs>): Prisma.PrismaPromise<GetUserInfoAggregateType<T>>

    /**
     * Group by UserInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInfoGroupByArgs['orderBy'] }
        : { orderBy?: UserInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInfo model
   */
  readonly fields: UserInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatarFile<T extends UserInfo$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wechatAuth<T extends UserInfo$wechatAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$wechatAuthArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    googleAuth<T extends UserInfo$googleAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$googleAuthArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    discordAuth<T extends UserInfo$discordAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$discordAuthArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mobileAuth<T extends UserInfo$mobileAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$mobileAuthArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailAuth<T extends UserInfo$emailAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$emailAuthArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentMessages<T extends UserInfo$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends UserInfo$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bots<T extends UserInfo$botsArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$botsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providerKeys<T extends UserInfo$providerKeysArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$providerKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personaTemplates<T extends UserInfo$personaTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$personaTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operateLogs<T extends UserInfo$operateLogsArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$operateLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInfo model
   */
  interface UserInfoFieldRefs {
    readonly id: FieldRef<"UserInfo", 'String'>
    readonly nickname: FieldRef<"UserInfo", 'String'>
    readonly code: FieldRef<"UserInfo", 'String'>
    readonly avatarFileId: FieldRef<"UserInfo", 'String'>
    readonly sex: FieldRef<"UserInfo", 'SexType'>
    readonly locale: FieldRef<"UserInfo", 'String'>
    readonly isAnonymity: FieldRef<"UserInfo", 'Boolean'>
    readonly isAdmin: FieldRef<"UserInfo", 'Boolean'>
    readonly isDeleted: FieldRef<"UserInfo", 'Boolean'>
    readonly createdAt: FieldRef<"UserInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInfo", 'DateTime'>
    readonly deletedAt: FieldRef<"UserInfo", 'DateTime'>
    readonly deviceId: FieldRef<"UserInfo", 'String'>
    readonly wechatOpenid: FieldRef<"UserInfo", 'String'>
    readonly wechatUnionId: FieldRef<"UserInfo", 'String'>
    readonly googleSub: FieldRef<"UserInfo", 'String'>
    readonly discordId: FieldRef<"UserInfo", 'String'>
    readonly mobile: FieldRef<"UserInfo", 'String'>
    readonly email: FieldRef<"UserInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserInfo findUnique
   */
  export type UserInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo findUniqueOrThrow
   */
  export type UserInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo findFirst
   */
  export type UserInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInfos.
     */
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo findFirstOrThrow
   */
  export type UserInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInfos.
     */
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo findMany
   */
  export type UserInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfos to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo create
   */
  export type UserInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInfo.
     */
    data: XOR<UserInfoCreateInput, UserInfoUncheckedCreateInput>
  }

  /**
   * UserInfo createMany
   */
  export type UserInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInfos.
     */
    data: UserInfoCreateManyInput | UserInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInfo createManyAndReturn
   */
  export type UserInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * The data used to create many UserInfos.
     */
    data: UserInfoCreateManyInput | UserInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInfo update
   */
  export type UserInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInfo.
     */
    data: XOR<UserInfoUpdateInput, UserInfoUncheckedUpdateInput>
    /**
     * Choose, which UserInfo to update.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo updateMany
   */
  export type UserInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInfos.
     */
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyInput>
    /**
     * Filter which UserInfos to update
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to update.
     */
    limit?: number
  }

  /**
   * UserInfo updateManyAndReturn
   */
  export type UserInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * The data used to update UserInfos.
     */
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyInput>
    /**
     * Filter which UserInfos to update
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInfo upsert
   */
  export type UserInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInfo to update in case it exists.
     */
    where: UserInfoWhereUniqueInput
    /**
     * In case the UserInfo found by the `where` argument doesn't exist, create a new UserInfo with this data.
     */
    create: XOR<UserInfoCreateInput, UserInfoUncheckedCreateInput>
    /**
     * In case the UserInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInfoUpdateInput, UserInfoUncheckedUpdateInput>
  }

  /**
   * UserInfo delete
   */
  export type UserInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter which UserInfo to delete.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo deleteMany
   */
  export type UserInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInfos to delete
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to delete.
     */
    limit?: number
  }

  /**
   * UserInfo.avatarFile
   */
  export type UserInfo$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * UserInfo.wechatAuth
   */
  export type UserInfo$wechatAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    where?: WechatAuthWhereInput
  }

  /**
   * UserInfo.googleAuth
   */
  export type UserInfo$googleAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    where?: GoogleAuthWhereInput
  }

  /**
   * UserInfo.discordAuth
   */
  export type UserInfo$discordAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    where?: DiscordAuthWhereInput
  }

  /**
   * UserInfo.mobileAuth
   */
  export type UserInfo$mobileAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    where?: MobileAuthWhereInput
  }

  /**
   * UserInfo.emailAuth
   */
  export type UserInfo$emailAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    where?: EmailAuthWhereInput
  }

  /**
   * UserInfo.sentMessages
   */
  export type UserInfo$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * UserInfo.receivedMessages
   */
  export type UserInfo$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    cursor?: MessageRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * UserInfo.bots
   */
  export type UserInfo$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * UserInfo.providerKeys
   */
  export type UserInfo$providerKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    where?: ProviderKeyWhereInput
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    cursor?: ProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * UserInfo.personaTemplates
   */
  export type UserInfo$personaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    cursor?: PersonaTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * UserInfo.operateLogs
   */
  export type UserInfo$operateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    where?: OperateLogWhereInput
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    cursor?: OperateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * UserInfo without action
   */
  export type UserInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
  }


  /**
   * Model PersonaTemplate
   */

  export type AggregatePersonaTemplate = {
    _count: PersonaTemplateCountAggregateOutputType | null
    _min: PersonaTemplateMinAggregateOutputType | null
    _max: PersonaTemplateMaxAggregateOutputType | null
  }

  export type PersonaTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    emoji: string | null
    avatarFileId: string | null
    tagline: string | null
    soulMarkdown: string | null
    soulPreview: string | null
    isSystem: boolean | null
    locale: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonaTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    emoji: string | null
    avatarFileId: string | null
    tagline: string | null
    soulMarkdown: string | null
    soulPreview: string | null
    isSystem: boolean | null
    locale: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonaTemplateCountAggregateOutputType = {
    id: number
    name: number
    emoji: number
    avatarFileId: number
    tagline: number
    soulMarkdown: number
    soulPreview: number
    isSystem: number
    locale: number
    createdById: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PersonaTemplateMinAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    locale?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonaTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    locale?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonaTemplateCountAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    locale?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PersonaTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonaTemplate to aggregate.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonaTemplates
    **/
    _count?: true | PersonaTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaTemplateMaxAggregateInputType
  }

  export type GetPersonaTemplateAggregateType<T extends PersonaTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaTemplate[P]>
      : GetScalarType<T[P], AggregatePersonaTemplate[P]>
  }




  export type PersonaTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithAggregationInput | PersonaTemplateOrderByWithAggregationInput[]
    by: PersonaTemplateScalarFieldEnum[] | PersonaTemplateScalarFieldEnum
    having?: PersonaTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaTemplateCountAggregateInputType | true
    _min?: PersonaTemplateMinAggregateInputType
    _max?: PersonaTemplateMaxAggregateInputType
  }

  export type PersonaTemplateGroupByOutputType = {
    id: string
    name: string
    emoji: string | null
    avatarFileId: string | null
    tagline: string
    soulMarkdown: string
    soulPreview: string | null
    isSystem: boolean
    locale: string
    createdById: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PersonaTemplateCountAggregateOutputType | null
    _min: PersonaTemplateMinAggregateOutputType | null
    _max: PersonaTemplateMaxAggregateOutputType | null
  }

  type GetPersonaTemplateGroupByPayload<T extends PersonaTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonaTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PersonaTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    locale?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
    bots?: boolean | PersonaTemplate$botsArgs<ExtArgs>
    _count?: boolean | PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    locale?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    locale?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    locale?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PersonaTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "emoji" | "avatarFileId" | "tagline" | "soulMarkdown" | "soulPreview" | "isSystem" | "locale" | "createdById" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["personaTemplate"]>
  export type PersonaTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
    bots?: boolean | PersonaTemplate$botsArgs<ExtArgs>
    _count?: boolean | PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonaTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }
  export type PersonaTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }

  export type $PersonaTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonaTemplate"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs> | null
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      bots: Prisma.$BotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      emoji: string | null
      avatarFileId: string | null
      tagline: string
      soulMarkdown: string
      soulPreview: string | null
      isSystem: boolean
      locale: string
      createdById: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["personaTemplate"]>
    composites: {}
  }

  type PersonaTemplateGetPayload<S extends boolean | null | undefined | PersonaTemplateDefaultArgs> = $Result.GetResult<Prisma.$PersonaTemplatePayload, S>

  type PersonaTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonaTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonaTemplateCountAggregateInputType | true
    }

  export interface PersonaTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonaTemplate'], meta: { name: 'PersonaTemplate' } }
    /**
     * Find zero or one PersonaTemplate that matches the filter.
     * @param {PersonaTemplateFindUniqueArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonaTemplateFindUniqueArgs>(args: SelectSubset<T, PersonaTemplateFindUniqueArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonaTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonaTemplateFindUniqueOrThrowArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonaTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonaTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonaTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindFirstArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonaTemplateFindFirstArgs>(args?: SelectSubset<T, PersonaTemplateFindFirstArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonaTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindFirstOrThrowArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonaTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonaTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonaTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonaTemplates
     * const personaTemplates = await prisma.personaTemplate.findMany()
     * 
     * // Get first 10 PersonaTemplates
     * const personaTemplates = await prisma.personaTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonaTemplateFindManyArgs>(args?: SelectSubset<T, PersonaTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonaTemplate.
     * @param {PersonaTemplateCreateArgs} args - Arguments to create a PersonaTemplate.
     * @example
     * // Create one PersonaTemplate
     * const PersonaTemplate = await prisma.personaTemplate.create({
     *   data: {
     *     // ... data to create a PersonaTemplate
     *   }
     * })
     * 
     */
    create<T extends PersonaTemplateCreateArgs>(args: SelectSubset<T, PersonaTemplateCreateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonaTemplates.
     * @param {PersonaTemplateCreateManyArgs} args - Arguments to create many PersonaTemplates.
     * @example
     * // Create many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonaTemplateCreateManyArgs>(args?: SelectSubset<T, PersonaTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonaTemplates and returns the data saved in the database.
     * @param {PersonaTemplateCreateManyAndReturnArgs} args - Arguments to create many PersonaTemplates.
     * @example
     * // Create many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonaTemplates and only return the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonaTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonaTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonaTemplate.
     * @param {PersonaTemplateDeleteArgs} args - Arguments to delete one PersonaTemplate.
     * @example
     * // Delete one PersonaTemplate
     * const PersonaTemplate = await prisma.personaTemplate.delete({
     *   where: {
     *     // ... filter to delete one PersonaTemplate
     *   }
     * })
     * 
     */
    delete<T extends PersonaTemplateDeleteArgs>(args: SelectSubset<T, PersonaTemplateDeleteArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonaTemplate.
     * @param {PersonaTemplateUpdateArgs} args - Arguments to update one PersonaTemplate.
     * @example
     * // Update one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonaTemplateUpdateArgs>(args: SelectSubset<T, PersonaTemplateUpdateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonaTemplates.
     * @param {PersonaTemplateDeleteManyArgs} args - Arguments to filter PersonaTemplates to delete.
     * @example
     * // Delete a few PersonaTemplates
     * const { count } = await prisma.personaTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonaTemplateDeleteManyArgs>(args?: SelectSubset<T, PersonaTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonaTemplateUpdateManyArgs>(args: SelectSubset<T, PersonaTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonaTemplates and returns the data updated in the database.
     * @param {PersonaTemplateUpdateManyAndReturnArgs} args - Arguments to update many PersonaTemplates.
     * @example
     * // Update many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonaTemplates and only return the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonaTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonaTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonaTemplate.
     * @param {PersonaTemplateUpsertArgs} args - Arguments to update or create a PersonaTemplate.
     * @example
     * // Update or create a PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.upsert({
     *   create: {
     *     // ... data to create a PersonaTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonaTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PersonaTemplateUpsertArgs>(args: SelectSubset<T, PersonaTemplateUpsertArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateCountArgs} args - Arguments to filter PersonaTemplates to count.
     * @example
     * // Count the number of PersonaTemplates
     * const count = await prisma.personaTemplate.count({
     *   where: {
     *     // ... the filter for the PersonaTemplates we want to count
     *   }
     * })
    **/
    count<T extends PersonaTemplateCountArgs>(
      args?: Subset<T, PersonaTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaTemplateAggregateArgs>(args: Subset<T, PersonaTemplateAggregateArgs>): Prisma.PrismaPromise<GetPersonaTemplateAggregateType<T>>

    /**
     * Group by PersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonaTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonaTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PersonaTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonaTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonaTemplate model
   */
  readonly fields: PersonaTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonaTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonaTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends PersonaTemplate$createdByArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$createdByArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avatarFile<T extends PersonaTemplate$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bots<T extends PersonaTemplate$botsArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$botsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonaTemplate model
   */
  interface PersonaTemplateFieldRefs {
    readonly id: FieldRef<"PersonaTemplate", 'String'>
    readonly name: FieldRef<"PersonaTemplate", 'String'>
    readonly emoji: FieldRef<"PersonaTemplate", 'String'>
    readonly avatarFileId: FieldRef<"PersonaTemplate", 'String'>
    readonly tagline: FieldRef<"PersonaTemplate", 'String'>
    readonly soulMarkdown: FieldRef<"PersonaTemplate", 'String'>
    readonly soulPreview: FieldRef<"PersonaTemplate", 'String'>
    readonly isSystem: FieldRef<"PersonaTemplate", 'Boolean'>
    readonly locale: FieldRef<"PersonaTemplate", 'String'>
    readonly createdById: FieldRef<"PersonaTemplate", 'String'>
    readonly isDeleted: FieldRef<"PersonaTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"PersonaTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonaTemplate", 'DateTime'>
    readonly deletedAt: FieldRef<"PersonaTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonaTemplate findUnique
   */
  export type PersonaTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate findUniqueOrThrow
   */
  export type PersonaTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate findFirst
   */
  export type PersonaTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonaTemplates.
     */
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate findFirstOrThrow
   */
  export type PersonaTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonaTemplates.
     */
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate findMany
   */
  export type PersonaTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplates to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate create
   */
  export type PersonaTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonaTemplate.
     */
    data: XOR<PersonaTemplateCreateInput, PersonaTemplateUncheckedCreateInput>
  }

  /**
   * PersonaTemplate createMany
   */
  export type PersonaTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonaTemplates.
     */
    data: PersonaTemplateCreateManyInput | PersonaTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonaTemplate createManyAndReturn
   */
  export type PersonaTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many PersonaTemplates.
     */
    data: PersonaTemplateCreateManyInput | PersonaTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonaTemplate update
   */
  export type PersonaTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonaTemplate.
     */
    data: XOR<PersonaTemplateUpdateInput, PersonaTemplateUncheckedUpdateInput>
    /**
     * Choose, which PersonaTemplate to update.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate updateMany
   */
  export type PersonaTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonaTemplates.
     */
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PersonaTemplates to update
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to update.
     */
    limit?: number
  }

  /**
   * PersonaTemplate updateManyAndReturn
   */
  export type PersonaTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * The data used to update PersonaTemplates.
     */
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PersonaTemplates to update
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonaTemplate upsert
   */
  export type PersonaTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonaTemplate to update in case it exists.
     */
    where: PersonaTemplateWhereUniqueInput
    /**
     * In case the PersonaTemplate found by the `where` argument doesn't exist, create a new PersonaTemplate with this data.
     */
    create: XOR<PersonaTemplateCreateInput, PersonaTemplateUncheckedCreateInput>
    /**
     * In case the PersonaTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonaTemplateUpdateInput, PersonaTemplateUncheckedUpdateInput>
  }

  /**
   * PersonaTemplate delete
   */
  export type PersonaTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter which PersonaTemplate to delete.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate deleteMany
   */
  export type PersonaTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonaTemplates to delete
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to delete.
     */
    limit?: number
  }

  /**
   * PersonaTemplate.createdBy
   */
  export type PersonaTemplate$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
  }

  /**
   * PersonaTemplate.avatarFile
   */
  export type PersonaTemplate$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * PersonaTemplate.bots
   */
  export type PersonaTemplate$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * PersonaTemplate without action
   */
  export type PersonaTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
  }


  /**
   * Model WechatAuth
   */

  export type AggregateWechatAuth = {
    _count: WechatAuthCountAggregateOutputType | null
    _min: WechatAuthMinAggregateOutputType | null
    _max: WechatAuthMaxAggregateOutputType | null
  }

  export type WechatAuthMinAggregateOutputType = {
    openid: string | null
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WechatAuthMaxAggregateOutputType = {
    openid: string | null
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WechatAuthCountAggregateOutputType = {
    openid: number
    sessionKey: number
    refreshToken: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WechatAuthMinAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WechatAuthMaxAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WechatAuthCountAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WechatAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WechatAuth to aggregate.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WechatAuths
    **/
    _count?: true | WechatAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WechatAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WechatAuthMaxAggregateInputType
  }

  export type GetWechatAuthAggregateType<T extends WechatAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateWechatAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWechatAuth[P]>
      : GetScalarType<T[P], AggregateWechatAuth[P]>
  }




  export type WechatAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WechatAuthWhereInput
    orderBy?: WechatAuthOrderByWithAggregationInput | WechatAuthOrderByWithAggregationInput[]
    by: WechatAuthScalarFieldEnum[] | WechatAuthScalarFieldEnum
    having?: WechatAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WechatAuthCountAggregateInputType | true
    _min?: WechatAuthMinAggregateInputType
    _max?: WechatAuthMaxAggregateInputType
  }

  export type WechatAuthGroupByOutputType = {
    openid: string
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WechatAuthCountAggregateOutputType | null
    _min: WechatAuthMinAggregateOutputType | null
    _max: WechatAuthMaxAggregateOutputType | null
  }

  type GetWechatAuthGroupByPayload<T extends WechatAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WechatAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WechatAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WechatAuthGroupByOutputType[P]>
            : GetScalarType<T[P], WechatAuthGroupByOutputType[P]>
        }
      >
    >


  export type WechatAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectScalar = {
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WechatAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openid" | "sessionKey" | "refreshToken" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["wechatAuth"]>
  export type WechatAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type WechatAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type WechatAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $WechatAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WechatAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openid: string
      sessionKey: string | null
      refreshToken: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["wechatAuth"]>
    composites: {}
  }

  type WechatAuthGetPayload<S extends boolean | null | undefined | WechatAuthDefaultArgs> = $Result.GetResult<Prisma.$WechatAuthPayload, S>

  type WechatAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WechatAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WechatAuthCountAggregateInputType | true
    }

  export interface WechatAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WechatAuth'], meta: { name: 'WechatAuth' } }
    /**
     * Find zero or one WechatAuth that matches the filter.
     * @param {WechatAuthFindUniqueArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WechatAuthFindUniqueArgs>(args: SelectSubset<T, WechatAuthFindUniqueArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WechatAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WechatAuthFindUniqueOrThrowArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WechatAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, WechatAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WechatAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindFirstArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WechatAuthFindFirstArgs>(args?: SelectSubset<T, WechatAuthFindFirstArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WechatAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindFirstOrThrowArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WechatAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, WechatAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WechatAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WechatAuths
     * const wechatAuths = await prisma.wechatAuth.findMany()
     * 
     * // Get first 10 WechatAuths
     * const wechatAuths = await prisma.wechatAuth.findMany({ take: 10 })
     * 
     * // Only select the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.findMany({ select: { openid: true } })
     * 
     */
    findMany<T extends WechatAuthFindManyArgs>(args?: SelectSubset<T, WechatAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WechatAuth.
     * @param {WechatAuthCreateArgs} args - Arguments to create a WechatAuth.
     * @example
     * // Create one WechatAuth
     * const WechatAuth = await prisma.wechatAuth.create({
     *   data: {
     *     // ... data to create a WechatAuth
     *   }
     * })
     * 
     */
    create<T extends WechatAuthCreateArgs>(args: SelectSubset<T, WechatAuthCreateArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WechatAuths.
     * @param {WechatAuthCreateManyArgs} args - Arguments to create many WechatAuths.
     * @example
     * // Create many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WechatAuthCreateManyArgs>(args?: SelectSubset<T, WechatAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WechatAuths and returns the data saved in the database.
     * @param {WechatAuthCreateManyAndReturnArgs} args - Arguments to create many WechatAuths.
     * @example
     * // Create many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WechatAuths and only return the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.createManyAndReturn({
     *   select: { openid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WechatAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, WechatAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WechatAuth.
     * @param {WechatAuthDeleteArgs} args - Arguments to delete one WechatAuth.
     * @example
     * // Delete one WechatAuth
     * const WechatAuth = await prisma.wechatAuth.delete({
     *   where: {
     *     // ... filter to delete one WechatAuth
     *   }
     * })
     * 
     */
    delete<T extends WechatAuthDeleteArgs>(args: SelectSubset<T, WechatAuthDeleteArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WechatAuth.
     * @param {WechatAuthUpdateArgs} args - Arguments to update one WechatAuth.
     * @example
     * // Update one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WechatAuthUpdateArgs>(args: SelectSubset<T, WechatAuthUpdateArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WechatAuths.
     * @param {WechatAuthDeleteManyArgs} args - Arguments to filter WechatAuths to delete.
     * @example
     * // Delete a few WechatAuths
     * const { count } = await prisma.wechatAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WechatAuthDeleteManyArgs>(args?: SelectSubset<T, WechatAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WechatAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WechatAuthUpdateManyArgs>(args: SelectSubset<T, WechatAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WechatAuths and returns the data updated in the database.
     * @param {WechatAuthUpdateManyAndReturnArgs} args - Arguments to update many WechatAuths.
     * @example
     * // Update many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WechatAuths and only return the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.updateManyAndReturn({
     *   select: { openid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WechatAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, WechatAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WechatAuth.
     * @param {WechatAuthUpsertArgs} args - Arguments to update or create a WechatAuth.
     * @example
     * // Update or create a WechatAuth
     * const wechatAuth = await prisma.wechatAuth.upsert({
     *   create: {
     *     // ... data to create a WechatAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WechatAuth we want to update
     *   }
     * })
     */
    upsert<T extends WechatAuthUpsertArgs>(args: SelectSubset<T, WechatAuthUpsertArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WechatAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthCountArgs} args - Arguments to filter WechatAuths to count.
     * @example
     * // Count the number of WechatAuths
     * const count = await prisma.wechatAuth.count({
     *   where: {
     *     // ... the filter for the WechatAuths we want to count
     *   }
     * })
    **/
    count<T extends WechatAuthCountArgs>(
      args?: Subset<T, WechatAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WechatAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WechatAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WechatAuthAggregateArgs>(args: Subset<T, WechatAuthAggregateArgs>): Prisma.PrismaPromise<GetWechatAuthAggregateType<T>>

    /**
     * Group by WechatAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WechatAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WechatAuthGroupByArgs['orderBy'] }
        : { orderBy?: WechatAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WechatAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWechatAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WechatAuth model
   */
  readonly fields: WechatAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WechatAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WechatAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WechatAuth model
   */
  interface WechatAuthFieldRefs {
    readonly openid: FieldRef<"WechatAuth", 'String'>
    readonly sessionKey: FieldRef<"WechatAuth", 'String'>
    readonly refreshToken: FieldRef<"WechatAuth", 'String'>
    readonly isDeleted: FieldRef<"WechatAuth", 'Boolean'>
    readonly createdAt: FieldRef<"WechatAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"WechatAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"WechatAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WechatAuth findUnique
   */
  export type WechatAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth findUniqueOrThrow
   */
  export type WechatAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth findFirst
   */
  export type WechatAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WechatAuths.
     */
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth findFirstOrThrow
   */
  export type WechatAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WechatAuths.
     */
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth findMany
   */
  export type WechatAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuths to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth create
   */
  export type WechatAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a WechatAuth.
     */
    data: XOR<WechatAuthCreateInput, WechatAuthUncheckedCreateInput>
  }

  /**
   * WechatAuth createMany
   */
  export type WechatAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WechatAuths.
     */
    data: WechatAuthCreateManyInput | WechatAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WechatAuth createManyAndReturn
   */
  export type WechatAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * The data used to create many WechatAuths.
     */
    data: WechatAuthCreateManyInput | WechatAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WechatAuth update
   */
  export type WechatAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a WechatAuth.
     */
    data: XOR<WechatAuthUpdateInput, WechatAuthUncheckedUpdateInput>
    /**
     * Choose, which WechatAuth to update.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth updateMany
   */
  export type WechatAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WechatAuths.
     */
    data: XOR<WechatAuthUpdateManyMutationInput, WechatAuthUncheckedUpdateManyInput>
    /**
     * Filter which WechatAuths to update
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to update.
     */
    limit?: number
  }

  /**
   * WechatAuth updateManyAndReturn
   */
  export type WechatAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * The data used to update WechatAuths.
     */
    data: XOR<WechatAuthUpdateManyMutationInput, WechatAuthUncheckedUpdateManyInput>
    /**
     * Filter which WechatAuths to update
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WechatAuth upsert
   */
  export type WechatAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the WechatAuth to update in case it exists.
     */
    where: WechatAuthWhereUniqueInput
    /**
     * In case the WechatAuth found by the `where` argument doesn't exist, create a new WechatAuth with this data.
     */
    create: XOR<WechatAuthCreateInput, WechatAuthUncheckedCreateInput>
    /**
     * In case the WechatAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WechatAuthUpdateInput, WechatAuthUncheckedUpdateInput>
  }

  /**
   * WechatAuth delete
   */
  export type WechatAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter which WechatAuth to delete.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth deleteMany
   */
  export type WechatAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WechatAuths to delete
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to delete.
     */
    limit?: number
  }

  /**
   * WechatAuth without action
   */
  export type WechatAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
  }


  /**
   * Model GoogleAuth
   */

  export type AggregateGoogleAuth = {
    _count: GoogleAuthCountAggregateOutputType | null
    _avg: GoogleAuthAvgAggregateOutputType | null
    _sum: GoogleAuthSumAggregateOutputType | null
    _min: GoogleAuthMinAggregateOutputType | null
    _max: GoogleAuthMaxAggregateOutputType | null
  }

  export type GoogleAuthAvgAggregateOutputType = {
    exp: number | null
    iat: number | null
  }

  export type GoogleAuthSumAggregateOutputType = {
    exp: number | null
    iat: number | null
  }

  export type GoogleAuthMinAggregateOutputType = {
    sub: string | null
    email: string | null
    verifiedEmail: boolean | null
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number | null
    iat: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GoogleAuthMaxAggregateOutputType = {
    sub: string | null
    email: string | null
    verifiedEmail: boolean | null
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number | null
    iat: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GoogleAuthCountAggregateOutputType = {
    sub: number
    email: number
    verifiedEmail: number
    atHash: number
    name: number
    picture: number
    givenName: number
    familyName: number
    exp: number
    iat: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GoogleAuthAvgAggregateInputType = {
    exp?: true
    iat?: true
  }

  export type GoogleAuthSumAggregateInputType = {
    exp?: true
    iat?: true
  }

  export type GoogleAuthMinAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GoogleAuthMaxAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GoogleAuthCountAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GoogleAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuth to aggregate.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleAuths
    **/
    _count?: true | GoogleAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoogleAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoogleAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleAuthMaxAggregateInputType
  }

  export type GetGoogleAuthAggregateType<T extends GoogleAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleAuth[P]>
      : GetScalarType<T[P], AggregateGoogleAuth[P]>
  }




  export type GoogleAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoogleAuthWhereInput
    orderBy?: GoogleAuthOrderByWithAggregationInput | GoogleAuthOrderByWithAggregationInput[]
    by: GoogleAuthScalarFieldEnum[] | GoogleAuthScalarFieldEnum
    having?: GoogleAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleAuthCountAggregateInputType | true
    _avg?: GoogleAuthAvgAggregateInputType
    _sum?: GoogleAuthSumAggregateInputType
    _min?: GoogleAuthMinAggregateInputType
    _max?: GoogleAuthMaxAggregateInputType
  }

  export type GoogleAuthGroupByOutputType = {
    sub: string
    email: string
    verifiedEmail: boolean
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number
    iat: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: GoogleAuthCountAggregateOutputType | null
    _avg: GoogleAuthAvgAggregateOutputType | null
    _sum: GoogleAuthSumAggregateOutputType | null
    _min: GoogleAuthMinAggregateOutputType | null
    _max: GoogleAuthMaxAggregateOutputType | null
  }

  type GetGoogleAuthGroupByPayload<T extends GoogleAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoogleAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleAuthGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleAuthGroupByOutputType[P]>
        }
      >
    >


  export type GoogleAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectScalar = {
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GoogleAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sub" | "email" | "verifiedEmail" | "atHash" | "name" | "picture" | "givenName" | "familyName" | "exp" | "iat" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["googleAuth"]>
  export type GoogleAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type GoogleAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type GoogleAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $GoogleAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoogleAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sub: string
      email: string
      verifiedEmail: boolean
      atHash: string | null
      name: string | null
      picture: string | null
      givenName: string | null
      familyName: string | null
      exp: number
      iat: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["googleAuth"]>
    composites: {}
  }

  type GoogleAuthGetPayload<S extends boolean | null | undefined | GoogleAuthDefaultArgs> = $Result.GetResult<Prisma.$GoogleAuthPayload, S>

  type GoogleAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoogleAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoogleAuthCountAggregateInputType | true
    }

  export interface GoogleAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleAuth'], meta: { name: 'GoogleAuth' } }
    /**
     * Find zero or one GoogleAuth that matches the filter.
     * @param {GoogleAuthFindUniqueArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoogleAuthFindUniqueArgs>(args: SelectSubset<T, GoogleAuthFindUniqueArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GoogleAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoogleAuthFindUniqueOrThrowArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoogleAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, GoogleAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoogleAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindFirstArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoogleAuthFindFirstArgs>(args?: SelectSubset<T, GoogleAuthFindFirstArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoogleAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindFirstOrThrowArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoogleAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, GoogleAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GoogleAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleAuths
     * const googleAuths = await prisma.googleAuth.findMany()
     * 
     * // Get first 10 GoogleAuths
     * const googleAuths = await prisma.googleAuth.findMany({ take: 10 })
     * 
     * // Only select the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.findMany({ select: { sub: true } })
     * 
     */
    findMany<T extends GoogleAuthFindManyArgs>(args?: SelectSubset<T, GoogleAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GoogleAuth.
     * @param {GoogleAuthCreateArgs} args - Arguments to create a GoogleAuth.
     * @example
     * // Create one GoogleAuth
     * const GoogleAuth = await prisma.googleAuth.create({
     *   data: {
     *     // ... data to create a GoogleAuth
     *   }
     * })
     * 
     */
    create<T extends GoogleAuthCreateArgs>(args: SelectSubset<T, GoogleAuthCreateArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GoogleAuths.
     * @param {GoogleAuthCreateManyArgs} args - Arguments to create many GoogleAuths.
     * @example
     * // Create many GoogleAuths
     * const googleAuth = await prisma.googleAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoogleAuthCreateManyArgs>(args?: SelectSubset<T, GoogleAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoogleAuths and returns the data saved in the database.
     * @param {GoogleAuthCreateManyAndReturnArgs} args - Arguments to create many GoogleAuths.
     * @example
     * // Create many GoogleAuths
     * const googleAuth = await prisma.googleAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoogleAuths and only return the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.createManyAndReturn({
     *   select: { sub: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoogleAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, GoogleAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GoogleAuth.
     * @param {GoogleAuthDeleteArgs} args - Arguments to delete one GoogleAuth.
     * @example
     * // Delete one GoogleAuth
     * const GoogleAuth = await prisma.googleAuth.delete({
     *   where: {
     *     // ... filter to delete one GoogleAuth
     *   }
     * })
     * 
     */
    delete<T extends GoogleAuthDeleteArgs>(args: SelectSubset<T, GoogleAuthDeleteArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GoogleAuth.
     * @param {GoogleAuthUpdateArgs} args - Arguments to update one GoogleAuth.
     * @example
     * // Update one GoogleAuth
     * const googleAuth = await prisma.googleAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoogleAuthUpdateArgs>(args: SelectSubset<T, GoogleAuthUpdateArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GoogleAuths.
     * @param {GoogleAuthDeleteManyArgs} args - Arguments to filter GoogleAuths to delete.
     * @example
     * // Delete a few GoogleAuths
     * const { count } = await prisma.googleAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoogleAuthDeleteManyArgs>(args?: SelectSubset<T, GoogleAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleAuths
     * const googleAuth = await prisma.googleAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoogleAuthUpdateManyArgs>(args: SelectSubset<T, GoogleAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAuths and returns the data updated in the database.
     * @param {GoogleAuthUpdateManyAndReturnArgs} args - Arguments to update many GoogleAuths.
     * @example
     * // Update many GoogleAuths
     * const googleAuth = await prisma.googleAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GoogleAuths and only return the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.updateManyAndReturn({
     *   select: { sub: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoogleAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, GoogleAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GoogleAuth.
     * @param {GoogleAuthUpsertArgs} args - Arguments to update or create a GoogleAuth.
     * @example
     * // Update or create a GoogleAuth
     * const googleAuth = await prisma.googleAuth.upsert({
     *   create: {
     *     // ... data to create a GoogleAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleAuth we want to update
     *   }
     * })
     */
    upsert<T extends GoogleAuthUpsertArgs>(args: SelectSubset<T, GoogleAuthUpsertArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GoogleAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthCountArgs} args - Arguments to filter GoogleAuths to count.
     * @example
     * // Count the number of GoogleAuths
     * const count = await prisma.googleAuth.count({
     *   where: {
     *     // ... the filter for the GoogleAuths we want to count
     *   }
     * })
    **/
    count<T extends GoogleAuthCountArgs>(
      args?: Subset<T, GoogleAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleAuthAggregateArgs>(args: Subset<T, GoogleAuthAggregateArgs>): Prisma.PrismaPromise<GetGoogleAuthAggregateType<T>>

    /**
     * Group by GoogleAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleAuthGroupByArgs['orderBy'] }
        : { orderBy?: GoogleAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoogleAuth model
   */
  readonly fields: GoogleAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoogleAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoogleAuth model
   */
  interface GoogleAuthFieldRefs {
    readonly sub: FieldRef<"GoogleAuth", 'String'>
    readonly email: FieldRef<"GoogleAuth", 'String'>
    readonly verifiedEmail: FieldRef<"GoogleAuth", 'Boolean'>
    readonly atHash: FieldRef<"GoogleAuth", 'String'>
    readonly name: FieldRef<"GoogleAuth", 'String'>
    readonly picture: FieldRef<"GoogleAuth", 'String'>
    readonly givenName: FieldRef<"GoogleAuth", 'String'>
    readonly familyName: FieldRef<"GoogleAuth", 'String'>
    readonly exp: FieldRef<"GoogleAuth", 'Int'>
    readonly iat: FieldRef<"GoogleAuth", 'Int'>
    readonly isDeleted: FieldRef<"GoogleAuth", 'Boolean'>
    readonly createdAt: FieldRef<"GoogleAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"GoogleAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"GoogleAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoogleAuth findUnique
   */
  export type GoogleAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth findUniqueOrThrow
   */
  export type GoogleAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth findFirst
   */
  export type GoogleAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuths.
     */
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth findFirstOrThrow
   */
  export type GoogleAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuths.
     */
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth findMany
   */
  export type GoogleAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuths to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth create
   */
  export type GoogleAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a GoogleAuth.
     */
    data: XOR<GoogleAuthCreateInput, GoogleAuthUncheckedCreateInput>
  }

  /**
   * GoogleAuth createMany
   */
  export type GoogleAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleAuths.
     */
    data: GoogleAuthCreateManyInput | GoogleAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleAuth createManyAndReturn
   */
  export type GoogleAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * The data used to create many GoogleAuths.
     */
    data: GoogleAuthCreateManyInput | GoogleAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoogleAuth update
   */
  export type GoogleAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a GoogleAuth.
     */
    data: XOR<GoogleAuthUpdateInput, GoogleAuthUncheckedUpdateInput>
    /**
     * Choose, which GoogleAuth to update.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth updateMany
   */
  export type GoogleAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleAuths.
     */
    data: XOR<GoogleAuthUpdateManyMutationInput, GoogleAuthUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAuths to update
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to update.
     */
    limit?: number
  }

  /**
   * GoogleAuth updateManyAndReturn
   */
  export type GoogleAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * The data used to update GoogleAuths.
     */
    data: XOR<GoogleAuthUpdateManyMutationInput, GoogleAuthUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAuths to update
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoogleAuth upsert
   */
  export type GoogleAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the GoogleAuth to update in case it exists.
     */
    where: GoogleAuthWhereUniqueInput
    /**
     * In case the GoogleAuth found by the `where` argument doesn't exist, create a new GoogleAuth with this data.
     */
    create: XOR<GoogleAuthCreateInput, GoogleAuthUncheckedCreateInput>
    /**
     * In case the GoogleAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleAuthUpdateInput, GoogleAuthUncheckedUpdateInput>
  }

  /**
   * GoogleAuth delete
   */
  export type GoogleAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter which GoogleAuth to delete.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth deleteMany
   */
  export type GoogleAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuths to delete
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to delete.
     */
    limit?: number
  }

  /**
   * GoogleAuth without action
   */
  export type GoogleAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
  }


  /**
   * Model DiscordAuth
   */

  export type AggregateDiscordAuth = {
    _count: DiscordAuthCountAggregateOutputType | null
    _min: DiscordAuthMinAggregateOutputType | null
    _max: DiscordAuthMaxAggregateOutputType | null
  }

  export type DiscordAuthMinAggregateOutputType = {
    discordId: string | null
    email: string | null
    verifiedEmail: boolean | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DiscordAuthMaxAggregateOutputType = {
    discordId: string | null
    email: string | null
    verifiedEmail: boolean | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DiscordAuthCountAggregateOutputType = {
    discordId: number
    email: number
    verifiedEmail: number
    name: number
    accessToken: number
    refreshToken: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DiscordAuthMinAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DiscordAuthMaxAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DiscordAuthCountAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DiscordAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAuth to aggregate.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordAuths
    **/
    _count?: true | DiscordAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscordAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscordAuthMaxAggregateInputType
  }

  export type GetDiscordAuthAggregateType<T extends DiscordAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscordAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordAuth[P]>
      : GetScalarType<T[P], AggregateDiscordAuth[P]>
  }




  export type DiscordAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscordAuthWhereInput
    orderBy?: DiscordAuthOrderByWithAggregationInput | DiscordAuthOrderByWithAggregationInput[]
    by: DiscordAuthScalarFieldEnum[] | DiscordAuthScalarFieldEnum
    having?: DiscordAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscordAuthCountAggregateInputType | true
    _min?: DiscordAuthMinAggregateInputType
    _max?: DiscordAuthMaxAggregateInputType
  }

  export type DiscordAuthGroupByOutputType = {
    discordId: string
    email: string
    verifiedEmail: boolean
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DiscordAuthCountAggregateOutputType | null
    _min: DiscordAuthMinAggregateOutputType | null
    _max: DiscordAuthMaxAggregateOutputType | null
  }

  type GetDiscordAuthGroupByPayload<T extends DiscordAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscordAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscordAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscordAuthGroupByOutputType[P]>
            : GetScalarType<T[P], DiscordAuthGroupByOutputType[P]>
        }
      >
    >


  export type DiscordAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectScalar = {
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DiscordAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"discordId" | "email" | "verifiedEmail" | "name" | "accessToken" | "refreshToken" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["discordAuth"]>
  export type DiscordAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type DiscordAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type DiscordAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $DiscordAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscordAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      discordId: string
      email: string
      verifiedEmail: boolean
      name: string | null
      accessToken: string | null
      refreshToken: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["discordAuth"]>
    composites: {}
  }

  type DiscordAuthGetPayload<S extends boolean | null | undefined | DiscordAuthDefaultArgs> = $Result.GetResult<Prisma.$DiscordAuthPayload, S>

  type DiscordAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscordAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscordAuthCountAggregateInputType | true
    }

  export interface DiscordAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscordAuth'], meta: { name: 'DiscordAuth' } }
    /**
     * Find zero or one DiscordAuth that matches the filter.
     * @param {DiscordAuthFindUniqueArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscordAuthFindUniqueArgs>(args: SelectSubset<T, DiscordAuthFindUniqueArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscordAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscordAuthFindUniqueOrThrowArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscordAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscordAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindFirstArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscordAuthFindFirstArgs>(args?: SelectSubset<T, DiscordAuthFindFirstArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindFirstOrThrowArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscordAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscordAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscordAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordAuths
     * const discordAuths = await prisma.discordAuth.findMany()
     * 
     * // Get first 10 DiscordAuths
     * const discordAuths = await prisma.discordAuth.findMany({ take: 10 })
     * 
     * // Only select the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.findMany({ select: { discordId: true } })
     * 
     */
    findMany<T extends DiscordAuthFindManyArgs>(args?: SelectSubset<T, DiscordAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscordAuth.
     * @param {DiscordAuthCreateArgs} args - Arguments to create a DiscordAuth.
     * @example
     * // Create one DiscordAuth
     * const DiscordAuth = await prisma.discordAuth.create({
     *   data: {
     *     // ... data to create a DiscordAuth
     *   }
     * })
     * 
     */
    create<T extends DiscordAuthCreateArgs>(args: SelectSubset<T, DiscordAuthCreateArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscordAuths.
     * @param {DiscordAuthCreateManyArgs} args - Arguments to create many DiscordAuths.
     * @example
     * // Create many DiscordAuths
     * const discordAuth = await prisma.discordAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscordAuthCreateManyArgs>(args?: SelectSubset<T, DiscordAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscordAuths and returns the data saved in the database.
     * @param {DiscordAuthCreateManyAndReturnArgs} args - Arguments to create many DiscordAuths.
     * @example
     * // Create many DiscordAuths
     * const discordAuth = await prisma.discordAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscordAuths and only return the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.createManyAndReturn({
     *   select: { discordId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscordAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscordAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscordAuth.
     * @param {DiscordAuthDeleteArgs} args - Arguments to delete one DiscordAuth.
     * @example
     * // Delete one DiscordAuth
     * const DiscordAuth = await prisma.discordAuth.delete({
     *   where: {
     *     // ... filter to delete one DiscordAuth
     *   }
     * })
     * 
     */
    delete<T extends DiscordAuthDeleteArgs>(args: SelectSubset<T, DiscordAuthDeleteArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscordAuth.
     * @param {DiscordAuthUpdateArgs} args - Arguments to update one DiscordAuth.
     * @example
     * // Update one DiscordAuth
     * const discordAuth = await prisma.discordAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscordAuthUpdateArgs>(args: SelectSubset<T, DiscordAuthUpdateArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscordAuths.
     * @param {DiscordAuthDeleteManyArgs} args - Arguments to filter DiscordAuths to delete.
     * @example
     * // Delete a few DiscordAuths
     * const { count } = await prisma.discordAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscordAuthDeleteManyArgs>(args?: SelectSubset<T, DiscordAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordAuths
     * const discordAuth = await prisma.discordAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscordAuthUpdateManyArgs>(args: SelectSubset<T, DiscordAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordAuths and returns the data updated in the database.
     * @param {DiscordAuthUpdateManyAndReturnArgs} args - Arguments to update many DiscordAuths.
     * @example
     * // Update many DiscordAuths
     * const discordAuth = await prisma.discordAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscordAuths and only return the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.updateManyAndReturn({
     *   select: { discordId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscordAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscordAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscordAuth.
     * @param {DiscordAuthUpsertArgs} args - Arguments to update or create a DiscordAuth.
     * @example
     * // Update or create a DiscordAuth
     * const discordAuth = await prisma.discordAuth.upsert({
     *   create: {
     *     // ... data to create a DiscordAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordAuth we want to update
     *   }
     * })
     */
    upsert<T extends DiscordAuthUpsertArgs>(args: SelectSubset<T, DiscordAuthUpsertArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscordAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthCountArgs} args - Arguments to filter DiscordAuths to count.
     * @example
     * // Count the number of DiscordAuths
     * const count = await prisma.discordAuth.count({
     *   where: {
     *     // ... the filter for the DiscordAuths we want to count
     *   }
     * })
    **/
    count<T extends DiscordAuthCountArgs>(
      args?: Subset<T, DiscordAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordAuthAggregateArgs>(args: Subset<T, DiscordAuthAggregateArgs>): Prisma.PrismaPromise<GetDiscordAuthAggregateType<T>>

    /**
     * Group by DiscordAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscordAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscordAuthGroupByArgs['orderBy'] }
        : { orderBy?: DiscordAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscordAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscordAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscordAuth model
   */
  readonly fields: DiscordAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscordAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscordAuth model
   */
  interface DiscordAuthFieldRefs {
    readonly discordId: FieldRef<"DiscordAuth", 'String'>
    readonly email: FieldRef<"DiscordAuth", 'String'>
    readonly verifiedEmail: FieldRef<"DiscordAuth", 'Boolean'>
    readonly name: FieldRef<"DiscordAuth", 'String'>
    readonly accessToken: FieldRef<"DiscordAuth", 'String'>
    readonly refreshToken: FieldRef<"DiscordAuth", 'String'>
    readonly isDeleted: FieldRef<"DiscordAuth", 'Boolean'>
    readonly createdAt: FieldRef<"DiscordAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscordAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"DiscordAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscordAuth findUnique
   */
  export type DiscordAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth findUniqueOrThrow
   */
  export type DiscordAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth findFirst
   */
  export type DiscordAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAuths.
     */
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth findFirstOrThrow
   */
  export type DiscordAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAuths.
     */
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth findMany
   */
  export type DiscordAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuths to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth create
   */
  export type DiscordAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscordAuth.
     */
    data: XOR<DiscordAuthCreateInput, DiscordAuthUncheckedCreateInput>
  }

  /**
   * DiscordAuth createMany
   */
  export type DiscordAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscordAuths.
     */
    data: DiscordAuthCreateManyInput | DiscordAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscordAuth createManyAndReturn
   */
  export type DiscordAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * The data used to create many DiscordAuths.
     */
    data: DiscordAuthCreateManyInput | DiscordAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscordAuth update
   */
  export type DiscordAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscordAuth.
     */
    data: XOR<DiscordAuthUpdateInput, DiscordAuthUncheckedUpdateInput>
    /**
     * Choose, which DiscordAuth to update.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth updateMany
   */
  export type DiscordAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscordAuths.
     */
    data: XOR<DiscordAuthUpdateManyMutationInput, DiscordAuthUncheckedUpdateManyInput>
    /**
     * Filter which DiscordAuths to update
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to update.
     */
    limit?: number
  }

  /**
   * DiscordAuth updateManyAndReturn
   */
  export type DiscordAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * The data used to update DiscordAuths.
     */
    data: XOR<DiscordAuthUpdateManyMutationInput, DiscordAuthUncheckedUpdateManyInput>
    /**
     * Filter which DiscordAuths to update
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscordAuth upsert
   */
  export type DiscordAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscordAuth to update in case it exists.
     */
    where: DiscordAuthWhereUniqueInput
    /**
     * In case the DiscordAuth found by the `where` argument doesn't exist, create a new DiscordAuth with this data.
     */
    create: XOR<DiscordAuthCreateInput, DiscordAuthUncheckedCreateInput>
    /**
     * In case the DiscordAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscordAuthUpdateInput, DiscordAuthUncheckedUpdateInput>
  }

  /**
   * DiscordAuth delete
   */
  export type DiscordAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter which DiscordAuth to delete.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth deleteMany
   */
  export type DiscordAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAuths to delete
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to delete.
     */
    limit?: number
  }

  /**
   * DiscordAuth without action
   */
  export type DiscordAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
  }


  /**
   * Model MobileAuth
   */

  export type AggregateMobileAuth = {
    _count: MobileAuthCountAggregateOutputType | null
    _min: MobileAuthMinAggregateOutputType | null
    _max: MobileAuthMaxAggregateOutputType | null
  }

  export type MobileAuthMinAggregateOutputType = {
    mobile: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MobileAuthMaxAggregateOutputType = {
    mobile: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MobileAuthCountAggregateOutputType = {
    mobile: number
    password: number
    verified: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type MobileAuthMinAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MobileAuthMaxAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MobileAuthCountAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MobileAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileAuth to aggregate.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobileAuths
    **/
    _count?: true | MobileAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobileAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobileAuthMaxAggregateInputType
  }

  export type GetMobileAuthAggregateType<T extends MobileAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateMobileAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobileAuth[P]>
      : GetScalarType<T[P], AggregateMobileAuth[P]>
  }




  export type MobileAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobileAuthWhereInput
    orderBy?: MobileAuthOrderByWithAggregationInput | MobileAuthOrderByWithAggregationInput[]
    by: MobileAuthScalarFieldEnum[] | MobileAuthScalarFieldEnum
    having?: MobileAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobileAuthCountAggregateInputType | true
    _min?: MobileAuthMinAggregateInputType
    _max?: MobileAuthMaxAggregateInputType
  }

  export type MobileAuthGroupByOutputType = {
    mobile: string
    password: string
    verified: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: MobileAuthCountAggregateOutputType | null
    _min: MobileAuthMinAggregateOutputType | null
    _max: MobileAuthMaxAggregateOutputType | null
  }

  type GetMobileAuthGroupByPayload<T extends MobileAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobileAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobileAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobileAuthGroupByOutputType[P]>
            : GetScalarType<T[P], MobileAuthGroupByOutputType[P]>
        }
      >
    >


  export type MobileAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectScalar = {
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type MobileAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mobile" | "password" | "verified" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["mobileAuth"]>
  export type MobileAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MobileAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MobileAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $MobileAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobileAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mobile: string
      password: string
      verified: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["mobileAuth"]>
    composites: {}
  }

  type MobileAuthGetPayload<S extends boolean | null | undefined | MobileAuthDefaultArgs> = $Result.GetResult<Prisma.$MobileAuthPayload, S>

  type MobileAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MobileAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MobileAuthCountAggregateInputType | true
    }

  export interface MobileAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobileAuth'], meta: { name: 'MobileAuth' } }
    /**
     * Find zero or one MobileAuth that matches the filter.
     * @param {MobileAuthFindUniqueArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MobileAuthFindUniqueArgs>(args: SelectSubset<T, MobileAuthFindUniqueArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MobileAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MobileAuthFindUniqueOrThrowArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MobileAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, MobileAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindFirstArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MobileAuthFindFirstArgs>(args?: SelectSubset<T, MobileAuthFindFirstArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindFirstOrThrowArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MobileAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, MobileAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MobileAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobileAuths
     * const mobileAuths = await prisma.mobileAuth.findMany()
     * 
     * // Get first 10 MobileAuths
     * const mobileAuths = await prisma.mobileAuth.findMany({ take: 10 })
     * 
     * // Only select the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.findMany({ select: { mobile: true } })
     * 
     */
    findMany<T extends MobileAuthFindManyArgs>(args?: SelectSubset<T, MobileAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MobileAuth.
     * @param {MobileAuthCreateArgs} args - Arguments to create a MobileAuth.
     * @example
     * // Create one MobileAuth
     * const MobileAuth = await prisma.mobileAuth.create({
     *   data: {
     *     // ... data to create a MobileAuth
     *   }
     * })
     * 
     */
    create<T extends MobileAuthCreateArgs>(args: SelectSubset<T, MobileAuthCreateArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MobileAuths.
     * @param {MobileAuthCreateManyArgs} args - Arguments to create many MobileAuths.
     * @example
     * // Create many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MobileAuthCreateManyArgs>(args?: SelectSubset<T, MobileAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MobileAuths and returns the data saved in the database.
     * @param {MobileAuthCreateManyAndReturnArgs} args - Arguments to create many MobileAuths.
     * @example
     * // Create many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MobileAuths and only return the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.createManyAndReturn({
     *   select: { mobile: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MobileAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, MobileAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MobileAuth.
     * @param {MobileAuthDeleteArgs} args - Arguments to delete one MobileAuth.
     * @example
     * // Delete one MobileAuth
     * const MobileAuth = await prisma.mobileAuth.delete({
     *   where: {
     *     // ... filter to delete one MobileAuth
     *   }
     * })
     * 
     */
    delete<T extends MobileAuthDeleteArgs>(args: SelectSubset<T, MobileAuthDeleteArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MobileAuth.
     * @param {MobileAuthUpdateArgs} args - Arguments to update one MobileAuth.
     * @example
     * // Update one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MobileAuthUpdateArgs>(args: SelectSubset<T, MobileAuthUpdateArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MobileAuths.
     * @param {MobileAuthDeleteManyArgs} args - Arguments to filter MobileAuths to delete.
     * @example
     * // Delete a few MobileAuths
     * const { count } = await prisma.mobileAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MobileAuthDeleteManyArgs>(args?: SelectSubset<T, MobileAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MobileAuthUpdateManyArgs>(args: SelectSubset<T, MobileAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileAuths and returns the data updated in the database.
     * @param {MobileAuthUpdateManyAndReturnArgs} args - Arguments to update many MobileAuths.
     * @example
     * // Update many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MobileAuths and only return the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.updateManyAndReturn({
     *   select: { mobile: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MobileAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, MobileAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MobileAuth.
     * @param {MobileAuthUpsertArgs} args - Arguments to update or create a MobileAuth.
     * @example
     * // Update or create a MobileAuth
     * const mobileAuth = await prisma.mobileAuth.upsert({
     *   create: {
     *     // ... data to create a MobileAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobileAuth we want to update
     *   }
     * })
     */
    upsert<T extends MobileAuthUpsertArgs>(args: SelectSubset<T, MobileAuthUpsertArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MobileAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthCountArgs} args - Arguments to filter MobileAuths to count.
     * @example
     * // Count the number of MobileAuths
     * const count = await prisma.mobileAuth.count({
     *   where: {
     *     // ... the filter for the MobileAuths we want to count
     *   }
     * })
    **/
    count<T extends MobileAuthCountArgs>(
      args?: Subset<T, MobileAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobileAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobileAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobileAuthAggregateArgs>(args: Subset<T, MobileAuthAggregateArgs>): Prisma.PrismaPromise<GetMobileAuthAggregateType<T>>

    /**
     * Group by MobileAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobileAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobileAuthGroupByArgs['orderBy'] }
        : { orderBy?: MobileAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobileAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobileAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobileAuth model
   */
  readonly fields: MobileAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobileAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobileAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MobileAuth model
   */
  interface MobileAuthFieldRefs {
    readonly mobile: FieldRef<"MobileAuth", 'String'>
    readonly password: FieldRef<"MobileAuth", 'String'>
    readonly verified: FieldRef<"MobileAuth", 'Boolean'>
    readonly isDeleted: FieldRef<"MobileAuth", 'Boolean'>
    readonly createdAt: FieldRef<"MobileAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"MobileAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"MobileAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MobileAuth findUnique
   */
  export type MobileAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth findUniqueOrThrow
   */
  export type MobileAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth findFirst
   */
  export type MobileAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileAuths.
     */
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth findFirstOrThrow
   */
  export type MobileAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileAuths.
     */
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth findMany
   */
  export type MobileAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuths to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth create
   */
  export type MobileAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a MobileAuth.
     */
    data: XOR<MobileAuthCreateInput, MobileAuthUncheckedCreateInput>
  }

  /**
   * MobileAuth createMany
   */
  export type MobileAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobileAuths.
     */
    data: MobileAuthCreateManyInput | MobileAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MobileAuth createManyAndReturn
   */
  export type MobileAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * The data used to create many MobileAuths.
     */
    data: MobileAuthCreateManyInput | MobileAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MobileAuth update
   */
  export type MobileAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a MobileAuth.
     */
    data: XOR<MobileAuthUpdateInput, MobileAuthUncheckedUpdateInput>
    /**
     * Choose, which MobileAuth to update.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth updateMany
   */
  export type MobileAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobileAuths.
     */
    data: XOR<MobileAuthUpdateManyMutationInput, MobileAuthUncheckedUpdateManyInput>
    /**
     * Filter which MobileAuths to update
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to update.
     */
    limit?: number
  }

  /**
   * MobileAuth updateManyAndReturn
   */
  export type MobileAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * The data used to update MobileAuths.
     */
    data: XOR<MobileAuthUpdateManyMutationInput, MobileAuthUncheckedUpdateManyInput>
    /**
     * Filter which MobileAuths to update
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MobileAuth upsert
   */
  export type MobileAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the MobileAuth to update in case it exists.
     */
    where: MobileAuthWhereUniqueInput
    /**
     * In case the MobileAuth found by the `where` argument doesn't exist, create a new MobileAuth with this data.
     */
    create: XOR<MobileAuthCreateInput, MobileAuthUncheckedCreateInput>
    /**
     * In case the MobileAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobileAuthUpdateInput, MobileAuthUncheckedUpdateInput>
  }

  /**
   * MobileAuth delete
   */
  export type MobileAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter which MobileAuth to delete.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth deleteMany
   */
  export type MobileAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileAuths to delete
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to delete.
     */
    limit?: number
  }

  /**
   * MobileAuth without action
   */
  export type MobileAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
  }


  /**
   * Model EmailAuth
   */

  export type AggregateEmailAuth = {
    _count: EmailAuthCountAggregateOutputType | null
    _min: EmailAuthMinAggregateOutputType | null
    _max: EmailAuthMaxAggregateOutputType | null
  }

  export type EmailAuthMinAggregateOutputType = {
    email: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmailAuthMaxAggregateOutputType = {
    email: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmailAuthCountAggregateOutputType = {
    email: number
    password: number
    verified: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmailAuthMinAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmailAuthMaxAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmailAuthCountAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmailAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAuth to aggregate.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAuths
    **/
    _count?: true | EmailAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAuthMaxAggregateInputType
  }

  export type GetEmailAuthAggregateType<T extends EmailAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAuth[P]>
      : GetScalarType<T[P], AggregateEmailAuth[P]>
  }




  export type EmailAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAuthWhereInput
    orderBy?: EmailAuthOrderByWithAggregationInput | EmailAuthOrderByWithAggregationInput[]
    by: EmailAuthScalarFieldEnum[] | EmailAuthScalarFieldEnum
    having?: EmailAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAuthCountAggregateInputType | true
    _min?: EmailAuthMinAggregateInputType
    _max?: EmailAuthMaxAggregateInputType
  }

  export type EmailAuthGroupByOutputType = {
    email: string
    password: string
    verified: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmailAuthCountAggregateOutputType | null
    _min: EmailAuthMinAggregateOutputType | null
    _max: EmailAuthMaxAggregateOutputType | null
  }

  type GetEmailAuthGroupByPayload<T extends EmailAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAuthGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAuthGroupByOutputType[P]>
        }
      >
    >


  export type EmailAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectScalar = {
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmailAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "password" | "verified" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["emailAuth"]>
  export type EmailAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type EmailAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type EmailAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $EmailAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      password: string
      verified: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["emailAuth"]>
    composites: {}
  }

  type EmailAuthGetPayload<S extends boolean | null | undefined | EmailAuthDefaultArgs> = $Result.GetResult<Prisma.$EmailAuthPayload, S>

  type EmailAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAuthCountAggregateInputType | true
    }

  export interface EmailAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAuth'], meta: { name: 'EmailAuth' } }
    /**
     * Find zero or one EmailAuth that matches the filter.
     * @param {EmailAuthFindUniqueArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAuthFindUniqueArgs>(args: SelectSubset<T, EmailAuthFindUniqueArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAuthFindUniqueOrThrowArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindFirstArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAuthFindFirstArgs>(args?: SelectSubset<T, EmailAuthFindFirstArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindFirstOrThrowArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAuths
     * const emailAuths = await prisma.emailAuth.findMany()
     * 
     * // Get first 10 EmailAuths
     * const emailAuths = await prisma.emailAuth.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends EmailAuthFindManyArgs>(args?: SelectSubset<T, EmailAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAuth.
     * @param {EmailAuthCreateArgs} args - Arguments to create a EmailAuth.
     * @example
     * // Create one EmailAuth
     * const EmailAuth = await prisma.emailAuth.create({
     *   data: {
     *     // ... data to create a EmailAuth
     *   }
     * })
     * 
     */
    create<T extends EmailAuthCreateArgs>(args: SelectSubset<T, EmailAuthCreateArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAuths.
     * @param {EmailAuthCreateManyArgs} args - Arguments to create many EmailAuths.
     * @example
     * // Create many EmailAuths
     * const emailAuth = await prisma.emailAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAuthCreateManyArgs>(args?: SelectSubset<T, EmailAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAuths and returns the data saved in the database.
     * @param {EmailAuthCreateManyAndReturnArgs} args - Arguments to create many EmailAuths.
     * @example
     * // Create many EmailAuths
     * const emailAuth = await prisma.emailAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAuths and only return the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.createManyAndReturn({
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAuth.
     * @param {EmailAuthDeleteArgs} args - Arguments to delete one EmailAuth.
     * @example
     * // Delete one EmailAuth
     * const EmailAuth = await prisma.emailAuth.delete({
     *   where: {
     *     // ... filter to delete one EmailAuth
     *   }
     * })
     * 
     */
    delete<T extends EmailAuthDeleteArgs>(args: SelectSubset<T, EmailAuthDeleteArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAuth.
     * @param {EmailAuthUpdateArgs} args - Arguments to update one EmailAuth.
     * @example
     * // Update one EmailAuth
     * const emailAuth = await prisma.emailAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAuthUpdateArgs>(args: SelectSubset<T, EmailAuthUpdateArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAuths.
     * @param {EmailAuthDeleteManyArgs} args - Arguments to filter EmailAuths to delete.
     * @example
     * // Delete a few EmailAuths
     * const { count } = await prisma.emailAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAuthDeleteManyArgs>(args?: SelectSubset<T, EmailAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAuths
     * const emailAuth = await prisma.emailAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAuthUpdateManyArgs>(args: SelectSubset<T, EmailAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAuths and returns the data updated in the database.
     * @param {EmailAuthUpdateManyAndReturnArgs} args - Arguments to update many EmailAuths.
     * @example
     * // Update many EmailAuths
     * const emailAuth = await prisma.emailAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAuths and only return the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.updateManyAndReturn({
     *   select: { email: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAuth.
     * @param {EmailAuthUpsertArgs} args - Arguments to update or create a EmailAuth.
     * @example
     * // Update or create a EmailAuth
     * const emailAuth = await prisma.emailAuth.upsert({
     *   create: {
     *     // ... data to create a EmailAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAuth we want to update
     *   }
     * })
     */
    upsert<T extends EmailAuthUpsertArgs>(args: SelectSubset<T, EmailAuthUpsertArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthCountArgs} args - Arguments to filter EmailAuths to count.
     * @example
     * // Count the number of EmailAuths
     * const count = await prisma.emailAuth.count({
     *   where: {
     *     // ... the filter for the EmailAuths we want to count
     *   }
     * })
    **/
    count<T extends EmailAuthCountArgs>(
      args?: Subset<T, EmailAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAuthAggregateArgs>(args: Subset<T, EmailAuthAggregateArgs>): Prisma.PrismaPromise<GetEmailAuthAggregateType<T>>

    /**
     * Group by EmailAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAuthGroupByArgs['orderBy'] }
        : { orderBy?: EmailAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAuth model
   */
  readonly fields: EmailAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAuth model
   */
  interface EmailAuthFieldRefs {
    readonly email: FieldRef<"EmailAuth", 'String'>
    readonly password: FieldRef<"EmailAuth", 'String'>
    readonly verified: FieldRef<"EmailAuth", 'Boolean'>
    readonly isDeleted: FieldRef<"EmailAuth", 'Boolean'>
    readonly createdAt: FieldRef<"EmailAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"EmailAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAuth findUnique
   */
  export type EmailAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth findUniqueOrThrow
   */
  export type EmailAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth findFirst
   */
  export type EmailAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAuths.
     */
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth findFirstOrThrow
   */
  export type EmailAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAuths.
     */
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth findMany
   */
  export type EmailAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuths to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth create
   */
  export type EmailAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAuth.
     */
    data: XOR<EmailAuthCreateInput, EmailAuthUncheckedCreateInput>
  }

  /**
   * EmailAuth createMany
   */
  export type EmailAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAuths.
     */
    data: EmailAuthCreateManyInput | EmailAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAuth createManyAndReturn
   */
  export type EmailAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAuths.
     */
    data: EmailAuthCreateManyInput | EmailAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAuth update
   */
  export type EmailAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAuth.
     */
    data: XOR<EmailAuthUpdateInput, EmailAuthUncheckedUpdateInput>
    /**
     * Choose, which EmailAuth to update.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth updateMany
   */
  export type EmailAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAuths.
     */
    data: XOR<EmailAuthUpdateManyMutationInput, EmailAuthUncheckedUpdateManyInput>
    /**
     * Filter which EmailAuths to update
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to update.
     */
    limit?: number
  }

  /**
   * EmailAuth updateManyAndReturn
   */
  export type EmailAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * The data used to update EmailAuths.
     */
    data: XOR<EmailAuthUpdateManyMutationInput, EmailAuthUncheckedUpdateManyInput>
    /**
     * Filter which EmailAuths to update
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAuth upsert
   */
  export type EmailAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAuth to update in case it exists.
     */
    where: EmailAuthWhereUniqueInput
    /**
     * In case the EmailAuth found by the `where` argument doesn't exist, create a new EmailAuth with this data.
     */
    create: XOR<EmailAuthCreateInput, EmailAuthUncheckedCreateInput>
    /**
     * In case the EmailAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAuthUpdateInput, EmailAuthUncheckedUpdateInput>
  }

  /**
   * EmailAuth delete
   */
  export type EmailAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter which EmailAuth to delete.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth deleteMany
   */
  export type EmailAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAuths to delete
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to delete.
     */
    limit?: number
  }

  /**
   * EmailAuth without action
   */
  export type EmailAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
  }


  /**
   * Model RiskDetectionRecord
   */

  export type AggregateRiskDetectionRecord = {
    _count: RiskDetectionRecordCountAggregateOutputType | null
    _avg: RiskDetectionRecordAvgAggregateOutputType | null
    _sum: RiskDetectionRecordSumAggregateOutputType | null
    _min: RiskDetectionRecordMinAggregateOutputType | null
    _max: RiskDetectionRecordMaxAggregateOutputType | null
  }

  export type RiskDetectionRecordAvgAggregateOutputType = {
    status: number | null
  }

  export type RiskDetectionRecordSumAggregateOutputType = {
    status: number | null
  }

  export type RiskDetectionRecordMinAggregateOutputType = {
    id: string | null
    action: string | null
    status: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RiskDetectionRecordMaxAggregateOutputType = {
    id: string | null
    action: string | null
    status: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RiskDetectionRecordCountAggregateOutputType = {
    id: number
    action: number
    data: number
    status: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RiskDetectionRecordAvgAggregateInputType = {
    status?: true
  }

  export type RiskDetectionRecordSumAggregateInputType = {
    status?: true
  }

  export type RiskDetectionRecordMinAggregateInputType = {
    id?: true
    action?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RiskDetectionRecordMaxAggregateInputType = {
    id?: true
    action?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RiskDetectionRecordCountAggregateInputType = {
    id?: true
    action?: true
    data?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RiskDetectionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDetectionRecord to aggregate.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskDetectionRecords
    **/
    _count?: true | RiskDetectionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskDetectionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskDetectionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskDetectionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskDetectionRecordMaxAggregateInputType
  }

  export type GetRiskDetectionRecordAggregateType<T extends RiskDetectionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskDetectionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskDetectionRecord[P]>
      : GetScalarType<T[P], AggregateRiskDetectionRecord[P]>
  }




  export type RiskDetectionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskDetectionRecordWhereInput
    orderBy?: RiskDetectionRecordOrderByWithAggregationInput | RiskDetectionRecordOrderByWithAggregationInput[]
    by: RiskDetectionRecordScalarFieldEnum[] | RiskDetectionRecordScalarFieldEnum
    having?: RiskDetectionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskDetectionRecordCountAggregateInputType | true
    _avg?: RiskDetectionRecordAvgAggregateInputType
    _sum?: RiskDetectionRecordSumAggregateInputType
    _min?: RiskDetectionRecordMinAggregateInputType
    _max?: RiskDetectionRecordMaxAggregateInputType
  }

  export type RiskDetectionRecordGroupByOutputType = {
    id: string
    action: string
    data: JsonValue | null
    status: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RiskDetectionRecordCountAggregateOutputType | null
    _avg: RiskDetectionRecordAvgAggregateOutputType | null
    _sum: RiskDetectionRecordSumAggregateOutputType | null
    _min: RiskDetectionRecordMinAggregateOutputType | null
    _max: RiskDetectionRecordMaxAggregateOutputType | null
  }

  type GetRiskDetectionRecordGroupByPayload<T extends RiskDetectionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskDetectionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskDetectionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskDetectionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RiskDetectionRecordGroupByOutputType[P]>
        }
      >
    >


  export type RiskDetectionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectScalar = {
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RiskDetectionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "data" | "status" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["riskDetectionRecord"]>

  export type $RiskDetectionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskDetectionRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      data: Prisma.JsonValue | null
      status: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["riskDetectionRecord"]>
    composites: {}
  }

  type RiskDetectionRecordGetPayload<S extends boolean | null | undefined | RiskDetectionRecordDefaultArgs> = $Result.GetResult<Prisma.$RiskDetectionRecordPayload, S>

  type RiskDetectionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskDetectionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskDetectionRecordCountAggregateInputType | true
    }

  export interface RiskDetectionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskDetectionRecord'], meta: { name: 'RiskDetectionRecord' } }
    /**
     * Find zero or one RiskDetectionRecord that matches the filter.
     * @param {RiskDetectionRecordFindUniqueArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskDetectionRecordFindUniqueArgs>(args: SelectSubset<T, RiskDetectionRecordFindUniqueArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskDetectionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskDetectionRecordFindUniqueOrThrowArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskDetectionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDetectionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindFirstArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskDetectionRecordFindFirstArgs>(args?: SelectSubset<T, RiskDetectionRecordFindFirstArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDetectionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindFirstOrThrowArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskDetectionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskDetectionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskDetectionRecords
     * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany()
     * 
     * // Get first 10 RiskDetectionRecords
     * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskDetectionRecordFindManyArgs>(args?: SelectSubset<T, RiskDetectionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskDetectionRecord.
     * @param {RiskDetectionRecordCreateArgs} args - Arguments to create a RiskDetectionRecord.
     * @example
     * // Create one RiskDetectionRecord
     * const RiskDetectionRecord = await prisma.riskDetectionRecord.create({
     *   data: {
     *     // ... data to create a RiskDetectionRecord
     *   }
     * })
     * 
     */
    create<T extends RiskDetectionRecordCreateArgs>(args: SelectSubset<T, RiskDetectionRecordCreateArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskDetectionRecords.
     * @param {RiskDetectionRecordCreateManyArgs} args - Arguments to create many RiskDetectionRecords.
     * @example
     * // Create many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskDetectionRecordCreateManyArgs>(args?: SelectSubset<T, RiskDetectionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskDetectionRecords and returns the data saved in the database.
     * @param {RiskDetectionRecordCreateManyAndReturnArgs} args - Arguments to create many RiskDetectionRecords.
     * @example
     * // Create many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskDetectionRecords and only return the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskDetectionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskDetectionRecord.
     * @param {RiskDetectionRecordDeleteArgs} args - Arguments to delete one RiskDetectionRecord.
     * @example
     * // Delete one RiskDetectionRecord
     * const RiskDetectionRecord = await prisma.riskDetectionRecord.delete({
     *   where: {
     *     // ... filter to delete one RiskDetectionRecord
     *   }
     * })
     * 
     */
    delete<T extends RiskDetectionRecordDeleteArgs>(args: SelectSubset<T, RiskDetectionRecordDeleteArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskDetectionRecord.
     * @param {RiskDetectionRecordUpdateArgs} args - Arguments to update one RiskDetectionRecord.
     * @example
     * // Update one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskDetectionRecordUpdateArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskDetectionRecords.
     * @param {RiskDetectionRecordDeleteManyArgs} args - Arguments to filter RiskDetectionRecords to delete.
     * @example
     * // Delete a few RiskDetectionRecords
     * const { count } = await prisma.riskDetectionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskDetectionRecordDeleteManyArgs>(args?: SelectSubset<T, RiskDetectionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDetectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskDetectionRecordUpdateManyArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDetectionRecords and returns the data updated in the database.
     * @param {RiskDetectionRecordUpdateManyAndReturnArgs} args - Arguments to update many RiskDetectionRecords.
     * @example
     * // Update many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskDetectionRecords and only return the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskDetectionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskDetectionRecord.
     * @param {RiskDetectionRecordUpsertArgs} args - Arguments to update or create a RiskDetectionRecord.
     * @example
     * // Update or create a RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.upsert({
     *   create: {
     *     // ... data to create a RiskDetectionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskDetectionRecord we want to update
     *   }
     * })
     */
    upsert<T extends RiskDetectionRecordUpsertArgs>(args: SelectSubset<T, RiskDetectionRecordUpsertArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskDetectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordCountArgs} args - Arguments to filter RiskDetectionRecords to count.
     * @example
     * // Count the number of RiskDetectionRecords
     * const count = await prisma.riskDetectionRecord.count({
     *   where: {
     *     // ... the filter for the RiskDetectionRecords we want to count
     *   }
     * })
    **/
    count<T extends RiskDetectionRecordCountArgs>(
      args?: Subset<T, RiskDetectionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskDetectionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskDetectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskDetectionRecordAggregateArgs>(args: Subset<T, RiskDetectionRecordAggregateArgs>): Prisma.PrismaPromise<GetRiskDetectionRecordAggregateType<T>>

    /**
     * Group by RiskDetectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskDetectionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskDetectionRecordGroupByArgs['orderBy'] }
        : { orderBy?: RiskDetectionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskDetectionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskDetectionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskDetectionRecord model
   */
  readonly fields: RiskDetectionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskDetectionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskDetectionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskDetectionRecord model
   */
  interface RiskDetectionRecordFieldRefs {
    readonly id: FieldRef<"RiskDetectionRecord", 'String'>
    readonly action: FieldRef<"RiskDetectionRecord", 'String'>
    readonly data: FieldRef<"RiskDetectionRecord", 'Json'>
    readonly status: FieldRef<"RiskDetectionRecord", 'Int'>
    readonly isDeleted: FieldRef<"RiskDetectionRecord", 'Boolean'>
    readonly createdAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
    readonly deletedAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskDetectionRecord findUnique
   */
  export type RiskDetectionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord findUniqueOrThrow
   */
  export type RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord findFirst
   */
  export type RiskDetectionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDetectionRecords.
     */
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord findFirstOrThrow
   */
  export type RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDetectionRecords.
     */
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord findMany
   */
  export type RiskDetectionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecords to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord create
   */
  export type RiskDetectionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a RiskDetectionRecord.
     */
    data: XOR<RiskDetectionRecordCreateInput, RiskDetectionRecordUncheckedCreateInput>
  }

  /**
   * RiskDetectionRecord createMany
   */
  export type RiskDetectionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskDetectionRecords.
     */
    data: RiskDetectionRecordCreateManyInput | RiskDetectionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskDetectionRecord createManyAndReturn
   */
  export type RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many RiskDetectionRecords.
     */
    data: RiskDetectionRecordCreateManyInput | RiskDetectionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskDetectionRecord update
   */
  export type RiskDetectionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a RiskDetectionRecord.
     */
    data: XOR<RiskDetectionRecordUpdateInput, RiskDetectionRecordUncheckedUpdateInput>
    /**
     * Choose, which RiskDetectionRecord to update.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord updateMany
   */
  export type RiskDetectionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskDetectionRecords.
     */
    data: XOR<RiskDetectionRecordUpdateManyMutationInput, RiskDetectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which RiskDetectionRecords to update
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to update.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord updateManyAndReturn
   */
  export type RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data used to update RiskDetectionRecords.
     */
    data: XOR<RiskDetectionRecordUpdateManyMutationInput, RiskDetectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which RiskDetectionRecords to update
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to update.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord upsert
   */
  export type RiskDetectionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the RiskDetectionRecord to update in case it exists.
     */
    where: RiskDetectionRecordWhereUniqueInput
    /**
     * In case the RiskDetectionRecord found by the `where` argument doesn't exist, create a new RiskDetectionRecord with this data.
     */
    create: XOR<RiskDetectionRecordCreateInput, RiskDetectionRecordUncheckedCreateInput>
    /**
     * In case the RiskDetectionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskDetectionRecordUpdateInput, RiskDetectionRecordUncheckedUpdateInput>
  }

  /**
   * RiskDetectionRecord delete
   */
  export type RiskDetectionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter which RiskDetectionRecord to delete.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord deleteMany
   */
  export type RiskDetectionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDetectionRecords to delete
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to delete.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord without action
   */
  export type RiskDetectionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
  }


  /**
   * Model SystemTaskQueue
   */

  export type AggregateSystemTaskQueue = {
    _count: SystemTaskQueueCountAggregateOutputType | null
    _avg: SystemTaskQueueAvgAggregateOutputType | null
    _sum: SystemTaskQueueSumAggregateOutputType | null
    _min: SystemTaskQueueMinAggregateOutputType | null
    _max: SystemTaskQueueMaxAggregateOutputType | null
  }

  export type SystemTaskQueueAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type SystemTaskQueueSumAggregateOutputType = {
    retryCount: number | null
  }

  export type SystemTaskQueueMinAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    recipient: string | null
    templateCode: string | null
    content: string | null
    subject: string | null
    retryCount: number | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemTaskQueueMaxAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    recipient: string | null
    templateCode: string | null
    content: string | null
    subject: string | null
    retryCount: number | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemTaskQueueCountAggregateOutputType = {
    id: number
    taskType: number
    status: number
    recipient: number
    templateCode: number
    templateData: number
    content: number
    subject: number
    retryCount: number
    processedAt: number
    errorMessage: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemTaskQueueAvgAggregateInputType = {
    retryCount?: true
  }

  export type SystemTaskQueueSumAggregateInputType = {
    retryCount?: true
  }

  export type SystemTaskQueueMinAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemTaskQueueMaxAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemTaskQueueCountAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    templateData?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemTaskQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemTaskQueue to aggregate.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemTaskQueues
    **/
    _count?: true | SystemTaskQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemTaskQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemTaskQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemTaskQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemTaskQueueMaxAggregateInputType
  }

  export type GetSystemTaskQueueAggregateType<T extends SystemTaskQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemTaskQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemTaskQueue[P]>
      : GetScalarType<T[P], AggregateSystemTaskQueue[P]>
  }




  export type SystemTaskQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemTaskQueueWhereInput
    orderBy?: SystemTaskQueueOrderByWithAggregationInput | SystemTaskQueueOrderByWithAggregationInput[]
    by: SystemTaskQueueScalarFieldEnum[] | SystemTaskQueueScalarFieldEnum
    having?: SystemTaskQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemTaskQueueCountAggregateInputType | true
    _avg?: SystemTaskQueueAvgAggregateInputType
    _sum?: SystemTaskQueueSumAggregateInputType
    _min?: SystemTaskQueueMinAggregateInputType
    _max?: SystemTaskQueueMaxAggregateInputType
  }

  export type SystemTaskQueueGroupByOutputType = {
    id: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode: string | null
    templateData: JsonValue | null
    content: string | null
    subject: string | null
    retryCount: number
    processedAt: Date
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SystemTaskQueueCountAggregateOutputType | null
    _avg: SystemTaskQueueAvgAggregateOutputType | null
    _sum: SystemTaskQueueSumAggregateOutputType | null
    _min: SystemTaskQueueMinAggregateOutputType | null
    _max: SystemTaskQueueMaxAggregateOutputType | null
  }

  type GetSystemTaskQueueGroupByPayload<T extends SystemTaskQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemTaskQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemTaskQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemTaskQueueGroupByOutputType[P]>
            : GetScalarType<T[P], SystemTaskQueueGroupByOutputType[P]>
        }
      >
    >


  export type SystemTaskQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectScalar = {
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemTaskQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskType" | "status" | "recipient" | "templateCode" | "templateData" | "content" | "subject" | "retryCount" | "processedAt" | "errorMessage" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["systemTaskQueue"]>

  export type $SystemTaskQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemTaskQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskType: $Enums.TaskType
      status: $Enums.TaskStatus
      recipient: string
      templateCode: string | null
      templateData: Prisma.JsonValue | null
      content: string | null
      subject: string | null
      retryCount: number
      processedAt: Date
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemTaskQueue"]>
    composites: {}
  }

  type SystemTaskQueueGetPayload<S extends boolean | null | undefined | SystemTaskQueueDefaultArgs> = $Result.GetResult<Prisma.$SystemTaskQueuePayload, S>

  type SystemTaskQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemTaskQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemTaskQueueCountAggregateInputType | true
    }

  export interface SystemTaskQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemTaskQueue'], meta: { name: 'SystemTaskQueue' } }
    /**
     * Find zero or one SystemTaskQueue that matches the filter.
     * @param {SystemTaskQueueFindUniqueArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemTaskQueueFindUniqueArgs>(args: SelectSubset<T, SystemTaskQueueFindUniqueArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemTaskQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemTaskQueueFindUniqueOrThrowArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemTaskQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemTaskQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindFirstArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemTaskQueueFindFirstArgs>(args?: SelectSubset<T, SystemTaskQueueFindFirstArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemTaskQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindFirstOrThrowArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemTaskQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemTaskQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemTaskQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemTaskQueues
     * const systemTaskQueues = await prisma.systemTaskQueue.findMany()
     * 
     * // Get first 10 SystemTaskQueues
     * const systemTaskQueues = await prisma.systemTaskQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemTaskQueueFindManyArgs>(args?: SelectSubset<T, SystemTaskQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemTaskQueue.
     * @param {SystemTaskQueueCreateArgs} args - Arguments to create a SystemTaskQueue.
     * @example
     * // Create one SystemTaskQueue
     * const SystemTaskQueue = await prisma.systemTaskQueue.create({
     *   data: {
     *     // ... data to create a SystemTaskQueue
     *   }
     * })
     * 
     */
    create<T extends SystemTaskQueueCreateArgs>(args: SelectSubset<T, SystemTaskQueueCreateArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemTaskQueues.
     * @param {SystemTaskQueueCreateManyArgs} args - Arguments to create many SystemTaskQueues.
     * @example
     * // Create many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemTaskQueueCreateManyArgs>(args?: SelectSubset<T, SystemTaskQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemTaskQueues and returns the data saved in the database.
     * @param {SystemTaskQueueCreateManyAndReturnArgs} args - Arguments to create many SystemTaskQueues.
     * @example
     * // Create many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemTaskQueues and only return the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemTaskQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemTaskQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemTaskQueue.
     * @param {SystemTaskQueueDeleteArgs} args - Arguments to delete one SystemTaskQueue.
     * @example
     * // Delete one SystemTaskQueue
     * const SystemTaskQueue = await prisma.systemTaskQueue.delete({
     *   where: {
     *     // ... filter to delete one SystemTaskQueue
     *   }
     * })
     * 
     */
    delete<T extends SystemTaskQueueDeleteArgs>(args: SelectSubset<T, SystemTaskQueueDeleteArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemTaskQueue.
     * @param {SystemTaskQueueUpdateArgs} args - Arguments to update one SystemTaskQueue.
     * @example
     * // Update one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemTaskQueueUpdateArgs>(args: SelectSubset<T, SystemTaskQueueUpdateArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemTaskQueues.
     * @param {SystemTaskQueueDeleteManyArgs} args - Arguments to filter SystemTaskQueues to delete.
     * @example
     * // Delete a few SystemTaskQueues
     * const { count } = await prisma.systemTaskQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemTaskQueueDeleteManyArgs>(args?: SelectSubset<T, SystemTaskQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemTaskQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemTaskQueueUpdateManyArgs>(args: SelectSubset<T, SystemTaskQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemTaskQueues and returns the data updated in the database.
     * @param {SystemTaskQueueUpdateManyAndReturnArgs} args - Arguments to update many SystemTaskQueues.
     * @example
     * // Update many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemTaskQueues and only return the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemTaskQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemTaskQueue.
     * @param {SystemTaskQueueUpsertArgs} args - Arguments to update or create a SystemTaskQueue.
     * @example
     * // Update or create a SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.upsert({
     *   create: {
     *     // ... data to create a SystemTaskQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemTaskQueue we want to update
     *   }
     * })
     */
    upsert<T extends SystemTaskQueueUpsertArgs>(args: SelectSubset<T, SystemTaskQueueUpsertArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemTaskQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueCountArgs} args - Arguments to filter SystemTaskQueues to count.
     * @example
     * // Count the number of SystemTaskQueues
     * const count = await prisma.systemTaskQueue.count({
     *   where: {
     *     // ... the filter for the SystemTaskQueues we want to count
     *   }
     * })
    **/
    count<T extends SystemTaskQueueCountArgs>(
      args?: Subset<T, SystemTaskQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemTaskQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemTaskQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemTaskQueueAggregateArgs>(args: Subset<T, SystemTaskQueueAggregateArgs>): Prisma.PrismaPromise<GetSystemTaskQueueAggregateType<T>>

    /**
     * Group by SystemTaskQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemTaskQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemTaskQueueGroupByArgs['orderBy'] }
        : { orderBy?: SystemTaskQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemTaskQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemTaskQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemTaskQueue model
   */
  readonly fields: SystemTaskQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemTaskQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemTaskQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemTaskQueue model
   */
  interface SystemTaskQueueFieldRefs {
    readonly id: FieldRef<"SystemTaskQueue", 'String'>
    readonly taskType: FieldRef<"SystemTaskQueue", 'TaskType'>
    readonly status: FieldRef<"SystemTaskQueue", 'TaskStatus'>
    readonly recipient: FieldRef<"SystemTaskQueue", 'String'>
    readonly templateCode: FieldRef<"SystemTaskQueue", 'String'>
    readonly templateData: FieldRef<"SystemTaskQueue", 'Json'>
    readonly content: FieldRef<"SystemTaskQueue", 'String'>
    readonly subject: FieldRef<"SystemTaskQueue", 'String'>
    readonly retryCount: FieldRef<"SystemTaskQueue", 'Int'>
    readonly processedAt: FieldRef<"SystemTaskQueue", 'DateTime'>
    readonly errorMessage: FieldRef<"SystemTaskQueue", 'String'>
    readonly metadata: FieldRef<"SystemTaskQueue", 'Json'>
    readonly createdAt: FieldRef<"SystemTaskQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemTaskQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemTaskQueue findUnique
   */
  export type SystemTaskQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue findUniqueOrThrow
   */
  export type SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue findFirst
   */
  export type SystemTaskQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTaskQueues.
     */
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue findFirstOrThrow
   */
  export type SystemTaskQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTaskQueues.
     */
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue findMany
   */
  export type SystemTaskQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueues to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue create
   */
  export type SystemTaskQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemTaskQueue.
     */
    data: XOR<SystemTaskQueueCreateInput, SystemTaskQueueUncheckedCreateInput>
  }

  /**
   * SystemTaskQueue createMany
   */
  export type SystemTaskQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemTaskQueues.
     */
    data: SystemTaskQueueCreateManyInput | SystemTaskQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemTaskQueue createManyAndReturn
   */
  export type SystemTaskQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data used to create many SystemTaskQueues.
     */
    data: SystemTaskQueueCreateManyInput | SystemTaskQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemTaskQueue update
   */
  export type SystemTaskQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemTaskQueue.
     */
    data: XOR<SystemTaskQueueUpdateInput, SystemTaskQueueUncheckedUpdateInput>
    /**
     * Choose, which SystemTaskQueue to update.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue updateMany
   */
  export type SystemTaskQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemTaskQueues.
     */
    data: XOR<SystemTaskQueueUpdateManyMutationInput, SystemTaskQueueUncheckedUpdateManyInput>
    /**
     * Filter which SystemTaskQueues to update
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to update.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue updateManyAndReturn
   */
  export type SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data used to update SystemTaskQueues.
     */
    data: XOR<SystemTaskQueueUpdateManyMutationInput, SystemTaskQueueUncheckedUpdateManyInput>
    /**
     * Filter which SystemTaskQueues to update
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to update.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue upsert
   */
  export type SystemTaskQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemTaskQueue to update in case it exists.
     */
    where: SystemTaskQueueWhereUniqueInput
    /**
     * In case the SystemTaskQueue found by the `where` argument doesn't exist, create a new SystemTaskQueue with this data.
     */
    create: XOR<SystemTaskQueueCreateInput, SystemTaskQueueUncheckedCreateInput>
    /**
     * In case the SystemTaskQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemTaskQueueUpdateInput, SystemTaskQueueUncheckedUpdateInput>
  }

  /**
   * SystemTaskQueue delete
   */
  export type SystemTaskQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter which SystemTaskQueue to delete.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue deleteMany
   */
  export type SystemTaskQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemTaskQueues to delete
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to delete.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue without action
   */
  export type SystemTaskQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
  }


  /**
   * Model FileSource
   */

  export type AggregateFileSource = {
    _count: FileSourceCountAggregateOutputType | null
    _avg: FileSourceAvgAggregateOutputType | null
    _sum: FileSourceSumAggregateOutputType | null
    _min: FileSourceMinAggregateOutputType | null
    _max: FileSourceMaxAggregateOutputType | null
  }

  export type FileSourceAvgAggregateOutputType = {
    fsize: number | null
    type: number | null
    status: number | null
    parts: number | null
  }

  export type FileSourceSumAggregateOutputType = {
    fsize: number | null
    type: number | null
    status: number | null
    parts: number[]
  }

  export type FileSourceMinAggregateOutputType = {
    id: string | null
    isUploaded: boolean | null
    bucket: string | null
    key: string | null
    hash: string | null
    thumbImg: string | null
    fsize: number | null
    mimeType: string | null
    type: number | null
    endUser: string | null
    status: number | null
    sha256: string | null
    ext: string | null
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType | null
    vendor: $Enums.FileBucketVendor | null
    region: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileSourceMaxAggregateOutputType = {
    id: string | null
    isUploaded: boolean | null
    bucket: string | null
    key: string | null
    hash: string | null
    thumbImg: string | null
    fsize: number | null
    mimeType: string | null
    type: number | null
    endUser: string | null
    status: number | null
    sha256: string | null
    ext: string | null
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType | null
    vendor: $Enums.FileBucketVendor | null
    region: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileSourceCountAggregateOutputType = {
    id: number
    isUploaded: number
    bucket: number
    key: number
    hash: number
    thumbImg: number
    fsize: number
    mimeType: number
    type: number
    endUser: number
    status: number
    sha256: number
    parts: number
    ext: number
    expireAt: number
    transitionToIaAt: number
    transitionToArchiveAt: number
    transitionToDeepArchiveAt: number
    transitionToArchiveIRAt: number
    env: number
    vendor: number
    region: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FileSourceAvgAggregateInputType = {
    fsize?: true
    type?: true
    status?: true
    parts?: true
  }

  export type FileSourceSumAggregateInputType = {
    fsize?: true
    type?: true
    status?: true
    parts?: true
  }

  export type FileSourceMinAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileSourceMaxAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileSourceCountAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    parts?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FileSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileSource to aggregate.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileSources
    **/
    _count?: true | FileSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileSourceMaxAggregateInputType
  }

  export type GetFileSourceAggregateType<T extends FileSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateFileSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileSource[P]>
      : GetScalarType<T[P], AggregateFileSource[P]>
  }




  export type FileSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileSourceWhereInput
    orderBy?: FileSourceOrderByWithAggregationInput | FileSourceOrderByWithAggregationInput[]
    by: FileSourceScalarFieldEnum[] | FileSourceScalarFieldEnum
    having?: FileSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileSourceCountAggregateInputType | true
    _avg?: FileSourceAvgAggregateInputType
    _sum?: FileSourceSumAggregateInputType
    _min?: FileSourceMinAggregateInputType
    _max?: FileSourceMaxAggregateInputType
  }

  export type FileSourceGroupByOutputType = {
    id: string
    isUploaded: boolean
    bucket: string
    key: string
    hash: string | null
    thumbImg: string | null
    fsize: number
    mimeType: string
    type: number
    endUser: string | null
    status: number
    sha256: string | null
    parts: number[]
    ext: string
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType
    vendor: $Enums.FileBucketVendor
    region: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FileSourceCountAggregateOutputType | null
    _avg: FileSourceAvgAggregateOutputType | null
    _sum: FileSourceSumAggregateOutputType | null
    _min: FileSourceMinAggregateOutputType | null
    _max: FileSourceMaxAggregateOutputType | null
  }

  type GetFileSourceGroupByPayload<T extends FileSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileSourceGroupByOutputType[P]>
            : GetScalarType<T[P], FileSourceGroupByOutputType[P]>
        }
      >
    >


  export type FileSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userAvatars?: boolean | FileSource$userAvatarsArgs<ExtArgs>
    personaTemplates?: boolean | FileSource$personaTemplatesArgs<ExtArgs>
    botAvatars?: boolean | FileSource$botAvatarsArgs<ExtArgs>
    _count?: boolean | FileSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectScalar = {
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FileSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUploaded" | "bucket" | "key" | "hash" | "thumbImg" | "fsize" | "mimeType" | "type" | "endUser" | "status" | "sha256" | "parts" | "ext" | "expireAt" | "transitionToIaAt" | "transitionToArchiveAt" | "transitionToDeepArchiveAt" | "transitionToArchiveIRAt" | "env" | "vendor" | "region" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["fileSource"]>
  export type FileSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAvatars?: boolean | FileSource$userAvatarsArgs<ExtArgs>
    personaTemplates?: boolean | FileSource$personaTemplatesArgs<ExtArgs>
    botAvatars?: boolean | FileSource$botAvatarsArgs<ExtArgs>
    _count?: boolean | FileSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FileSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FileSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileSource"
    objects: {
      userAvatars: Prisma.$UserInfoPayload<ExtArgs>[]
      personaTemplates: Prisma.$PersonaTemplatePayload<ExtArgs>[]
      botAvatars: Prisma.$BotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUploaded: boolean
      bucket: string
      key: string
      hash: string | null
      thumbImg: string | null
      fsize: number
      mimeType: string
      type: number
      endUser: string | null
      status: number
      sha256: string | null
      parts: number[]
      ext: string
      expireAt: Date | null
      transitionToIaAt: Date | null
      transitionToArchiveAt: Date | null
      transitionToDeepArchiveAt: Date | null
      transitionToArchiveIRAt: Date | null
      env: $Enums.FileEnvType
      vendor: $Enums.FileBucketVendor
      region: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["fileSource"]>
    composites: {}
  }

  type FileSourceGetPayload<S extends boolean | null | undefined | FileSourceDefaultArgs> = $Result.GetResult<Prisma.$FileSourcePayload, S>

  type FileSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileSourceCountAggregateInputType | true
    }

  export interface FileSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileSource'], meta: { name: 'FileSource' } }
    /**
     * Find zero or one FileSource that matches the filter.
     * @param {FileSourceFindUniqueArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileSourceFindUniqueArgs>(args: SelectSubset<T, FileSourceFindUniqueArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileSourceFindUniqueOrThrowArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, FileSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindFirstArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileSourceFindFirstArgs>(args?: SelectSubset<T, FileSourceFindFirstArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindFirstOrThrowArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, FileSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileSources
     * const fileSources = await prisma.fileSource.findMany()
     * 
     * // Get first 10 FileSources
     * const fileSources = await prisma.fileSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileSourceFindManyArgs>(args?: SelectSubset<T, FileSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileSource.
     * @param {FileSourceCreateArgs} args - Arguments to create a FileSource.
     * @example
     * // Create one FileSource
     * const FileSource = await prisma.fileSource.create({
     *   data: {
     *     // ... data to create a FileSource
     *   }
     * })
     * 
     */
    create<T extends FileSourceCreateArgs>(args: SelectSubset<T, FileSourceCreateArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileSources.
     * @param {FileSourceCreateManyArgs} args - Arguments to create many FileSources.
     * @example
     * // Create many FileSources
     * const fileSource = await prisma.fileSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileSourceCreateManyArgs>(args?: SelectSubset<T, FileSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileSources and returns the data saved in the database.
     * @param {FileSourceCreateManyAndReturnArgs} args - Arguments to create many FileSources.
     * @example
     * // Create many FileSources
     * const fileSource = await prisma.fileSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileSources and only return the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, FileSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileSource.
     * @param {FileSourceDeleteArgs} args - Arguments to delete one FileSource.
     * @example
     * // Delete one FileSource
     * const FileSource = await prisma.fileSource.delete({
     *   where: {
     *     // ... filter to delete one FileSource
     *   }
     * })
     * 
     */
    delete<T extends FileSourceDeleteArgs>(args: SelectSubset<T, FileSourceDeleteArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileSource.
     * @param {FileSourceUpdateArgs} args - Arguments to update one FileSource.
     * @example
     * // Update one FileSource
     * const fileSource = await prisma.fileSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileSourceUpdateArgs>(args: SelectSubset<T, FileSourceUpdateArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileSources.
     * @param {FileSourceDeleteManyArgs} args - Arguments to filter FileSources to delete.
     * @example
     * // Delete a few FileSources
     * const { count } = await prisma.fileSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileSourceDeleteManyArgs>(args?: SelectSubset<T, FileSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileSources
     * const fileSource = await prisma.fileSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileSourceUpdateManyArgs>(args: SelectSubset<T, FileSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileSources and returns the data updated in the database.
     * @param {FileSourceUpdateManyAndReturnArgs} args - Arguments to update many FileSources.
     * @example
     * // Update many FileSources
     * const fileSource = await prisma.fileSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileSources and only return the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, FileSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileSource.
     * @param {FileSourceUpsertArgs} args - Arguments to update or create a FileSource.
     * @example
     * // Update or create a FileSource
     * const fileSource = await prisma.fileSource.upsert({
     *   create: {
     *     // ... data to create a FileSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileSource we want to update
     *   }
     * })
     */
    upsert<T extends FileSourceUpsertArgs>(args: SelectSubset<T, FileSourceUpsertArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceCountArgs} args - Arguments to filter FileSources to count.
     * @example
     * // Count the number of FileSources
     * const count = await prisma.fileSource.count({
     *   where: {
     *     // ... the filter for the FileSources we want to count
     *   }
     * })
    **/
    count<T extends FileSourceCountArgs>(
      args?: Subset<T, FileSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileSourceAggregateArgs>(args: Subset<T, FileSourceAggregateArgs>): Prisma.PrismaPromise<GetFileSourceAggregateType<T>>

    /**
     * Group by FileSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileSourceGroupByArgs['orderBy'] }
        : { orderBy?: FileSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileSource model
   */
  readonly fields: FileSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAvatars<T extends FileSource$userAvatarsArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$userAvatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personaTemplates<T extends FileSource$personaTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$personaTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    botAvatars<T extends FileSource$botAvatarsArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$botAvatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileSource model
   */
  interface FileSourceFieldRefs {
    readonly id: FieldRef<"FileSource", 'String'>
    readonly isUploaded: FieldRef<"FileSource", 'Boolean'>
    readonly bucket: FieldRef<"FileSource", 'String'>
    readonly key: FieldRef<"FileSource", 'String'>
    readonly hash: FieldRef<"FileSource", 'String'>
    readonly thumbImg: FieldRef<"FileSource", 'String'>
    readonly fsize: FieldRef<"FileSource", 'Float'>
    readonly mimeType: FieldRef<"FileSource", 'String'>
    readonly type: FieldRef<"FileSource", 'Int'>
    readonly endUser: FieldRef<"FileSource", 'String'>
    readonly status: FieldRef<"FileSource", 'Int'>
    readonly sha256: FieldRef<"FileSource", 'String'>
    readonly parts: FieldRef<"FileSource", 'Int[]'>
    readonly ext: FieldRef<"FileSource", 'String'>
    readonly expireAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToIaAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToArchiveAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToDeepArchiveAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToArchiveIRAt: FieldRef<"FileSource", 'DateTime'>
    readonly env: FieldRef<"FileSource", 'FileEnvType'>
    readonly vendor: FieldRef<"FileSource", 'FileBucketVendor'>
    readonly region: FieldRef<"FileSource", 'String'>
    readonly isDeleted: FieldRef<"FileSource", 'Boolean'>
    readonly createdAt: FieldRef<"FileSource", 'DateTime'>
    readonly updatedAt: FieldRef<"FileSource", 'DateTime'>
    readonly deletedAt: FieldRef<"FileSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileSource findUnique
   */
  export type FileSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource findUniqueOrThrow
   */
  export type FileSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource findFirst
   */
  export type FileSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileSources.
     */
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource findFirstOrThrow
   */
  export type FileSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileSources.
     */
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource findMany
   */
  export type FileSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSources to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource create
   */
  export type FileSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a FileSource.
     */
    data: XOR<FileSourceCreateInput, FileSourceUncheckedCreateInput>
  }

  /**
   * FileSource createMany
   */
  export type FileSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileSources.
     */
    data: FileSourceCreateManyInput | FileSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileSource createManyAndReturn
   */
  export type FileSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * The data used to create many FileSources.
     */
    data: FileSourceCreateManyInput | FileSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileSource update
   */
  export type FileSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a FileSource.
     */
    data: XOR<FileSourceUpdateInput, FileSourceUncheckedUpdateInput>
    /**
     * Choose, which FileSource to update.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource updateMany
   */
  export type FileSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileSources.
     */
    data: XOR<FileSourceUpdateManyMutationInput, FileSourceUncheckedUpdateManyInput>
    /**
     * Filter which FileSources to update
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to update.
     */
    limit?: number
  }

  /**
   * FileSource updateManyAndReturn
   */
  export type FileSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * The data used to update FileSources.
     */
    data: XOR<FileSourceUpdateManyMutationInput, FileSourceUncheckedUpdateManyInput>
    /**
     * Filter which FileSources to update
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to update.
     */
    limit?: number
  }

  /**
   * FileSource upsert
   */
  export type FileSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the FileSource to update in case it exists.
     */
    where: FileSourceWhereUniqueInput
    /**
     * In case the FileSource found by the `where` argument doesn't exist, create a new FileSource with this data.
     */
    create: XOR<FileSourceCreateInput, FileSourceUncheckedCreateInput>
    /**
     * In case the FileSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileSourceUpdateInput, FileSourceUncheckedUpdateInput>
  }

  /**
   * FileSource delete
   */
  export type FileSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter which FileSource to delete.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource deleteMany
   */
  export type FileSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileSources to delete
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to delete.
     */
    limit?: number
  }

  /**
   * FileSource.userAvatars
   */
  export type FileSource$userAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    cursor?: UserInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * FileSource.personaTemplates
   */
  export type FileSource$personaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    cursor?: PersonaTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * FileSource.botAvatars
   */
  export type FileSource$botAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * FileSource without action
   */
  export type FileSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
  }


  /**
   * Model CountryCode
   */

  export type AggregateCountryCode = {
    _count: CountryCodeCountAggregateOutputType | null
    _min: CountryCodeMinAggregateOutputType | null
    _max: CountryCodeMaxAggregateOutputType | null
  }

  export type CountryCodeMinAggregateOutputType = {
    id: string | null
    continent: string | null
    code: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryCodeMaxAggregateOutputType = {
    id: string | null
    continent: string | null
    code: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryCodeCountAggregateOutputType = {
    id: number
    continent: number
    code: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CountryCodeMinAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryCodeMaxAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryCodeCountAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CountryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCode to aggregate.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryCodes
    **/
    _count?: true | CountryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryCodeMaxAggregateInputType
  }

  export type GetCountryCodeAggregateType<T extends CountryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryCode[P]>
      : GetScalarType<T[P], AggregateCountryCode[P]>
  }




  export type CountryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCodeWhereInput
    orderBy?: CountryCodeOrderByWithAggregationInput | CountryCodeOrderByWithAggregationInput[]
    by: CountryCodeScalarFieldEnum[] | CountryCodeScalarFieldEnum
    having?: CountryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCodeCountAggregateInputType | true
    _min?: CountryCodeMinAggregateInputType
    _max?: CountryCodeMaxAggregateInputType
  }

  export type CountryCodeGroupByOutputType = {
    id: string
    continent: string
    code: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CountryCodeCountAggregateOutputType | null
    _min: CountryCodeMinAggregateOutputType | null
    _max: CountryCodeMaxAggregateOutputType | null
  }

  type GetCountryCodeGroupByPayload<T extends CountryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CountryCodeGroupByOutputType[P]>
        }
      >
    >


  export type CountryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectScalar = {
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CountryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "continent" | "code" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["countryCode"]>

  export type $CountryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      continent: string
      code: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["countryCode"]>
    composites: {}
  }

  type CountryCodeGetPayload<S extends boolean | null | undefined | CountryCodeDefaultArgs> = $Result.GetResult<Prisma.$CountryCodePayload, S>

  type CountryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCodeCountAggregateInputType | true
    }

  export interface CountryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryCode'], meta: { name: 'CountryCode' } }
    /**
     * Find zero or one CountryCode that matches the filter.
     * @param {CountryCodeFindUniqueArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryCodeFindUniqueArgs>(args: SelectSubset<T, CountryCodeFindUniqueArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryCodeFindUniqueOrThrowArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindFirstArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryCodeFindFirstArgs>(args?: SelectSubset<T, CountryCodeFindFirstArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindFirstOrThrowArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryCodes
     * const countryCodes = await prisma.countryCode.findMany()
     * 
     * // Get first 10 CountryCodes
     * const countryCodes = await prisma.countryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryCodeFindManyArgs>(args?: SelectSubset<T, CountryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountryCode.
     * @param {CountryCodeCreateArgs} args - Arguments to create a CountryCode.
     * @example
     * // Create one CountryCode
     * const CountryCode = await prisma.countryCode.create({
     *   data: {
     *     // ... data to create a CountryCode
     *   }
     * })
     * 
     */
    create<T extends CountryCodeCreateArgs>(args: SelectSubset<T, CountryCodeCreateArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountryCodes.
     * @param {CountryCodeCreateManyArgs} args - Arguments to create many CountryCodes.
     * @example
     * // Create many CountryCodes
     * const countryCode = await prisma.countryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCodeCreateManyArgs>(args?: SelectSubset<T, CountryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryCodes and returns the data saved in the database.
     * @param {CountryCodeCreateManyAndReturnArgs} args - Arguments to create many CountryCodes.
     * @example
     * // Create many CountryCodes
     * const countryCode = await prisma.countryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryCodes and only return the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountryCode.
     * @param {CountryCodeDeleteArgs} args - Arguments to delete one CountryCode.
     * @example
     * // Delete one CountryCode
     * const CountryCode = await prisma.countryCode.delete({
     *   where: {
     *     // ... filter to delete one CountryCode
     *   }
     * })
     * 
     */
    delete<T extends CountryCodeDeleteArgs>(args: SelectSubset<T, CountryCodeDeleteArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountryCode.
     * @param {CountryCodeUpdateArgs} args - Arguments to update one CountryCode.
     * @example
     * // Update one CountryCode
     * const countryCode = await prisma.countryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryCodeUpdateArgs>(args: SelectSubset<T, CountryCodeUpdateArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountryCodes.
     * @param {CountryCodeDeleteManyArgs} args - Arguments to filter CountryCodes to delete.
     * @example
     * // Delete a few CountryCodes
     * const { count } = await prisma.countryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryCodeDeleteManyArgs>(args?: SelectSubset<T, CountryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryCodes
     * const countryCode = await prisma.countryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryCodeUpdateManyArgs>(args: SelectSubset<T, CountryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCodes and returns the data updated in the database.
     * @param {CountryCodeUpdateManyAndReturnArgs} args - Arguments to update many CountryCodes.
     * @example
     * // Update many CountryCodes
     * const countryCode = await prisma.countryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountryCodes and only return the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountryCode.
     * @param {CountryCodeUpsertArgs} args - Arguments to update or create a CountryCode.
     * @example
     * // Update or create a CountryCode
     * const countryCode = await prisma.countryCode.upsert({
     *   create: {
     *     // ... data to create a CountryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryCode we want to update
     *   }
     * })
     */
    upsert<T extends CountryCodeUpsertArgs>(args: SelectSubset<T, CountryCodeUpsertArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeCountArgs} args - Arguments to filter CountryCodes to count.
     * @example
     * // Count the number of CountryCodes
     * const count = await prisma.countryCode.count({
     *   where: {
     *     // ... the filter for the CountryCodes we want to count
     *   }
     * })
    **/
    count<T extends CountryCodeCountArgs>(
      args?: Subset<T, CountryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryCodeAggregateArgs>(args: Subset<T, CountryCodeAggregateArgs>): Prisma.PrismaPromise<GetCountryCodeAggregateType<T>>

    /**
     * Group by CountryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryCodeGroupByArgs['orderBy'] }
        : { orderBy?: CountryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryCode model
   */
  readonly fields: CountryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryCode model
   */
  interface CountryCodeFieldRefs {
    readonly id: FieldRef<"CountryCode", 'String'>
    readonly continent: FieldRef<"CountryCode", 'String'>
    readonly code: FieldRef<"CountryCode", 'String'>
    readonly isDeleted: FieldRef<"CountryCode", 'Boolean'>
    readonly createdAt: FieldRef<"CountryCode", 'DateTime'>
    readonly updatedAt: FieldRef<"CountryCode", 'DateTime'>
    readonly deletedAt: FieldRef<"CountryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CountryCode findUnique
   */
  export type CountryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode findUniqueOrThrow
   */
  export type CountryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode findFirst
   */
  export type CountryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCodes.
     */
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode findFirstOrThrow
   */
  export type CountryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCodes.
     */
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode findMany
   */
  export type CountryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCodes to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode create
   */
  export type CountryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data needed to create a CountryCode.
     */
    data: XOR<CountryCodeCreateInput, CountryCodeUncheckedCreateInput>
  }

  /**
   * CountryCode createMany
   */
  export type CountryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryCodes.
     */
    data: CountryCodeCreateManyInput | CountryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCode createManyAndReturn
   */
  export type CountryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many CountryCodes.
     */
    data: CountryCodeCreateManyInput | CountryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCode update
   */
  export type CountryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data needed to update a CountryCode.
     */
    data: XOR<CountryCodeUpdateInput, CountryCodeUncheckedUpdateInput>
    /**
     * Choose, which CountryCode to update.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode updateMany
   */
  export type CountryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryCodes.
     */
    data: XOR<CountryCodeUpdateManyMutationInput, CountryCodeUncheckedUpdateManyInput>
    /**
     * Filter which CountryCodes to update
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to update.
     */
    limit?: number
  }

  /**
   * CountryCode updateManyAndReturn
   */
  export type CountryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data used to update CountryCodes.
     */
    data: XOR<CountryCodeUpdateManyMutationInput, CountryCodeUncheckedUpdateManyInput>
    /**
     * Filter which CountryCodes to update
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to update.
     */
    limit?: number
  }

  /**
   * CountryCode upsert
   */
  export type CountryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The filter to search for the CountryCode to update in case it exists.
     */
    where: CountryCodeWhereUniqueInput
    /**
     * In case the CountryCode found by the `where` argument doesn't exist, create a new CountryCode with this data.
     */
    create: XOR<CountryCodeCreateInput, CountryCodeUncheckedCreateInput>
    /**
     * In case the CountryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryCodeUpdateInput, CountryCodeUncheckedUpdateInput>
  }

  /**
   * CountryCode delete
   */
  export type CountryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter which CountryCode to delete.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode deleteMany
   */
  export type CountryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCodes to delete
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to delete.
     */
    limit?: number
  }

  /**
   * CountryCode without action
   */
  export type CountryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
  }


  /**
   * Model Bot
   */

  export type AggregateBot = {
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  export type BotAvgAggregateOutputType = {
    port: number | null
  }

  export type BotSumAggregateOutputType = {
    port: number | null
  }

  export type BotMinAggregateOutputType = {
    id: string | null
    name: string | null
    hostname: string | null
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    status: $Enums.BotStatus | null
    createdById: string | null
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    healthStatus: $Enums.HealthStatus | null
    lastHealthCheck: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    hostname: string | null
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    status: $Enums.BotStatus | null
    createdById: string | null
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    healthStatus: $Enums.HealthStatus | null
    lastHealthCheck: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotCountAggregateOutputType = {
    id: number
    name: number
    hostname: number
    containerId: number
    port: number
    gatewayToken: number
    proxyTokenHash: number
    tags: number
    status: number
    createdById: number
    personaTemplateId: number
    emoji: number
    avatarFileId: number
    soulMarkdown: number
    pendingConfig: number
    healthStatus: number
    lastHealthCheck: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BotAvgAggregateInputType = {
    port?: true
  }

  export type BotSumAggregateInputType = {
    port?: true
  }

  export type BotMinAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    healthStatus?: true
    lastHealthCheck?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotMaxAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    healthStatus?: true
    lastHealthCheck?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotCountAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    tags?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    pendingConfig?: true
    healthStatus?: true
    lastHealthCheck?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bot to aggregate.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bots
    **/
    _count?: true | BotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotMaxAggregateInputType
  }

  export type GetBotAggregateType<T extends BotAggregateArgs> = {
        [P in keyof T & keyof AggregateBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot[P]>
      : GetScalarType<T[P], AggregateBot[P]>
  }




  export type BotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
    orderBy?: BotOrderByWithAggregationInput | BotOrderByWithAggregationInput[]
    by: BotScalarFieldEnum[] | BotScalarFieldEnum
    having?: BotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotCountAggregateInputType | true
    _avg?: BotAvgAggregateInputType
    _sum?: BotSumAggregateInputType
    _min?: BotMinAggregateInputType
    _max?: BotMaxAggregateInputType
  }

  export type BotGroupByOutputType = {
    id: string
    name: string
    hostname: string
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    tags: string[]
    status: $Enums.BotStatus
    createdById: string
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    pendingConfig: JsonValue | null
    healthStatus: $Enums.HealthStatus
    lastHealthCheck: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  type GetBotGroupByPayload<T extends BotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotGroupByOutputType[P]>
            : GetScalarType<T[P], BotGroupByOutputType[P]>
        }
      >
    >


  export type BotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    pendingConfig?: boolean
    healthStatus?: boolean
    lastHealthCheck?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
    providerKeys?: boolean | Bot$providerKeysArgs<ExtArgs>
    usageLogs?: boolean | Bot$usageLogsArgs<ExtArgs>
    proxyToken?: boolean | Bot$proxyTokenArgs<ExtArgs>
    plugins?: boolean | Bot$pluginsArgs<ExtArgs>
    skills?: boolean | Bot$skillsArgs<ExtArgs>
    channels?: boolean | Bot$channelsArgs<ExtArgs>
    modelRoutings?: boolean | Bot$modelRoutingsArgs<ExtArgs>
    routingConfig?: boolean | Bot$routingConfigArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    pendingConfig?: boolean
    healthStatus?: boolean
    lastHealthCheck?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    pendingConfig?: boolean
    healthStatus?: boolean
    lastHealthCheck?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectScalar = {
    id?: boolean
    name?: boolean
    hostname?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    pendingConfig?: boolean
    healthStatus?: boolean
    lastHealthCheck?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "hostname" | "containerId" | "port" | "gatewayToken" | "proxyTokenHash" | "tags" | "status" | "createdById" | "personaTemplateId" | "emoji" | "avatarFileId" | "soulMarkdown" | "pendingConfig" | "healthStatus" | "lastHealthCheck" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["bot"]>
  export type BotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
    providerKeys?: boolean | Bot$providerKeysArgs<ExtArgs>
    usageLogs?: boolean | Bot$usageLogsArgs<ExtArgs>
    proxyToken?: boolean | Bot$proxyTokenArgs<ExtArgs>
    plugins?: boolean | Bot$pluginsArgs<ExtArgs>
    skills?: boolean | Bot$skillsArgs<ExtArgs>
    channels?: boolean | Bot$channelsArgs<ExtArgs>
    modelRoutings?: boolean | Bot$modelRoutingsArgs<ExtArgs>
    routingConfig?: boolean | Bot$routingConfigArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }
  export type BotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }

  export type $BotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bot"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs>
      personaTemplate: Prisma.$PersonaTemplatePayload<ExtArgs> | null
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      providerKeys: Prisma.$BotProviderKeyPayload<ExtArgs>[]
      usageLogs: Prisma.$BotUsageLogPayload<ExtArgs>[]
      proxyToken: Prisma.$ProxyTokenPayload<ExtArgs> | null
      plugins: Prisma.$BotPluginPayload<ExtArgs>[]
      skills: Prisma.$BotSkillPayload<ExtArgs>[]
      channels: Prisma.$BotChannelPayload<ExtArgs>[]
      modelRoutings: Prisma.$BotModelRoutingPayload<ExtArgs>[]
      routingConfig: Prisma.$BotRoutingConfigPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      hostname: string
      containerId: string | null
      port: number | null
      gatewayToken: string | null
      proxyTokenHash: string | null
      tags: string[]
      status: $Enums.BotStatus
      createdById: string
      personaTemplateId: string | null
      emoji: string | null
      avatarFileId: string | null
      soulMarkdown: string | null
      pendingConfig: Prisma.JsonValue | null
      healthStatus: $Enums.HealthStatus
      lastHealthCheck: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["bot"]>
    composites: {}
  }

  type BotGetPayload<S extends boolean | null | undefined | BotDefaultArgs> = $Result.GetResult<Prisma.$BotPayload, S>

  type BotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotCountAggregateInputType | true
    }

  export interface BotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bot'], meta: { name: 'Bot' } }
    /**
     * Find zero or one Bot that matches the filter.
     * @param {BotFindUniqueArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotFindUniqueArgs>(args: SelectSubset<T, BotFindUniqueArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotFindUniqueOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotFindUniqueOrThrowArgs>(args: SelectSubset<T, BotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotFindFirstArgs>(args?: SelectSubset<T, BotFindFirstArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotFindFirstOrThrowArgs>(args?: SelectSubset<T, BotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bot.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botWithIdOnly = await prisma.bot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotFindManyArgs>(args?: SelectSubset<T, BotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bot.
     * @param {BotCreateArgs} args - Arguments to create a Bot.
     * @example
     * // Create one Bot
     * const Bot = await prisma.bot.create({
     *   data: {
     *     // ... data to create a Bot
     *   }
     * })
     * 
     */
    create<T extends BotCreateArgs>(args: SelectSubset<T, BotCreateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bots.
     * @param {BotCreateManyArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotCreateManyArgs>(args?: SelectSubset<T, BotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bots and returns the data saved in the database.
     * @param {BotCreateManyAndReturnArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotCreateManyAndReturnArgs>(args?: SelectSubset<T, BotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bot.
     * @param {BotDeleteArgs} args - Arguments to delete one Bot.
     * @example
     * // Delete one Bot
     * const Bot = await prisma.bot.delete({
     *   where: {
     *     // ... filter to delete one Bot
     *   }
     * })
     * 
     */
    delete<T extends BotDeleteArgs>(args: SelectSubset<T, BotDeleteArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bot.
     * @param {BotUpdateArgs} args - Arguments to update one Bot.
     * @example
     * // Update one Bot
     * const bot = await prisma.bot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotUpdateArgs>(args: SelectSubset<T, BotUpdateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bots.
     * @param {BotDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotDeleteManyArgs>(args?: SelectSubset<T, BotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotUpdateManyArgs>(args: SelectSubset<T, BotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots and returns the data updated in the database.
     * @param {BotUpdateManyAndReturnArgs} args - Arguments to update many Bots.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotUpdateManyAndReturnArgs>(args: SelectSubset<T, BotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bot.
     * @param {BotUpsertArgs} args - Arguments to update or create a Bot.
     * @example
     * // Update or create a Bot
     * const bot = await prisma.bot.upsert({
     *   create: {
     *     // ... data to create a Bot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot we want to update
     *   }
     * })
     */
    upsert<T extends BotUpsertArgs>(args: SelectSubset<T, BotUpsertArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bot.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends BotCountArgs>(
      args?: Subset<T, BotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotAggregateArgs>(args: Subset<T, BotAggregateArgs>): Prisma.PrismaPromise<GetBotAggregateType<T>>

    /**
     * Group by Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotGroupByArgs['orderBy'] }
        : { orderBy?: BotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bot model
   */
  readonly fields: BotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personaTemplate<T extends Bot$personaTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Bot$personaTemplateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avatarFile<T extends Bot$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, Bot$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providerKeys<T extends Bot$providerKeysArgs<ExtArgs> = {}>(args?: Subset<T, Bot$providerKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends Bot$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyToken<T extends Bot$proxyTokenArgs<ExtArgs> = {}>(args?: Subset<T, Bot$proxyTokenArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    plugins<T extends Bot$pluginsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$pluginsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    skills<T extends Bot$skillsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    channels<T extends Bot$channelsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$channelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    modelRoutings<T extends Bot$modelRoutingsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$modelRoutingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    routingConfig<T extends Bot$routingConfigArgs<ExtArgs> = {}>(args?: Subset<T, Bot$routingConfigArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bot model
   */
  interface BotFieldRefs {
    readonly id: FieldRef<"Bot", 'String'>
    readonly name: FieldRef<"Bot", 'String'>
    readonly hostname: FieldRef<"Bot", 'String'>
    readonly containerId: FieldRef<"Bot", 'String'>
    readonly port: FieldRef<"Bot", 'Int'>
    readonly gatewayToken: FieldRef<"Bot", 'String'>
    readonly proxyTokenHash: FieldRef<"Bot", 'String'>
    readonly tags: FieldRef<"Bot", 'String[]'>
    readonly status: FieldRef<"Bot", 'BotStatus'>
    readonly createdById: FieldRef<"Bot", 'String'>
    readonly personaTemplateId: FieldRef<"Bot", 'String'>
    readonly emoji: FieldRef<"Bot", 'String'>
    readonly avatarFileId: FieldRef<"Bot", 'String'>
    readonly soulMarkdown: FieldRef<"Bot", 'String'>
    readonly pendingConfig: FieldRef<"Bot", 'Json'>
    readonly healthStatus: FieldRef<"Bot", 'HealthStatus'>
    readonly lastHealthCheck: FieldRef<"Bot", 'DateTime'>
    readonly isDeleted: FieldRef<"Bot", 'Boolean'>
    readonly createdAt: FieldRef<"Bot", 'DateTime'>
    readonly updatedAt: FieldRef<"Bot", 'DateTime'>
    readonly deletedAt: FieldRef<"Bot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bot findUnique
   */
  export type BotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findUniqueOrThrow
   */
  export type BotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findFirst
   */
  export type BotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findFirstOrThrow
   */
  export type BotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findMany
   */
  export type BotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bots to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot create
   */
  export type BotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to create a Bot.
     */
    data: XOR<BotCreateInput, BotUncheckedCreateInput>
  }

  /**
   * Bot createMany
   */
  export type BotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bot createManyAndReturn
   */
  export type BotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot update
   */
  export type BotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to update a Bot.
     */
    data: XOR<BotUpdateInput, BotUncheckedUpdateInput>
    /**
     * Choose, which Bot to update.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot updateMany
   */
  export type BotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
  }

  /**
   * Bot updateManyAndReturn
   */
  export type BotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot upsert
   */
  export type BotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The filter to search for the Bot to update in case it exists.
     */
    where: BotWhereUniqueInput
    /**
     * In case the Bot found by the `where` argument doesn't exist, create a new Bot with this data.
     */
    create: XOR<BotCreateInput, BotUncheckedCreateInput>
    /**
     * In case the Bot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUpdateInput, BotUncheckedUpdateInput>
  }

  /**
   * Bot delete
   */
  export type BotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter which Bot to delete.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot deleteMany
   */
  export type BotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bots to delete
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to delete.
     */
    limit?: number
  }

  /**
   * Bot.personaTemplate
   */
  export type Bot$personaTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
  }

  /**
   * Bot.avatarFile
   */
  export type Bot$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * Bot.providerKeys
   */
  export type Bot$providerKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    cursor?: BotProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * Bot.usageLogs
   */
  export type Bot$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    cursor?: BotUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * Bot.proxyToken
   */
  export type Bot$proxyTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    where?: ProxyTokenWhereInput
  }

  /**
   * Bot.plugins
   */
  export type Bot$pluginsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    where?: BotPluginWhereInput
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    cursor?: BotPluginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotPluginScalarFieldEnum | BotPluginScalarFieldEnum[]
  }

  /**
   * Bot.skills
   */
  export type Bot$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    where?: BotSkillWhereInput
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    cursor?: BotSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotSkillScalarFieldEnum | BotSkillScalarFieldEnum[]
  }

  /**
   * Bot.channels
   */
  export type Bot$channelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    where?: BotChannelWhereInput
    orderBy?: BotChannelOrderByWithRelationInput | BotChannelOrderByWithRelationInput[]
    cursor?: BotChannelWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotChannelScalarFieldEnum | BotChannelScalarFieldEnum[]
  }

  /**
   * Bot.modelRoutings
   */
  export type Bot$modelRoutingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    where?: BotModelRoutingWhereInput
    orderBy?: BotModelRoutingOrderByWithRelationInput | BotModelRoutingOrderByWithRelationInput[]
    cursor?: BotModelRoutingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotModelRoutingScalarFieldEnum | BotModelRoutingScalarFieldEnum[]
  }

  /**
   * Bot.routingConfig
   */
  export type Bot$routingConfigArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    where?: BotRoutingConfigWhereInput
  }

  /**
   * Bot without action
   */
  export type BotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
  }


  /**
   * Model ProviderKey
   */

  export type AggregateProviderKey = {
    _count: ProviderKeyCountAggregateOutputType | null
    _min: ProviderKeyMinAggregateOutputType | null
    _max: ProviderKeyMaxAggregateOutputType | null
  }

  export type ProviderKeyMinAggregateOutputType = {
    id: string | null
    vendor: string | null
    apiType: string | null
    secretEncrypted: Bytes | null
    label: string | null
    tag: string | null
    baseUrl: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProviderKeyMaxAggregateOutputType = {
    id: string | null
    vendor: string | null
    apiType: string | null
    secretEncrypted: Bytes | null
    label: string | null
    tag: string | null
    baseUrl: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProviderKeyCountAggregateOutputType = {
    id: number
    vendor: number
    apiType: number
    secretEncrypted: number
    label: number
    tag: number
    baseUrl: number
    createdById: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProviderKeyMinAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProviderKeyMaxAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProviderKeyCountAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProviderKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderKey to aggregate.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderKeys
    **/
    _count?: true | ProviderKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderKeyMaxAggregateInputType
  }

  export type GetProviderKeyAggregateType<T extends ProviderKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderKey[P]>
      : GetScalarType<T[P], AggregateProviderKey[P]>
  }




  export type ProviderKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderKeyWhereInput
    orderBy?: ProviderKeyOrderByWithAggregationInput | ProviderKeyOrderByWithAggregationInput[]
    by: ProviderKeyScalarFieldEnum[] | ProviderKeyScalarFieldEnum
    having?: ProviderKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderKeyCountAggregateInputType | true
    _min?: ProviderKeyMinAggregateInputType
    _max?: ProviderKeyMaxAggregateInputType
  }

  export type ProviderKeyGroupByOutputType = {
    id: string
    vendor: string
    apiType: string | null
    secretEncrypted: Bytes
    label: string
    tag: string | null
    baseUrl: string | null
    createdById: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProviderKeyCountAggregateOutputType | null
    _min: ProviderKeyMinAggregateOutputType | null
    _max: ProviderKeyMaxAggregateOutputType | null
  }

  type GetProviderKeyGroupByPayload<T extends ProviderKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderKeyGroupByOutputType[P]>
        }
      >
    >


  export type ProviderKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    botProviderKeys?: boolean | ProviderKey$botProviderKeysArgs<ExtArgs>
    usageLogs?: boolean | ProviderKey$usageLogsArgs<ExtArgs>
    proxyTokens?: boolean | ProviderKey$proxyTokensArgs<ExtArgs>
    _count?: boolean | ProviderKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectScalar = {
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProviderKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor" | "apiType" | "secretEncrypted" | "label" | "tag" | "baseUrl" | "createdById" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["providerKey"]>
  export type ProviderKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    botProviderKeys?: boolean | ProviderKey$botProviderKeysArgs<ExtArgs>
    usageLogs?: boolean | ProviderKey$usageLogsArgs<ExtArgs>
    proxyTokens?: boolean | ProviderKey$proxyTokensArgs<ExtArgs>
    _count?: boolean | ProviderKeyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type ProviderKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $ProviderKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderKey"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs>
      botProviderKeys: Prisma.$BotProviderKeyPayload<ExtArgs>[]
      usageLogs: Prisma.$BotUsageLogPayload<ExtArgs>[]
      proxyTokens: Prisma.$ProxyTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * ä¸»é”® UUID
       */
      id: string
      /**
       * æœåŠ¡å•†æ ‡è¯†ï¼šopenai, anthropic, google, venice, deepseek, groq, custom ç­‰
       */
      vendor: string
      /**
       * API åè®®ç±»å‹ï¼šopenai, anthropic, gemini, azure-openai, aws-bedrock, vertexai, ollama, new-api, gateway ç­‰
       * ç”¨äºç¡®å®š API è°ƒç”¨æ–¹å¼ï¼Œcustom æœåŠ¡å•†å¿…å¡«
       */
      apiType: string | null
      /**
       * åŠ å¯†å­˜å‚¨çš„ API å¯†é’¥ï¼ˆAES-256-GCM åŠ å¯†ï¼‰
       */
      secretEncrypted: Prisma.Bytes
      /**
       * å¯†é’¥åç§°ï¼ˆå¿…å¡«ï¼‰ï¼Œç”¨äºç”¨æˆ·è¯†åˆ«ä¸åŒå¯†é’¥ï¼ŒåŒä¸€ç”¨æˆ·ä¸‹å”¯ä¸€
       */
      label: string
      /**
       * è·¯ç”±æ ‡ç­¾ï¼Œç”¨äºåœ¨å¤šå¯†é’¥åœºæ™¯ä¸‹è¿›è¡Œæµé‡åˆ†é…
       */
      tag: string | null
      /**
       * è‡ªå®šä¹‰ API åœ°å€ï¼Œç”¨äºç§æœ‰éƒ¨ç½²æˆ–ä»£ç†æœåŠ¡
       */
      baseUrl: string | null
      /**
       * åˆ›å»ºè€…ç”¨æˆ· ID
       */
      createdById: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["providerKey"]>
    composites: {}
  }

  type ProviderKeyGetPayload<S extends boolean | null | undefined | ProviderKeyDefaultArgs> = $Result.GetResult<Prisma.$ProviderKeyPayload, S>

  type ProviderKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderKeyCountAggregateInputType | true
    }

  export interface ProviderKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderKey'], meta: { name: 'ProviderKey' } }
    /**
     * Find zero or one ProviderKey that matches the filter.
     * @param {ProviderKeyFindUniqueArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderKeyFindUniqueArgs>(args: SelectSubset<T, ProviderKeyFindUniqueArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderKeyFindUniqueOrThrowArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindFirstArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderKeyFindFirstArgs>(args?: SelectSubset<T, ProviderKeyFindFirstArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindFirstOrThrowArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderKeys
     * const providerKeys = await prisma.providerKey.findMany()
     * 
     * // Get first 10 ProviderKeys
     * const providerKeys = await prisma.providerKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderKeyFindManyArgs>(args?: SelectSubset<T, ProviderKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderKey.
     * @param {ProviderKeyCreateArgs} args - Arguments to create a ProviderKey.
     * @example
     * // Create one ProviderKey
     * const ProviderKey = await prisma.providerKey.create({
     *   data: {
     *     // ... data to create a ProviderKey
     *   }
     * })
     * 
     */
    create<T extends ProviderKeyCreateArgs>(args: SelectSubset<T, ProviderKeyCreateArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderKeys.
     * @param {ProviderKeyCreateManyArgs} args - Arguments to create many ProviderKeys.
     * @example
     * // Create many ProviderKeys
     * const providerKey = await prisma.providerKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderKeyCreateManyArgs>(args?: SelectSubset<T, ProviderKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderKeys and returns the data saved in the database.
     * @param {ProviderKeyCreateManyAndReturnArgs} args - Arguments to create many ProviderKeys.
     * @example
     * // Create many ProviderKeys
     * const providerKey = await prisma.providerKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderKeys and only return the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderKey.
     * @param {ProviderKeyDeleteArgs} args - Arguments to delete one ProviderKey.
     * @example
     * // Delete one ProviderKey
     * const ProviderKey = await prisma.providerKey.delete({
     *   where: {
     *     // ... filter to delete one ProviderKey
     *   }
     * })
     * 
     */
    delete<T extends ProviderKeyDeleteArgs>(args: SelectSubset<T, ProviderKeyDeleteArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderKey.
     * @param {ProviderKeyUpdateArgs} args - Arguments to update one ProviderKey.
     * @example
     * // Update one ProviderKey
     * const providerKey = await prisma.providerKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderKeyUpdateArgs>(args: SelectSubset<T, ProviderKeyUpdateArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderKeys.
     * @param {ProviderKeyDeleteManyArgs} args - Arguments to filter ProviderKeys to delete.
     * @example
     * // Delete a few ProviderKeys
     * const { count } = await prisma.providerKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderKeyDeleteManyArgs>(args?: SelectSubset<T, ProviderKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderKeys
     * const providerKey = await prisma.providerKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderKeyUpdateManyArgs>(args: SelectSubset<T, ProviderKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderKeys and returns the data updated in the database.
     * @param {ProviderKeyUpdateManyAndReturnArgs} args - Arguments to update many ProviderKeys.
     * @example
     * // Update many ProviderKeys
     * const providerKey = await prisma.providerKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderKeys and only return the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderKey.
     * @param {ProviderKeyUpsertArgs} args - Arguments to update or create a ProviderKey.
     * @example
     * // Update or create a ProviderKey
     * const providerKey = await prisma.providerKey.upsert({
     *   create: {
     *     // ... data to create a ProviderKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderKey we want to update
     *   }
     * })
     */
    upsert<T extends ProviderKeyUpsertArgs>(args: SelectSubset<T, ProviderKeyUpsertArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyCountArgs} args - Arguments to filter ProviderKeys to count.
     * @example
     * // Count the number of ProviderKeys
     * const count = await prisma.providerKey.count({
     *   where: {
     *     // ... the filter for the ProviderKeys we want to count
     *   }
     * })
    **/
    count<T extends ProviderKeyCountArgs>(
      args?: Subset<T, ProviderKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderKeyAggregateArgs>(args: Subset<T, ProviderKeyAggregateArgs>): Prisma.PrismaPromise<GetProviderKeyAggregateType<T>>

    /**
     * Group by ProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderKeyGroupByArgs['orderBy'] }
        : { orderBy?: ProviderKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderKey model
   */
  readonly fields: ProviderKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    botProviderKeys<T extends ProviderKey$botProviderKeysArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$botProviderKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends ProviderKey$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyTokens<T extends ProviderKey$proxyTokensArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$proxyTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderKey model
   */
  interface ProviderKeyFieldRefs {
    readonly id: FieldRef<"ProviderKey", 'String'>
    readonly vendor: FieldRef<"ProviderKey", 'String'>
    readonly apiType: FieldRef<"ProviderKey", 'String'>
    readonly secretEncrypted: FieldRef<"ProviderKey", 'Bytes'>
    readonly label: FieldRef<"ProviderKey", 'String'>
    readonly tag: FieldRef<"ProviderKey", 'String'>
    readonly baseUrl: FieldRef<"ProviderKey", 'String'>
    readonly createdById: FieldRef<"ProviderKey", 'String'>
    readonly isDeleted: FieldRef<"ProviderKey", 'Boolean'>
    readonly createdAt: FieldRef<"ProviderKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ProviderKey", 'DateTime'>
    readonly deletedAt: FieldRef<"ProviderKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderKey findUnique
   */
  export type ProviderKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey findUniqueOrThrow
   */
  export type ProviderKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey findFirst
   */
  export type ProviderKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderKeys.
     */
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey findFirstOrThrow
   */
  export type ProviderKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderKeys.
     */
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey findMany
   */
  export type ProviderKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKeys to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey create
   */
  export type ProviderKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderKey.
     */
    data: XOR<ProviderKeyCreateInput, ProviderKeyUncheckedCreateInput>
  }

  /**
   * ProviderKey createMany
   */
  export type ProviderKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderKeys.
     */
    data: ProviderKeyCreateManyInput | ProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderKey createManyAndReturn
   */
  export type ProviderKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderKeys.
     */
    data: ProviderKeyCreateManyInput | ProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderKey update
   */
  export type ProviderKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderKey.
     */
    data: XOR<ProviderKeyUpdateInput, ProviderKeyUncheckedUpdateInput>
    /**
     * Choose, which ProviderKey to update.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey updateMany
   */
  export type ProviderKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderKeys.
     */
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderKeys to update
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to update.
     */
    limit?: number
  }

  /**
   * ProviderKey updateManyAndReturn
   */
  export type ProviderKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to update ProviderKeys.
     */
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderKeys to update
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderKey upsert
   */
  export type ProviderKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderKey to update in case it exists.
     */
    where: ProviderKeyWhereUniqueInput
    /**
     * In case the ProviderKey found by the `where` argument doesn't exist, create a new ProviderKey with this data.
     */
    create: XOR<ProviderKeyCreateInput, ProviderKeyUncheckedCreateInput>
    /**
     * In case the ProviderKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderKeyUpdateInput, ProviderKeyUncheckedUpdateInput>
  }

  /**
   * ProviderKey delete
   */
  export type ProviderKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter which ProviderKey to delete.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey deleteMany
   */
  export type ProviderKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderKeys to delete
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to delete.
     */
    limit?: number
  }

  /**
   * ProviderKey.botProviderKeys
   */
  export type ProviderKey$botProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    cursor?: BotProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey.usageLogs
   */
  export type ProviderKey$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    cursor?: BotUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * ProviderKey.proxyTokens
   */
  export type ProviderKey$proxyTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    where?: ProxyTokenWhereInput
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    cursor?: ProxyTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProviderKey without action
   */
  export type ProviderKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
  }


  /**
   * Model BotProviderKey
   */

  export type AggregateBotProviderKey = {
    _count: BotProviderKeyCountAggregateOutputType | null
    _min: BotProviderKeyMinAggregateOutputType | null
    _max: BotProviderKeyMaxAggregateOutputType | null
  }

  export type BotProviderKeyMinAggregateOutputType = {
    id: string | null
    botId: string | null
    providerKeyId: string | null
    isPrimary: boolean | null
    primaryModel: string | null
    createdAt: Date | null
  }

  export type BotProviderKeyMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    providerKeyId: string | null
    isPrimary: boolean | null
    primaryModel: string | null
    createdAt: Date | null
  }

  export type BotProviderKeyCountAggregateOutputType = {
    id: number
    botId: number
    providerKeyId: number
    isPrimary: number
    allowedModels: number
    primaryModel: number
    createdAt: number
    _all: number
  }


  export type BotProviderKeyMinAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    primaryModel?: true
    createdAt?: true
  }

  export type BotProviderKeyMaxAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    primaryModel?: true
    createdAt?: true
  }

  export type BotProviderKeyCountAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    allowedModels?: true
    primaryModel?: true
    createdAt?: true
    _all?: true
  }

  export type BotProviderKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotProviderKey to aggregate.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotProviderKeys
    **/
    _count?: true | BotProviderKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotProviderKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotProviderKeyMaxAggregateInputType
  }

  export type GetBotProviderKeyAggregateType<T extends BotProviderKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateBotProviderKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotProviderKey[P]>
      : GetScalarType<T[P], AggregateBotProviderKey[P]>
  }




  export type BotProviderKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithAggregationInput | BotProviderKeyOrderByWithAggregationInput[]
    by: BotProviderKeyScalarFieldEnum[] | BotProviderKeyScalarFieldEnum
    having?: BotProviderKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotProviderKeyCountAggregateInputType | true
    _min?: BotProviderKeyMinAggregateInputType
    _max?: BotProviderKeyMaxAggregateInputType
  }

  export type BotProviderKeyGroupByOutputType = {
    id: string
    botId: string
    providerKeyId: string
    isPrimary: boolean
    allowedModels: string[]
    primaryModel: string | null
    createdAt: Date
    _count: BotProviderKeyCountAggregateOutputType | null
    _min: BotProviderKeyMinAggregateOutputType | null
    _max: BotProviderKeyMaxAggregateOutputType | null
  }

  type GetBotProviderKeyGroupByPayload<T extends BotProviderKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotProviderKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotProviderKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotProviderKeyGroupByOutputType[P]>
            : GetScalarType<T[P], BotProviderKeyGroupByOutputType[P]>
        }
      >
    >


  export type BotProviderKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    allowedModels?: boolean
    primaryModel?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    allowedModels?: boolean
    primaryModel?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    allowedModels?: boolean
    primaryModel?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectScalar = {
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    allowedModels?: boolean
    primaryModel?: boolean
    createdAt?: boolean
  }

  export type BotProviderKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "providerKeyId" | "isPrimary" | "allowedModels" | "primaryModel" | "createdAt", ExtArgs["result"]["botProviderKey"]>
  export type BotProviderKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type BotProviderKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type BotProviderKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }

  export type $BotProviderKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotProviderKey"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      providerKeyId: string
      isPrimary: boolean
      /**
       * å…è®¸ä½¿ç”¨çš„æ¨¡å‹åˆ—è¡¨
       */
      allowedModels: string[]
      /**
       * ä¸»è¦æ¨¡å‹ï¼ˆé»˜è®¤ä½¿ç”¨çš„æ¨¡å‹ï¼‰
       */
      primaryModel: string | null
      createdAt: Date
    }, ExtArgs["result"]["botProviderKey"]>
    composites: {}
  }

  type BotProviderKeyGetPayload<S extends boolean | null | undefined | BotProviderKeyDefaultArgs> = $Result.GetResult<Prisma.$BotProviderKeyPayload, S>

  type BotProviderKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotProviderKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotProviderKeyCountAggregateInputType | true
    }

  export interface BotProviderKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotProviderKey'], meta: { name: 'BotProviderKey' } }
    /**
     * Find zero or one BotProviderKey that matches the filter.
     * @param {BotProviderKeyFindUniqueArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotProviderKeyFindUniqueArgs>(args: SelectSubset<T, BotProviderKeyFindUniqueArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotProviderKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotProviderKeyFindUniqueOrThrowArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotProviderKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, BotProviderKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotProviderKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindFirstArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotProviderKeyFindFirstArgs>(args?: SelectSubset<T, BotProviderKeyFindFirstArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotProviderKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindFirstOrThrowArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotProviderKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, BotProviderKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotProviderKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotProviderKeys
     * const botProviderKeys = await prisma.botProviderKey.findMany()
     * 
     * // Get first 10 BotProviderKeys
     * const botProviderKeys = await prisma.botProviderKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotProviderKeyFindManyArgs>(args?: SelectSubset<T, BotProviderKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotProviderKey.
     * @param {BotProviderKeyCreateArgs} args - Arguments to create a BotProviderKey.
     * @example
     * // Create one BotProviderKey
     * const BotProviderKey = await prisma.botProviderKey.create({
     *   data: {
     *     // ... data to create a BotProviderKey
     *   }
     * })
     * 
     */
    create<T extends BotProviderKeyCreateArgs>(args: SelectSubset<T, BotProviderKeyCreateArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotProviderKeys.
     * @param {BotProviderKeyCreateManyArgs} args - Arguments to create many BotProviderKeys.
     * @example
     * // Create many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotProviderKeyCreateManyArgs>(args?: SelectSubset<T, BotProviderKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotProviderKeys and returns the data saved in the database.
     * @param {BotProviderKeyCreateManyAndReturnArgs} args - Arguments to create many BotProviderKeys.
     * @example
     * // Create many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotProviderKeys and only return the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotProviderKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, BotProviderKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotProviderKey.
     * @param {BotProviderKeyDeleteArgs} args - Arguments to delete one BotProviderKey.
     * @example
     * // Delete one BotProviderKey
     * const BotProviderKey = await prisma.botProviderKey.delete({
     *   where: {
     *     // ... filter to delete one BotProviderKey
     *   }
     * })
     * 
     */
    delete<T extends BotProviderKeyDeleteArgs>(args: SelectSubset<T, BotProviderKeyDeleteArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotProviderKey.
     * @param {BotProviderKeyUpdateArgs} args - Arguments to update one BotProviderKey.
     * @example
     * // Update one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotProviderKeyUpdateArgs>(args: SelectSubset<T, BotProviderKeyUpdateArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotProviderKeys.
     * @param {BotProviderKeyDeleteManyArgs} args - Arguments to filter BotProviderKeys to delete.
     * @example
     * // Delete a few BotProviderKeys
     * const { count } = await prisma.botProviderKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotProviderKeyDeleteManyArgs>(args?: SelectSubset<T, BotProviderKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotProviderKeyUpdateManyArgs>(args: SelectSubset<T, BotProviderKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotProviderKeys and returns the data updated in the database.
     * @param {BotProviderKeyUpdateManyAndReturnArgs} args - Arguments to update many BotProviderKeys.
     * @example
     * // Update many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotProviderKeys and only return the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotProviderKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, BotProviderKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotProviderKey.
     * @param {BotProviderKeyUpsertArgs} args - Arguments to update or create a BotProviderKey.
     * @example
     * // Update or create a BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.upsert({
     *   create: {
     *     // ... data to create a BotProviderKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotProviderKey we want to update
     *   }
     * })
     */
    upsert<T extends BotProviderKeyUpsertArgs>(args: SelectSubset<T, BotProviderKeyUpsertArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyCountArgs} args - Arguments to filter BotProviderKeys to count.
     * @example
     * // Count the number of BotProviderKeys
     * const count = await prisma.botProviderKey.count({
     *   where: {
     *     // ... the filter for the BotProviderKeys we want to count
     *   }
     * })
    **/
    count<T extends BotProviderKeyCountArgs>(
      args?: Subset<T, BotProviderKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotProviderKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotProviderKeyAggregateArgs>(args: Subset<T, BotProviderKeyAggregateArgs>): Prisma.PrismaPromise<GetBotProviderKeyAggregateType<T>>

    /**
     * Group by BotProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotProviderKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotProviderKeyGroupByArgs['orderBy'] }
        : { orderBy?: BotProviderKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotProviderKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotProviderKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotProviderKey model
   */
  readonly fields: BotProviderKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotProviderKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotProviderKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends ProviderKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKeyDefaultArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotProviderKey model
   */
  interface BotProviderKeyFieldRefs {
    readonly id: FieldRef<"BotProviderKey", 'String'>
    readonly botId: FieldRef<"BotProviderKey", 'String'>
    readonly providerKeyId: FieldRef<"BotProviderKey", 'String'>
    readonly isPrimary: FieldRef<"BotProviderKey", 'Boolean'>
    readonly allowedModels: FieldRef<"BotProviderKey", 'String[]'>
    readonly primaryModel: FieldRef<"BotProviderKey", 'String'>
    readonly createdAt: FieldRef<"BotProviderKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotProviderKey findUnique
   */
  export type BotProviderKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey findUniqueOrThrow
   */
  export type BotProviderKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey findFirst
   */
  export type BotProviderKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotProviderKeys.
     */
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey findFirstOrThrow
   */
  export type BotProviderKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotProviderKeys.
     */
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey findMany
   */
  export type BotProviderKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKeys to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey create
   */
  export type BotProviderKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a BotProviderKey.
     */
    data: XOR<BotProviderKeyCreateInput, BotProviderKeyUncheckedCreateInput>
  }

  /**
   * BotProviderKey createMany
   */
  export type BotProviderKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotProviderKeys.
     */
    data: BotProviderKeyCreateManyInput | BotProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotProviderKey createManyAndReturn
   */
  export type BotProviderKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to create many BotProviderKeys.
     */
    data: BotProviderKeyCreateManyInput | BotProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotProviderKey update
   */
  export type BotProviderKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a BotProviderKey.
     */
    data: XOR<BotProviderKeyUpdateInput, BotProviderKeyUncheckedUpdateInput>
    /**
     * Choose, which BotProviderKey to update.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey updateMany
   */
  export type BotProviderKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotProviderKeys.
     */
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which BotProviderKeys to update
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to update.
     */
    limit?: number
  }

  /**
   * BotProviderKey updateManyAndReturn
   */
  export type BotProviderKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to update BotProviderKeys.
     */
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which BotProviderKeys to update
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotProviderKey upsert
   */
  export type BotProviderKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the BotProviderKey to update in case it exists.
     */
    where: BotProviderKeyWhereUniqueInput
    /**
     * In case the BotProviderKey found by the `where` argument doesn't exist, create a new BotProviderKey with this data.
     */
    create: XOR<BotProviderKeyCreateInput, BotProviderKeyUncheckedCreateInput>
    /**
     * In case the BotProviderKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotProviderKeyUpdateInput, BotProviderKeyUncheckedUpdateInput>
  }

  /**
   * BotProviderKey delete
   */
  export type BotProviderKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter which BotProviderKey to delete.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey deleteMany
   */
  export type BotProviderKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotProviderKeys to delete
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to delete.
     */
    limit?: number
  }

  /**
   * BotProviderKey without action
   */
  export type BotProviderKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
  }


  /**
   * Model BotUsageLog
   */

  export type AggregateBotUsageLog = {
    _count: BotUsageLogCountAggregateOutputType | null
    _avg: BotUsageLogAvgAggregateOutputType | null
    _sum: BotUsageLogSumAggregateOutputType | null
    _min: BotUsageLogMinAggregateOutputType | null
    _max: BotUsageLogMaxAggregateOutputType | null
  }

  export type BotUsageLogAvgAggregateOutputType = {
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    durationMs: number | null
    thinkingTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    thinkingCost: Decimal | null
    cacheCost: Decimal | null
    totalCost: Decimal | null
    fallbackLevel: number | null
  }

  export type BotUsageLogSumAggregateOutputType = {
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    durationMs: number | null
    thinkingTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    thinkingCost: Decimal | null
    cacheCost: Decimal | null
    totalCost: Decimal | null
    fallbackLevel: number | null
  }

  export type BotUsageLogMinAggregateOutputType = {
    id: string | null
    botId: string | null
    vendor: string | null
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date | null
    model: string | null
    endpoint: string | null
    durationMs: number | null
    errorMessage: string | null
    thinkingTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    protocolType: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    thinkingCost: Decimal | null
    cacheCost: Decimal | null
    totalCost: Decimal | null
    fallbackUsed: boolean | null
    fallbackLevel: number | null
    originalModel: string | null
  }

  export type BotUsageLogMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    vendor: string | null
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date | null
    model: string | null
    endpoint: string | null
    durationMs: number | null
    errorMessage: string | null
    thinkingTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    protocolType: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    thinkingCost: Decimal | null
    cacheCost: Decimal | null
    totalCost: Decimal | null
    fallbackUsed: boolean | null
    fallbackLevel: number | null
    originalModel: string | null
  }

  export type BotUsageLogCountAggregateOutputType = {
    id: number
    botId: number
    vendor: number
    providerKeyId: number
    statusCode: number
    requestTokens: number
    responseTokens: number
    createdAt: number
    model: number
    endpoint: number
    durationMs: number
    errorMessage: number
    thinkingTokens: number
    cacheReadTokens: number
    cacheWriteTokens: number
    protocolType: number
    inputCost: number
    outputCost: number
    thinkingCost: number
    cacheCost: number
    totalCost: number
    fallbackUsed: number
    fallbackLevel: number
    originalModel: number
    _all: number
  }


  export type BotUsageLogAvgAggregateInputType = {
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    durationMs?: true
    thinkingTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    inputCost?: true
    outputCost?: true
    thinkingCost?: true
    cacheCost?: true
    totalCost?: true
    fallbackLevel?: true
  }

  export type BotUsageLogSumAggregateInputType = {
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    durationMs?: true
    thinkingTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    inputCost?: true
    outputCost?: true
    thinkingCost?: true
    cacheCost?: true
    totalCost?: true
    fallbackLevel?: true
  }

  export type BotUsageLogMinAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
    model?: true
    endpoint?: true
    durationMs?: true
    errorMessage?: true
    thinkingTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    protocolType?: true
    inputCost?: true
    outputCost?: true
    thinkingCost?: true
    cacheCost?: true
    totalCost?: true
    fallbackUsed?: true
    fallbackLevel?: true
    originalModel?: true
  }

  export type BotUsageLogMaxAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
    model?: true
    endpoint?: true
    durationMs?: true
    errorMessage?: true
    thinkingTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    protocolType?: true
    inputCost?: true
    outputCost?: true
    thinkingCost?: true
    cacheCost?: true
    totalCost?: true
    fallbackUsed?: true
    fallbackLevel?: true
    originalModel?: true
  }

  export type BotUsageLogCountAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
    model?: true
    endpoint?: true
    durationMs?: true
    errorMessage?: true
    thinkingTokens?: true
    cacheReadTokens?: true
    cacheWriteTokens?: true
    protocolType?: true
    inputCost?: true
    outputCost?: true
    thinkingCost?: true
    cacheCost?: true
    totalCost?: true
    fallbackUsed?: true
    fallbackLevel?: true
    originalModel?: true
    _all?: true
  }

  export type BotUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUsageLog to aggregate.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotUsageLogs
    **/
    _count?: true | BotUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotUsageLogMaxAggregateInputType
  }

  export type GetBotUsageLogAggregateType<T extends BotUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBotUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotUsageLog[P]>
      : GetScalarType<T[P], AggregateBotUsageLog[P]>
  }




  export type BotUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithAggregationInput | BotUsageLogOrderByWithAggregationInput[]
    by: BotUsageLogScalarFieldEnum[] | BotUsageLogScalarFieldEnum
    having?: BotUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotUsageLogCountAggregateInputType | true
    _avg?: BotUsageLogAvgAggregateInputType
    _sum?: BotUsageLogSumAggregateInputType
    _min?: BotUsageLogMinAggregateInputType
    _max?: BotUsageLogMaxAggregateInputType
  }

  export type BotUsageLogGroupByOutputType = {
    id: string
    botId: string
    vendor: string
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date
    model: string | null
    endpoint: string | null
    durationMs: number | null
    errorMessage: string | null
    thinkingTokens: number | null
    cacheReadTokens: number | null
    cacheWriteTokens: number | null
    protocolType: string | null
    inputCost: Decimal | null
    outputCost: Decimal | null
    thinkingCost: Decimal | null
    cacheCost: Decimal | null
    totalCost: Decimal | null
    fallbackUsed: boolean | null
    fallbackLevel: number | null
    originalModel: string | null
    _count: BotUsageLogCountAggregateOutputType | null
    _avg: BotUsageLogAvgAggregateOutputType | null
    _sum: BotUsageLogSumAggregateOutputType | null
    _min: BotUsageLogMinAggregateOutputType | null
    _max: BotUsageLogMaxAggregateOutputType | null
  }

  type GetBotUsageLogGroupByPayload<T extends BotUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], BotUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type BotUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    model?: boolean
    endpoint?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    thinkingTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    protocolType?: boolean
    inputCost?: boolean
    outputCost?: boolean
    thinkingCost?: boolean
    cacheCost?: boolean
    totalCost?: boolean
    fallbackUsed?: boolean
    fallbackLevel?: boolean
    originalModel?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    model?: boolean
    endpoint?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    thinkingTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    protocolType?: boolean
    inputCost?: boolean
    outputCost?: boolean
    thinkingCost?: boolean
    cacheCost?: boolean
    totalCost?: boolean
    fallbackUsed?: boolean
    fallbackLevel?: boolean
    originalModel?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    model?: boolean
    endpoint?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    thinkingTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    protocolType?: boolean
    inputCost?: boolean
    outputCost?: boolean
    thinkingCost?: boolean
    cacheCost?: boolean
    totalCost?: boolean
    fallbackUsed?: boolean
    fallbackLevel?: boolean
    originalModel?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectScalar = {
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    model?: boolean
    endpoint?: boolean
    durationMs?: boolean
    errorMessage?: boolean
    thinkingTokens?: boolean
    cacheReadTokens?: boolean
    cacheWriteTokens?: boolean
    protocolType?: boolean
    inputCost?: boolean
    outputCost?: boolean
    thinkingCost?: boolean
    cacheCost?: boolean
    totalCost?: boolean
    fallbackUsed?: boolean
    fallbackLevel?: boolean
    originalModel?: boolean
  }

  export type BotUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "vendor" | "providerKeyId" | "statusCode" | "requestTokens" | "responseTokens" | "createdAt" | "model" | "endpoint" | "durationMs" | "errorMessage" | "thinkingTokens" | "cacheReadTokens" | "cacheWriteTokens" | "protocolType" | "inputCost" | "outputCost" | "thinkingCost" | "cacheCost" | "totalCost" | "fallbackUsed" | "fallbackLevel" | "originalModel", ExtArgs["result"]["botUsageLog"]>
  export type BotUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }
  export type BotUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }
  export type BotUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }

  export type $BotUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotUsageLog"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      vendor: string
      providerKeyId: string | null
      statusCode: number | null
      requestTokens: number | null
      responseTokens: number | null
      createdAt: Date
      model: string | null
      endpoint: string | null
      durationMs: number | null
      errorMessage: string | null
      /**
       * Extended Thinking tokens
       */
      thinkingTokens: number | null
      /**
       * Cache Control è¯»å– tokens
       */
      cacheReadTokens: number | null
      /**
       * Cache Control å†™å…¥ tokens
       */
      cacheWriteTokens: number | null
      /**
       * åè®®ç±»å‹ï¼šopenai-compatible | anthropic-native | gemini-native
       */
      protocolType: string | null
      /**
       * è¾“å…¥æˆæœ¬
       */
      inputCost: Prisma.Decimal | null
      /**
       * è¾“å‡ºæˆæœ¬
       */
      outputCost: Prisma.Decimal | null
      /**
       * æ€è€ƒæˆæœ¬
       */
      thinkingCost: Prisma.Decimal | null
      /**
       * ç¼“å­˜æˆæœ¬
       */
      cacheCost: Prisma.Decimal | null
      /**
       * æ€»æˆæœ¬
       */
      totalCost: Prisma.Decimal | null
      /**
       * æ˜¯å¦ä½¿ç”¨äº† Fallback
       */
      fallbackUsed: boolean | null
      /**
       * Fallback çº§åˆ«ï¼ˆ0=ä¸»æ¨¡å‹ï¼Œ1=ç¬¬ä¸€å¤‡ç”¨ï¼Œä»¥æ­¤ç±»æ¨ï¼‰
       */
      fallbackLevel: number | null
      /**
       * åŸå§‹è¯·æ±‚æ¨¡å‹
       */
      originalModel: string | null
    }, ExtArgs["result"]["botUsageLog"]>
    composites: {}
  }

  type BotUsageLogGetPayload<S extends boolean | null | undefined | BotUsageLogDefaultArgs> = $Result.GetResult<Prisma.$BotUsageLogPayload, S>

  type BotUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotUsageLogCountAggregateInputType | true
    }

  export interface BotUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotUsageLog'], meta: { name: 'BotUsageLog' } }
    /**
     * Find zero or one BotUsageLog that matches the filter.
     * @param {BotUsageLogFindUniqueArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotUsageLogFindUniqueArgs>(args: SelectSubset<T, BotUsageLogFindUniqueArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotUsageLogFindUniqueOrThrowArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BotUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindFirstArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotUsageLogFindFirstArgs>(args?: SelectSubset<T, BotUsageLogFindFirstArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindFirstOrThrowArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BotUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotUsageLogs
     * const botUsageLogs = await prisma.botUsageLog.findMany()
     * 
     * // Get first 10 BotUsageLogs
     * const botUsageLogs = await prisma.botUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotUsageLogFindManyArgs>(args?: SelectSubset<T, BotUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotUsageLog.
     * @param {BotUsageLogCreateArgs} args - Arguments to create a BotUsageLog.
     * @example
     * // Create one BotUsageLog
     * const BotUsageLog = await prisma.botUsageLog.create({
     *   data: {
     *     // ... data to create a BotUsageLog
     *   }
     * })
     * 
     */
    create<T extends BotUsageLogCreateArgs>(args: SelectSubset<T, BotUsageLogCreateArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotUsageLogs.
     * @param {BotUsageLogCreateManyArgs} args - Arguments to create many BotUsageLogs.
     * @example
     * // Create many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotUsageLogCreateManyArgs>(args?: SelectSubset<T, BotUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotUsageLogs and returns the data saved in the database.
     * @param {BotUsageLogCreateManyAndReturnArgs} args - Arguments to create many BotUsageLogs.
     * @example
     * // Create many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotUsageLogs and only return the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BotUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotUsageLog.
     * @param {BotUsageLogDeleteArgs} args - Arguments to delete one BotUsageLog.
     * @example
     * // Delete one BotUsageLog
     * const BotUsageLog = await prisma.botUsageLog.delete({
     *   where: {
     *     // ... filter to delete one BotUsageLog
     *   }
     * })
     * 
     */
    delete<T extends BotUsageLogDeleteArgs>(args: SelectSubset<T, BotUsageLogDeleteArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotUsageLog.
     * @param {BotUsageLogUpdateArgs} args - Arguments to update one BotUsageLog.
     * @example
     * // Update one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotUsageLogUpdateArgs>(args: SelectSubset<T, BotUsageLogUpdateArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotUsageLogs.
     * @param {BotUsageLogDeleteManyArgs} args - Arguments to filter BotUsageLogs to delete.
     * @example
     * // Delete a few BotUsageLogs
     * const { count } = await prisma.botUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotUsageLogDeleteManyArgs>(args?: SelectSubset<T, BotUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotUsageLogUpdateManyArgs>(args: SelectSubset<T, BotUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotUsageLogs and returns the data updated in the database.
     * @param {BotUsageLogUpdateManyAndReturnArgs} args - Arguments to update many BotUsageLogs.
     * @example
     * // Update many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotUsageLogs and only return the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, BotUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotUsageLog.
     * @param {BotUsageLogUpsertArgs} args - Arguments to update or create a BotUsageLog.
     * @example
     * // Update or create a BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.upsert({
     *   create: {
     *     // ... data to create a BotUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends BotUsageLogUpsertArgs>(args: SelectSubset<T, BotUsageLogUpsertArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogCountArgs} args - Arguments to filter BotUsageLogs to count.
     * @example
     * // Count the number of BotUsageLogs
     * const count = await prisma.botUsageLog.count({
     *   where: {
     *     // ... the filter for the BotUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends BotUsageLogCountArgs>(
      args?: Subset<T, BotUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotUsageLogAggregateArgs>(args: Subset<T, BotUsageLogAggregateArgs>): Prisma.PrismaPromise<GetBotUsageLogAggregateType<T>>

    /**
     * Group by BotUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: BotUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotUsageLog model
   */
  readonly fields: BotUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends BotUsageLog$providerKeyArgs<ExtArgs> = {}>(args?: Subset<T, BotUsageLog$providerKeyArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotUsageLog model
   */
  interface BotUsageLogFieldRefs {
    readonly id: FieldRef<"BotUsageLog", 'String'>
    readonly botId: FieldRef<"BotUsageLog", 'String'>
    readonly vendor: FieldRef<"BotUsageLog", 'String'>
    readonly providerKeyId: FieldRef<"BotUsageLog", 'String'>
    readonly statusCode: FieldRef<"BotUsageLog", 'Int'>
    readonly requestTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly responseTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly createdAt: FieldRef<"BotUsageLog", 'DateTime'>
    readonly model: FieldRef<"BotUsageLog", 'String'>
    readonly endpoint: FieldRef<"BotUsageLog", 'String'>
    readonly durationMs: FieldRef<"BotUsageLog", 'Int'>
    readonly errorMessage: FieldRef<"BotUsageLog", 'String'>
    readonly thinkingTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly cacheReadTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly cacheWriteTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly protocolType: FieldRef<"BotUsageLog", 'String'>
    readonly inputCost: FieldRef<"BotUsageLog", 'Decimal'>
    readonly outputCost: FieldRef<"BotUsageLog", 'Decimal'>
    readonly thinkingCost: FieldRef<"BotUsageLog", 'Decimal'>
    readonly cacheCost: FieldRef<"BotUsageLog", 'Decimal'>
    readonly totalCost: FieldRef<"BotUsageLog", 'Decimal'>
    readonly fallbackUsed: FieldRef<"BotUsageLog", 'Boolean'>
    readonly fallbackLevel: FieldRef<"BotUsageLog", 'Int'>
    readonly originalModel: FieldRef<"BotUsageLog", 'String'>
  }
    

  // Custom InputTypes
  /**
   * BotUsageLog findUnique
   */
  export type BotUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog findUniqueOrThrow
   */
  export type BotUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog findFirst
   */
  export type BotUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsageLogs.
     */
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog findFirstOrThrow
   */
  export type BotUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsageLogs.
     */
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog findMany
   */
  export type BotUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLogs to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog create
   */
  export type BotUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BotUsageLog.
     */
    data: XOR<BotUsageLogCreateInput, BotUsageLogUncheckedCreateInput>
  }

  /**
   * BotUsageLog createMany
   */
  export type BotUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotUsageLogs.
     */
    data: BotUsageLogCreateManyInput | BotUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotUsageLog createManyAndReturn
   */
  export type BotUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many BotUsageLogs.
     */
    data: BotUsageLogCreateManyInput | BotUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotUsageLog update
   */
  export type BotUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BotUsageLog.
     */
    data: XOR<BotUsageLogUpdateInput, BotUsageLogUncheckedUpdateInput>
    /**
     * Choose, which BotUsageLog to update.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog updateMany
   */
  export type BotUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotUsageLogs.
     */
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which BotUsageLogs to update
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to update.
     */
    limit?: number
  }

  /**
   * BotUsageLog updateManyAndReturn
   */
  export type BotUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update BotUsageLogs.
     */
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which BotUsageLogs to update
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotUsageLog upsert
   */
  export type BotUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BotUsageLog to update in case it exists.
     */
    where: BotUsageLogWhereUniqueInput
    /**
     * In case the BotUsageLog found by the `where` argument doesn't exist, create a new BotUsageLog with this data.
     */
    create: XOR<BotUsageLogCreateInput, BotUsageLogUncheckedCreateInput>
    /**
     * In case the BotUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUsageLogUpdateInput, BotUsageLogUncheckedUpdateInput>
  }

  /**
   * BotUsageLog delete
   */
  export type BotUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter which BotUsageLog to delete.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog deleteMany
   */
  export type BotUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUsageLogs to delete
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * BotUsageLog.providerKey
   */
  export type BotUsageLog$providerKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    where?: ProviderKeyWhereInput
  }

  /**
   * BotUsageLog without action
   */
  export type BotUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ProxyToken
   */

  export type AggregateProxyToken = {
    _count: ProxyTokenCountAggregateOutputType | null
    _avg: ProxyTokenAvgAggregateOutputType | null
    _sum: ProxyTokenSumAggregateOutputType | null
    _min: ProxyTokenMinAggregateOutputType | null
    _max: ProxyTokenMaxAggregateOutputType | null
  }

  export type ProxyTokenAvgAggregateOutputType = {
    requestCount: number | null
  }

  export type ProxyTokenSumAggregateOutputType = {
    requestCount: number | null
  }

  export type ProxyTokenMinAggregateOutputType = {
    id: string | null
    botId: string | null
    tokenHash: string | null
    vendor: string | null
    keyId: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyTokenMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    tokenHash: string | null
    vendor: string | null
    keyId: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyTokenCountAggregateOutputType = {
    id: number
    botId: number
    tokenHash: number
    vendor: number
    keyId: number
    tags: number
    expiresAt: number
    revokedAt: number
    lastUsedAt: number
    requestCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProxyTokenAvgAggregateInputType = {
    requestCount?: true
  }

  export type ProxyTokenSumAggregateInputType = {
    requestCount?: true
  }

  export type ProxyTokenMinAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyTokenMaxAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyTokenCountAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    tags?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProxyTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyToken to aggregate.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyTokens
    **/
    _count?: true | ProxyTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxyTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxyTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyTokenMaxAggregateInputType
  }

  export type GetProxyTokenAggregateType<T extends ProxyTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyToken[P]>
      : GetScalarType<T[P], AggregateProxyToken[P]>
  }




  export type ProxyTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyTokenWhereInput
    orderBy?: ProxyTokenOrderByWithAggregationInput | ProxyTokenOrderByWithAggregationInput[]
    by: ProxyTokenScalarFieldEnum[] | ProxyTokenScalarFieldEnum
    having?: ProxyTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyTokenCountAggregateInputType | true
    _avg?: ProxyTokenAvgAggregateInputType
    _sum?: ProxyTokenSumAggregateInputType
    _min?: ProxyTokenMinAggregateInputType
    _max?: ProxyTokenMaxAggregateInputType
  }

  export type ProxyTokenGroupByOutputType = {
    id: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags: string[]
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProxyTokenCountAggregateOutputType | null
    _avg: ProxyTokenAvgAggregateOutputType | null
    _sum: ProxyTokenSumAggregateOutputType | null
    _min: ProxyTokenMinAggregateOutputType | null
    _max: ProxyTokenMaxAggregateOutputType | null
  }

  type GetProxyTokenGroupByPayload<T extends ProxyTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyTokenGroupByOutputType[P]>
        }
      >
    >


  export type ProxyTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectScalar = {
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProxyTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "tokenHash" | "vendor" | "keyId" | "tags" | "expiresAt" | "revokedAt" | "lastUsedAt" | "requestCount" | "createdAt" | "updatedAt", ExtArgs["result"]["proxyToken"]>
  export type ProxyTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type ProxyTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type ProxyTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }

  export type $ProxyTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxyToken"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * å…³è”çš„ Bot IDï¼ˆä¸€å¯¹ä¸€å…³ç³»ï¼‰
       */
      botId: string
      /**
       * Token çš„ SHA-256 å“ˆå¸Œå€¼ï¼ˆæ°¸ä¸å­˜å‚¨åŸå§‹ Tokenï¼‰
       */
      tokenHash: string
      /**
       * AI æœåŠ¡å•†æ ‡è¯†ï¼ˆopenai, anthropic, google ç­‰ï¼‰
       */
      vendor: string
      /**
       * å…³è”çš„ ProviderKey ID
       */
      keyId: string
      /**
       * è®¿é—®æ§åˆ¶æ ‡ç­¾
       */
      tags: string[]
      /**
       * Token è¿‡æœŸæ—¶é—´ï¼ˆå¯é€‰ï¼‰
       */
      expiresAt: Date | null
      /**
       * Token æ’¤é”€æ—¶é—´ï¼ˆnull è¡¨ç¤ºæœ‰æ•ˆï¼‰
       */
      revokedAt: Date | null
      /**
       * æœ€åä½¿ç”¨æ—¶é—´
       */
      lastUsedAt: Date | null
      /**
       * è¯·æ±‚è®¡æ•°
       */
      requestCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxyToken"]>
    composites: {}
  }

  type ProxyTokenGetPayload<S extends boolean | null | undefined | ProxyTokenDefaultArgs> = $Result.GetResult<Prisma.$ProxyTokenPayload, S>

  type ProxyTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyTokenCountAggregateInputType | true
    }

  export interface ProxyTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxyToken'], meta: { name: 'ProxyToken' } }
    /**
     * Find zero or one ProxyToken that matches the filter.
     * @param {ProxyTokenFindUniqueArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyTokenFindUniqueArgs>(args: SelectSubset<T, ProxyTokenFindUniqueArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxyToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyTokenFindUniqueOrThrowArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindFirstArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyTokenFindFirstArgs>(args?: SelectSubset<T, ProxyTokenFindFirstArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindFirstOrThrowArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxyTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyTokens
     * const proxyTokens = await prisma.proxyToken.findMany()
     * 
     * // Get first 10 ProxyTokens
     * const proxyTokens = await prisma.proxyToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyTokenFindManyArgs>(args?: SelectSubset<T, ProxyTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxyToken.
     * @param {ProxyTokenCreateArgs} args - Arguments to create a ProxyToken.
     * @example
     * // Create one ProxyToken
     * const ProxyToken = await prisma.proxyToken.create({
     *   data: {
     *     // ... data to create a ProxyToken
     *   }
     * })
     * 
     */
    create<T extends ProxyTokenCreateArgs>(args: SelectSubset<T, ProxyTokenCreateArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxyTokens.
     * @param {ProxyTokenCreateManyArgs} args - Arguments to create many ProxyTokens.
     * @example
     * // Create many ProxyTokens
     * const proxyToken = await prisma.proxyToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyTokenCreateManyArgs>(args?: SelectSubset<T, ProxyTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxyTokens and returns the data saved in the database.
     * @param {ProxyTokenCreateManyAndReturnArgs} args - Arguments to create many ProxyTokens.
     * @example
     * // Create many ProxyTokens
     * const proxyToken = await prisma.proxyToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxyTokens and only return the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxyToken.
     * @param {ProxyTokenDeleteArgs} args - Arguments to delete one ProxyToken.
     * @example
     * // Delete one ProxyToken
     * const ProxyToken = await prisma.proxyToken.delete({
     *   where: {
     *     // ... filter to delete one ProxyToken
     *   }
     * })
     * 
     */
    delete<T extends ProxyTokenDeleteArgs>(args: SelectSubset<T, ProxyTokenDeleteArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxyToken.
     * @param {ProxyTokenUpdateArgs} args - Arguments to update one ProxyToken.
     * @example
     * // Update one ProxyToken
     * const proxyToken = await prisma.proxyToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyTokenUpdateArgs>(args: SelectSubset<T, ProxyTokenUpdateArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxyTokens.
     * @param {ProxyTokenDeleteManyArgs} args - Arguments to filter ProxyTokens to delete.
     * @example
     * // Delete a few ProxyTokens
     * const { count } = await prisma.proxyToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyTokenDeleteManyArgs>(args?: SelectSubset<T, ProxyTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyTokens
     * const proxyToken = await prisma.proxyToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyTokenUpdateManyArgs>(args: SelectSubset<T, ProxyTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyTokens and returns the data updated in the database.
     * @param {ProxyTokenUpdateManyAndReturnArgs} args - Arguments to update many ProxyTokens.
     * @example
     * // Update many ProxyTokens
     * const proxyToken = await prisma.proxyToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxyTokens and only return the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxyToken.
     * @param {ProxyTokenUpsertArgs} args - Arguments to update or create a ProxyToken.
     * @example
     * // Update or create a ProxyToken
     * const proxyToken = await prisma.proxyToken.upsert({
     *   create: {
     *     // ... data to create a ProxyToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyToken we want to update
     *   }
     * })
     */
    upsert<T extends ProxyTokenUpsertArgs>(args: SelectSubset<T, ProxyTokenUpsertArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenCountArgs} args - Arguments to filter ProxyTokens to count.
     * @example
     * // Count the number of ProxyTokens
     * const count = await prisma.proxyToken.count({
     *   where: {
     *     // ... the filter for the ProxyTokens we want to count
     *   }
     * })
    **/
    count<T extends ProxyTokenCountArgs>(
      args?: Subset<T, ProxyTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyTokenAggregateArgs>(args: Subset<T, ProxyTokenAggregateArgs>): Prisma.PrismaPromise<GetProxyTokenAggregateType<T>>

    /**
     * Group by ProxyToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyTokenGroupByArgs['orderBy'] }
        : { orderBy?: ProxyTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxyToken model
   */
  readonly fields: ProxyTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends ProviderKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKeyDefaultArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxyToken model
   */
  interface ProxyTokenFieldRefs {
    readonly id: FieldRef<"ProxyToken", 'String'>
    readonly botId: FieldRef<"ProxyToken", 'String'>
    readonly tokenHash: FieldRef<"ProxyToken", 'String'>
    readonly vendor: FieldRef<"ProxyToken", 'String'>
    readonly keyId: FieldRef<"ProxyToken", 'String'>
    readonly tags: FieldRef<"ProxyToken", 'String[]'>
    readonly expiresAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly revokedAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly requestCount: FieldRef<"ProxyToken", 'Int'>
    readonly createdAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly updatedAt: FieldRef<"ProxyToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxyToken findUnique
   */
  export type ProxyTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken findUniqueOrThrow
   */
  export type ProxyTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken findFirst
   */
  export type ProxyTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyTokens.
     */
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken findFirstOrThrow
   */
  export type ProxyTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyTokens.
     */
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken findMany
   */
  export type ProxyTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyTokens to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken create
   */
  export type ProxyTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxyToken.
     */
    data: XOR<ProxyTokenCreateInput, ProxyTokenUncheckedCreateInput>
  }

  /**
   * ProxyToken createMany
   */
  export type ProxyTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxyTokens.
     */
    data: ProxyTokenCreateManyInput | ProxyTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyToken createManyAndReturn
   */
  export type ProxyTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * The data used to create many ProxyTokens.
     */
    data: ProxyTokenCreateManyInput | ProxyTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyToken update
   */
  export type ProxyTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxyToken.
     */
    data: XOR<ProxyTokenUpdateInput, ProxyTokenUncheckedUpdateInput>
    /**
     * Choose, which ProxyToken to update.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken updateMany
   */
  export type ProxyTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxyTokens.
     */
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyInput>
    /**
     * Filter which ProxyTokens to update
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to update.
     */
    limit?: number
  }

  /**
   * ProxyToken updateManyAndReturn
   */
  export type ProxyTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * The data used to update ProxyTokens.
     */
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyInput>
    /**
     * Filter which ProxyTokens to update
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyToken upsert
   */
  export type ProxyTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxyToken to update in case it exists.
     */
    where: ProxyTokenWhereUniqueInput
    /**
     * In case the ProxyToken found by the `where` argument doesn't exist, create a new ProxyToken with this data.
     */
    create: XOR<ProxyTokenCreateInput, ProxyTokenUncheckedCreateInput>
    /**
     * In case the ProxyToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyTokenUpdateInput, ProxyTokenUncheckedUpdateInput>
  }

  /**
   * ProxyToken delete
   */
  export type ProxyTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter which ProxyToken to delete.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken deleteMany
   */
  export type ProxyTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyTokens to delete
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to delete.
     */
    limit?: number
  }

  /**
   * ProxyToken without action
   */
  export type ProxyTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    senderId: number
    metadata: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    senderId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    type: string
    title: string | null
    content: JsonValue
    senderId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "content" | "senderId" | "metadata" | "createdAt" | "updatedAt" | "isDeleted" | "deletedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserInfoPayload<ExtArgs> | null
      recipients: Prisma.$MessageRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string | null
      content: Prisma.JsonValue
      senderId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends Message$senderArgs<ExtArgs> = {}>(args?: Subset<T, Message$senderArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recipients<T extends Message$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Message$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly title: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'Json'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly isDeleted: FieldRef<"Message", 'Boolean'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.sender
   */
  export type Message$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
  }

  /**
   * Message.recipients
   */
  export type Message$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    cursor?: MessageRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageRecipient
   */

  export type AggregateMessageRecipient = {
    _count: MessageRecipientCountAggregateOutputType | null
    _min: MessageRecipientMinAggregateOutputType | null
    _max: MessageRecipientMaxAggregateOutputType | null
  }

  export type MessageRecipientMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageRecipientMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageRecipientCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type MessageRecipientMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageRecipientMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageRecipientCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRecipient to aggregate.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageRecipients
    **/
    _count?: true | MessageRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageRecipientMaxAggregateInputType
  }

  export type GetMessageRecipientAggregateType<T extends MessageRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRecipient[P]>
      : GetScalarType<T[P], AggregateMessageRecipient[P]>
  }




  export type MessageRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithAggregationInput | MessageRecipientOrderByWithAggregationInput[]
    by: MessageRecipientScalarFieldEnum[] | MessageRecipientScalarFieldEnum
    having?: MessageRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageRecipientCountAggregateInputType | true
    _min?: MessageRecipientMinAggregateInputType
    _max?: MessageRecipientMaxAggregateInputType
  }

  export type MessageRecipientGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedAt: Date | null
    _count: MessageRecipientCountAggregateOutputType | null
    _min: MessageRecipientMinAggregateOutputType | null
    _max: MessageRecipientMaxAggregateOutputType | null
  }

  type GetMessageRecipientGroupByPayload<T extends MessageRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], MessageRecipientGroupByOutputType[P]>
        }
      >
    >


  export type MessageRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type MessageRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "userId" | "isRead" | "readAt" | "createdAt" | "updatedAt" | "isDeleted" | "deletedAt", ExtArgs["result"]["messageRecipient"]>
  export type MessageRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MessageRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MessageRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $MessageRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRecipient"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["messageRecipient"]>
    composites: {}
  }

  type MessageRecipientGetPayload<S extends boolean | null | undefined | MessageRecipientDefaultArgs> = $Result.GetResult<Prisma.$MessageRecipientPayload, S>

  type MessageRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageRecipientCountAggregateInputType | true
    }

  export interface MessageRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRecipient'], meta: { name: 'MessageRecipient' } }
    /**
     * Find zero or one MessageRecipient that matches the filter.
     * @param {MessageRecipientFindUniqueArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageRecipientFindUniqueArgs>(args: SelectSubset<T, MessageRecipientFindUniqueArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageRecipientFindUniqueOrThrowArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindFirstArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageRecipientFindFirstArgs>(args?: SelectSubset<T, MessageRecipientFindFirstArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindFirstOrThrowArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageRecipients
     * const messageRecipients = await prisma.messageRecipient.findMany()
     * 
     * // Get first 10 MessageRecipients
     * const messageRecipients = await prisma.messageRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageRecipientFindManyArgs>(args?: SelectSubset<T, MessageRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageRecipient.
     * @param {MessageRecipientCreateArgs} args - Arguments to create a MessageRecipient.
     * @example
     * // Create one MessageRecipient
     * const MessageRecipient = await prisma.messageRecipient.create({
     *   data: {
     *     // ... data to create a MessageRecipient
     *   }
     * })
     * 
     */
    create<T extends MessageRecipientCreateArgs>(args: SelectSubset<T, MessageRecipientCreateArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageRecipients.
     * @param {MessageRecipientCreateManyArgs} args - Arguments to create many MessageRecipients.
     * @example
     * // Create many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageRecipientCreateManyArgs>(args?: SelectSubset<T, MessageRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageRecipients and returns the data saved in the database.
     * @param {MessageRecipientCreateManyAndReturnArgs} args - Arguments to create many MessageRecipients.
     * @example
     * // Create many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageRecipients and only return the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageRecipient.
     * @param {MessageRecipientDeleteArgs} args - Arguments to delete one MessageRecipient.
     * @example
     * // Delete one MessageRecipient
     * const MessageRecipient = await prisma.messageRecipient.delete({
     *   where: {
     *     // ... filter to delete one MessageRecipient
     *   }
     * })
     * 
     */
    delete<T extends MessageRecipientDeleteArgs>(args: SelectSubset<T, MessageRecipientDeleteArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageRecipient.
     * @param {MessageRecipientUpdateArgs} args - Arguments to update one MessageRecipient.
     * @example
     * // Update one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageRecipientUpdateArgs>(args: SelectSubset<T, MessageRecipientUpdateArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageRecipients.
     * @param {MessageRecipientDeleteManyArgs} args - Arguments to filter MessageRecipients to delete.
     * @example
     * // Delete a few MessageRecipients
     * const { count } = await prisma.messageRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageRecipientDeleteManyArgs>(args?: SelectSubset<T, MessageRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageRecipientUpdateManyArgs>(args: SelectSubset<T, MessageRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRecipients and returns the data updated in the database.
     * @param {MessageRecipientUpdateManyAndReturnArgs} args - Arguments to update many MessageRecipients.
     * @example
     * // Update many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageRecipients and only return the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageRecipient.
     * @param {MessageRecipientUpsertArgs} args - Arguments to update or create a MessageRecipient.
     * @example
     * // Update or create a MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.upsert({
     *   create: {
     *     // ... data to create a MessageRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRecipient we want to update
     *   }
     * })
     */
    upsert<T extends MessageRecipientUpsertArgs>(args: SelectSubset<T, MessageRecipientUpsertArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientCountArgs} args - Arguments to filter MessageRecipients to count.
     * @example
     * // Count the number of MessageRecipients
     * const count = await prisma.messageRecipient.count({
     *   where: {
     *     // ... the filter for the MessageRecipients we want to count
     *   }
     * })
    **/
    count<T extends MessageRecipientCountArgs>(
      args?: Subset<T, MessageRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageRecipientAggregateArgs>(args: Subset<T, MessageRecipientAggregateArgs>): Prisma.PrismaPromise<GetMessageRecipientAggregateType<T>>

    /**
     * Group by MessageRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageRecipientGroupByArgs['orderBy'] }
        : { orderBy?: MessageRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRecipient model
   */
  readonly fields: MessageRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRecipient model
   */
  interface MessageRecipientFieldRefs {
    readonly id: FieldRef<"MessageRecipient", 'String'>
    readonly messageId: FieldRef<"MessageRecipient", 'String'>
    readonly userId: FieldRef<"MessageRecipient", 'String'>
    readonly isRead: FieldRef<"MessageRecipient", 'Boolean'>
    readonly readAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly createdAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly isDeleted: FieldRef<"MessageRecipient", 'Boolean'>
    readonly deletedAt: FieldRef<"MessageRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRecipient findUnique
   */
  export type MessageRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient findUniqueOrThrow
   */
  export type MessageRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient findFirst
   */
  export type MessageRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRecipients.
     */
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient findFirstOrThrow
   */
  export type MessageRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRecipients.
     */
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient findMany
   */
  export type MessageRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipients to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient create
   */
  export type MessageRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRecipient.
     */
    data: XOR<MessageRecipientCreateInput, MessageRecipientUncheckedCreateInput>
  }

  /**
   * MessageRecipient createMany
   */
  export type MessageRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageRecipients.
     */
    data: MessageRecipientCreateManyInput | MessageRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRecipient createManyAndReturn
   */
  export type MessageRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many MessageRecipients.
     */
    data: MessageRecipientCreateManyInput | MessageRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRecipient update
   */
  export type MessageRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRecipient.
     */
    data: XOR<MessageRecipientUpdateInput, MessageRecipientUncheckedUpdateInput>
    /**
     * Choose, which MessageRecipient to update.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient updateMany
   */
  export type MessageRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageRecipients.
     */
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyInput>
    /**
     * Filter which MessageRecipients to update
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to update.
     */
    limit?: number
  }

  /**
   * MessageRecipient updateManyAndReturn
   */
  export type MessageRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * The data used to update MessageRecipients.
     */
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyInput>
    /**
     * Filter which MessageRecipients to update
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRecipient upsert
   */
  export type MessageRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRecipient to update in case it exists.
     */
    where: MessageRecipientWhereUniqueInput
    /**
     * In case the MessageRecipient found by the `where` argument doesn't exist, create a new MessageRecipient with this data.
     */
    create: XOR<MessageRecipientCreateInput, MessageRecipientUncheckedCreateInput>
    /**
     * In case the MessageRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageRecipientUpdateInput, MessageRecipientUncheckedUpdateInput>
  }

  /**
   * MessageRecipient delete
   */
  export type MessageRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter which MessageRecipient to delete.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient deleteMany
   */
  export type MessageRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRecipients to delete
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to delete.
     */
    limit?: number
  }

  /**
   * MessageRecipient without action
   */
  export type MessageRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
  }


  /**
   * Model OperateLog
   */

  export type AggregateOperateLog = {
    _count: OperateLogCountAggregateOutputType | null
    _min: OperateLogMinAggregateOutputType | null
    _max: OperateLogMaxAggregateOutputType | null
  }

  export type OperateLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    operateType: $Enums.OperateType | null
    target: $Enums.OperateTarget | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperateLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    operateType: $Enums.OperateType | null
    target: $Enums.OperateTarget | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperateLogCountAggregateOutputType = {
    id: number
    userId: number
    operateType: number
    target: number
    targetId: number
    targetName: number
    detail: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type OperateLogMinAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperateLogMaxAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperateLogCountAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    detail?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type OperateLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperateLog to aggregate.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperateLogs
    **/
    _count?: true | OperateLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperateLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperateLogMaxAggregateInputType
  }

  export type GetOperateLogAggregateType<T extends OperateLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOperateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperateLog[P]>
      : GetScalarType<T[P], AggregateOperateLog[P]>
  }




  export type OperateLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperateLogWhereInput
    orderBy?: OperateLogOrderByWithAggregationInput | OperateLogOrderByWithAggregationInput[]
    by: OperateLogScalarFieldEnum[] | OperateLogScalarFieldEnum
    having?: OperateLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperateLogCountAggregateInputType | true
    _min?: OperateLogMinAggregateInputType
    _max?: OperateLogMaxAggregateInputType
  }

  export type OperateLogGroupByOutputType = {
    id: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId: string | null
    targetName: string | null
    detail: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: OperateLogCountAggregateOutputType | null
    _min: OperateLogMinAggregateOutputType | null
    _max: OperateLogMaxAggregateOutputType | null
  }

  type GetOperateLogGroupByPayload<T extends OperateLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperateLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperateLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperateLogGroupByOutputType[P]>
            : GetScalarType<T[P], OperateLogGroupByOutputType[P]>
        }
      >
    >


  export type OperateLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectScalar = {
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type OperateLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "operateType" | "target" | "targetId" | "targetName" | "detail" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["operateLog"]>
  export type OperateLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type OperateLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type OperateLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $OperateLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperateLog"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      operateType: $Enums.OperateType
      target: $Enums.OperateTarget
      targetId: string | null
      targetName: string | null
      detail: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["operateLog"]>
    composites: {}
  }

  type OperateLogGetPayload<S extends boolean | null | undefined | OperateLogDefaultArgs> = $Result.GetResult<Prisma.$OperateLogPayload, S>

  type OperateLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperateLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperateLogCountAggregateInputType | true
    }

  export interface OperateLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperateLog'], meta: { name: 'OperateLog' } }
    /**
     * Find zero or one OperateLog that matches the filter.
     * @param {OperateLogFindUniqueArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperateLogFindUniqueArgs>(args: SelectSubset<T, OperateLogFindUniqueArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperateLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperateLogFindUniqueOrThrowArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperateLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OperateLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperateLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindFirstArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperateLogFindFirstArgs>(args?: SelectSubset<T, OperateLogFindFirstArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperateLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindFirstOrThrowArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperateLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OperateLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperateLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperateLogs
     * const operateLogs = await prisma.operateLog.findMany()
     * 
     * // Get first 10 OperateLogs
     * const operateLogs = await prisma.operateLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperateLogFindManyArgs>(args?: SelectSubset<T, OperateLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperateLog.
     * @param {OperateLogCreateArgs} args - Arguments to create a OperateLog.
     * @example
     * // Create one OperateLog
     * const OperateLog = await prisma.operateLog.create({
     *   data: {
     *     // ... data to create a OperateLog
     *   }
     * })
     * 
     */
    create<T extends OperateLogCreateArgs>(args: SelectSubset<T, OperateLogCreateArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperateLogs.
     * @param {OperateLogCreateManyArgs} args - Arguments to create many OperateLogs.
     * @example
     * // Create many OperateLogs
     * const operateLog = await prisma.operateLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperateLogCreateManyArgs>(args?: SelectSubset<T, OperateLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperateLogs and returns the data saved in the database.
     * @param {OperateLogCreateManyAndReturnArgs} args - Arguments to create many OperateLogs.
     * @example
     * // Create many OperateLogs
     * const operateLog = await prisma.operateLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperateLogs and only return the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperateLogCreateManyAndReturnArgs>(args?: SelectSubset<T, OperateLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperateLog.
     * @param {OperateLogDeleteArgs} args - Arguments to delete one OperateLog.
     * @example
     * // Delete one OperateLog
     * const OperateLog = await prisma.operateLog.delete({
     *   where: {
     *     // ... filter to delete one OperateLog
     *   }
     * })
     * 
     */
    delete<T extends OperateLogDeleteArgs>(args: SelectSubset<T, OperateLogDeleteArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperateLog.
     * @param {OperateLogUpdateArgs} args - Arguments to update one OperateLog.
     * @example
     * // Update one OperateLog
     * const operateLog = await prisma.operateLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperateLogUpdateArgs>(args: SelectSubset<T, OperateLogUpdateArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperateLogs.
     * @param {OperateLogDeleteManyArgs} args - Arguments to filter OperateLogs to delete.
     * @example
     * // Delete a few OperateLogs
     * const { count } = await prisma.operateLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperateLogDeleteManyArgs>(args?: SelectSubset<T, OperateLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperateLogs
     * const operateLog = await prisma.operateLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperateLogUpdateManyArgs>(args: SelectSubset<T, OperateLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperateLogs and returns the data updated in the database.
     * @param {OperateLogUpdateManyAndReturnArgs} args - Arguments to update many OperateLogs.
     * @example
     * // Update many OperateLogs
     * const operateLog = await prisma.operateLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperateLogs and only return the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperateLogUpdateManyAndReturnArgs>(args: SelectSubset<T, OperateLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperateLog.
     * @param {OperateLogUpsertArgs} args - Arguments to update or create a OperateLog.
     * @example
     * // Update or create a OperateLog
     * const operateLog = await prisma.operateLog.upsert({
     *   create: {
     *     // ... data to create a OperateLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperateLog we want to update
     *   }
     * })
     */
    upsert<T extends OperateLogUpsertArgs>(args: SelectSubset<T, OperateLogUpsertArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogCountArgs} args - Arguments to filter OperateLogs to count.
     * @example
     * // Count the number of OperateLogs
     * const count = await prisma.operateLog.count({
     *   where: {
     *     // ... the filter for the OperateLogs we want to count
     *   }
     * })
    **/
    count<T extends OperateLogCountArgs>(
      args?: Subset<T, OperateLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperateLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperateLogAggregateArgs>(args: Subset<T, OperateLogAggregateArgs>): Prisma.PrismaPromise<GetOperateLogAggregateType<T>>

    /**
     * Group by OperateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperateLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperateLogGroupByArgs['orderBy'] }
        : { orderBy?: OperateLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperateLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperateLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperateLog model
   */
  readonly fields: OperateLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperateLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperateLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperateLog model
   */
  interface OperateLogFieldRefs {
    readonly id: FieldRef<"OperateLog", 'String'>
    readonly userId: FieldRef<"OperateLog", 'String'>
    readonly operateType: FieldRef<"OperateLog", 'OperateType'>
    readonly target: FieldRef<"OperateLog", 'OperateTarget'>
    readonly targetId: FieldRef<"OperateLog", 'String'>
    readonly targetName: FieldRef<"OperateLog", 'String'>
    readonly detail: FieldRef<"OperateLog", 'Json'>
    readonly ipAddress: FieldRef<"OperateLog", 'String'>
    readonly userAgent: FieldRef<"OperateLog", 'String'>
    readonly createdAt: FieldRef<"OperateLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperateLog findUnique
   */
  export type OperateLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog findUniqueOrThrow
   */
  export type OperateLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog findFirst
   */
  export type OperateLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperateLogs.
     */
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog findFirstOrThrow
   */
  export type OperateLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperateLogs.
     */
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog findMany
   */
  export type OperateLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLogs to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog create
   */
  export type OperateLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OperateLog.
     */
    data: XOR<OperateLogCreateInput, OperateLogUncheckedCreateInput>
  }

  /**
   * OperateLog createMany
   */
  export type OperateLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperateLogs.
     */
    data: OperateLogCreateManyInput | OperateLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperateLog createManyAndReturn
   */
  export type OperateLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * The data used to create many OperateLogs.
     */
    data: OperateLogCreateManyInput | OperateLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperateLog update
   */
  export type OperateLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OperateLog.
     */
    data: XOR<OperateLogUpdateInput, OperateLogUncheckedUpdateInput>
    /**
     * Choose, which OperateLog to update.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog updateMany
   */
  export type OperateLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperateLogs.
     */
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyInput>
    /**
     * Filter which OperateLogs to update
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to update.
     */
    limit?: number
  }

  /**
   * OperateLog updateManyAndReturn
   */
  export type OperateLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * The data used to update OperateLogs.
     */
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyInput>
    /**
     * Filter which OperateLogs to update
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperateLog upsert
   */
  export type OperateLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OperateLog to update in case it exists.
     */
    where: OperateLogWhereUniqueInput
    /**
     * In case the OperateLog found by the `where` argument doesn't exist, create a new OperateLog with this data.
     */
    create: XOR<OperateLogCreateInput, OperateLogUncheckedCreateInput>
    /**
     * In case the OperateLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperateLogUpdateInput, OperateLogUncheckedUpdateInput>
  }

  /**
   * OperateLog delete
   */
  export type OperateLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter which OperateLog to delete.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog deleteMany
   */
  export type OperateLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperateLogs to delete
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to delete.
     */
    limit?: number
  }

  /**
   * OperateLog without action
   */
  export type OperateLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
  }


  /**
   * Model ChannelDefinition
   */

  export type AggregateChannelDefinition = {
    _count: ChannelDefinitionCountAggregateOutputType | null
    _avg: ChannelDefinitionAvgAggregateOutputType | null
    _sum: ChannelDefinitionSumAggregateOutputType | null
    _min: ChannelDefinitionMinAggregateOutputType | null
    _max: ChannelDefinitionMaxAggregateOutputType | null
  }

  export type ChannelDefinitionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelDefinitionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelDefinitionMinAggregateOutputType = {
    id: string | null
    label: string | null
    icon: string | null
    popular: boolean | null
    tokenHint: string | null
    tokenPlaceholder: string | null
    helpUrl: string | null
    helpText: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelDefinitionMaxAggregateOutputType = {
    id: string | null
    label: string | null
    icon: string | null
    popular: boolean | null
    tokenHint: string | null
    tokenPlaceholder: string | null
    helpUrl: string | null
    helpText: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelDefinitionCountAggregateOutputType = {
    id: number
    label: number
    icon: number
    popular: number
    popularLocales: number
    tokenHint: number
    tokenPlaceholder: number
    helpUrl: number
    helpText: number
    sortOrder: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChannelDefinitionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelDefinitionSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelDefinitionMinAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelDefinitionMaxAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelDefinitionCountAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    popularLocales?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChannelDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelDefinition to aggregate.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelDefinitions
    **/
    _count?: true | ChannelDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelDefinitionMaxAggregateInputType
  }

  export type GetChannelDefinitionAggregateType<T extends ChannelDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelDefinition[P]>
      : GetScalarType<T[P], AggregateChannelDefinition[P]>
  }




  export type ChannelDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelDefinitionWhereInput
    orderBy?: ChannelDefinitionOrderByWithAggregationInput | ChannelDefinitionOrderByWithAggregationInput[]
    by: ChannelDefinitionScalarFieldEnum[] | ChannelDefinitionScalarFieldEnum
    having?: ChannelDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelDefinitionCountAggregateInputType | true
    _avg?: ChannelDefinitionAvgAggregateInputType
    _sum?: ChannelDefinitionSumAggregateInputType
    _min?: ChannelDefinitionMinAggregateInputType
    _max?: ChannelDefinitionMaxAggregateInputType
  }

  export type ChannelDefinitionGroupByOutputType = {
    id: string
    label: string
    icon: string
    popular: boolean
    popularLocales: string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl: string | null
    helpText: string | null
    sortOrder: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ChannelDefinitionCountAggregateOutputType | null
    _avg: ChannelDefinitionAvgAggregateOutputType | null
    _sum: ChannelDefinitionSumAggregateOutputType | null
    _min: ChannelDefinitionMinAggregateOutputType | null
    _max: ChannelDefinitionMaxAggregateOutputType | null
  }

  type GetChannelDefinitionGroupByPayload<T extends ChannelDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type ChannelDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    popularLocales?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    credentialFields?: boolean | ChannelDefinition$credentialFieldsArgs<ExtArgs>
    _count?: boolean | ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    popularLocales?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    popularLocales?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectScalar = {
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    popularLocales?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChannelDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "icon" | "popular" | "popularLocales" | "tokenHint" | "tokenPlaceholder" | "helpUrl" | "helpText" | "sortOrder" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["channelDefinition"]>
  export type ChannelDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credentialFields?: boolean | ChannelDefinition$credentialFieldsArgs<ExtArgs>
    _count?: boolean | ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChannelDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChannelDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelDefinition"
    objects: {
      credentialFields: Prisma.$ChannelCredentialFieldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      icon: string
      popular: boolean
      popularLocales: string[]
      tokenHint: string
      tokenPlaceholder: string
      helpUrl: string | null
      helpText: string | null
      sortOrder: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["channelDefinition"]>
    composites: {}
  }

  type ChannelDefinitionGetPayload<S extends boolean | null | undefined | ChannelDefinitionDefaultArgs> = $Result.GetResult<Prisma.$ChannelDefinitionPayload, S>

  type ChannelDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelDefinitionCountAggregateInputType | true
    }

  export interface ChannelDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelDefinition'], meta: { name: 'ChannelDefinition' } }
    /**
     * Find zero or one ChannelDefinition that matches the filter.
     * @param {ChannelDefinitionFindUniqueArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelDefinitionFindUniqueArgs>(args: SelectSubset<T, ChannelDefinitionFindUniqueArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelDefinitionFindUniqueOrThrowArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindFirstArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelDefinitionFindFirstArgs>(args?: SelectSubset<T, ChannelDefinitionFindFirstArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindFirstOrThrowArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelDefinitions
     * const channelDefinitions = await prisma.channelDefinition.findMany()
     * 
     * // Get first 10 ChannelDefinitions
     * const channelDefinitions = await prisma.channelDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelDefinitionFindManyArgs>(args?: SelectSubset<T, ChannelDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelDefinition.
     * @param {ChannelDefinitionCreateArgs} args - Arguments to create a ChannelDefinition.
     * @example
     * // Create one ChannelDefinition
     * const ChannelDefinition = await prisma.channelDefinition.create({
     *   data: {
     *     // ... data to create a ChannelDefinition
     *   }
     * })
     * 
     */
    create<T extends ChannelDefinitionCreateArgs>(args: SelectSubset<T, ChannelDefinitionCreateArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelDefinitions.
     * @param {ChannelDefinitionCreateManyArgs} args - Arguments to create many ChannelDefinitions.
     * @example
     * // Create many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelDefinitionCreateManyArgs>(args?: SelectSubset<T, ChannelDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelDefinitions and returns the data saved in the database.
     * @param {ChannelDefinitionCreateManyAndReturnArgs} args - Arguments to create many ChannelDefinitions.
     * @example
     * // Create many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelDefinitions and only return the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChannelDefinition.
     * @param {ChannelDefinitionDeleteArgs} args - Arguments to delete one ChannelDefinition.
     * @example
     * // Delete one ChannelDefinition
     * const ChannelDefinition = await prisma.channelDefinition.delete({
     *   where: {
     *     // ... filter to delete one ChannelDefinition
     *   }
     * })
     * 
     */
    delete<T extends ChannelDefinitionDeleteArgs>(args: SelectSubset<T, ChannelDefinitionDeleteArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelDefinition.
     * @param {ChannelDefinitionUpdateArgs} args - Arguments to update one ChannelDefinition.
     * @example
     * // Update one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelDefinitionUpdateArgs>(args: SelectSubset<T, ChannelDefinitionUpdateArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelDefinitions.
     * @param {ChannelDefinitionDeleteManyArgs} args - Arguments to filter ChannelDefinitions to delete.
     * @example
     * // Delete a few ChannelDefinitions
     * const { count } = await prisma.channelDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDefinitionDeleteManyArgs>(args?: SelectSubset<T, ChannelDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelDefinitionUpdateManyArgs>(args: SelectSubset<T, ChannelDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelDefinitions and returns the data updated in the database.
     * @param {ChannelDefinitionUpdateManyAndReturnArgs} args - Arguments to update many ChannelDefinitions.
     * @example
     * // Update many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChannelDefinitions and only return the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChannelDefinition.
     * @param {ChannelDefinitionUpsertArgs} args - Arguments to update or create a ChannelDefinition.
     * @example
     * // Update or create a ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.upsert({
     *   create: {
     *     // ... data to create a ChannelDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelDefinition we want to update
     *   }
     * })
     */
    upsert<T extends ChannelDefinitionUpsertArgs>(args: SelectSubset<T, ChannelDefinitionUpsertArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChannelDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionCountArgs} args - Arguments to filter ChannelDefinitions to count.
     * @example
     * // Count the number of ChannelDefinitions
     * const count = await prisma.channelDefinition.count({
     *   where: {
     *     // ... the filter for the ChannelDefinitions we want to count
     *   }
     * })
    **/
    count<T extends ChannelDefinitionCountArgs>(
      args?: Subset<T, ChannelDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelDefinitionAggregateArgs>(args: Subset<T, ChannelDefinitionAggregateArgs>): Prisma.PrismaPromise<GetChannelDefinitionAggregateType<T>>

    /**
     * Group by ChannelDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: ChannelDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelDefinition model
   */
  readonly fields: ChannelDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credentialFields<T extends ChannelDefinition$credentialFieldsArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefinition$credentialFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelDefinition model
   */
  interface ChannelDefinitionFieldRefs {
    readonly id: FieldRef<"ChannelDefinition", 'String'>
    readonly label: FieldRef<"ChannelDefinition", 'String'>
    readonly icon: FieldRef<"ChannelDefinition", 'String'>
    readonly popular: FieldRef<"ChannelDefinition", 'Boolean'>
    readonly popularLocales: FieldRef<"ChannelDefinition", 'String[]'>
    readonly tokenHint: FieldRef<"ChannelDefinition", 'String'>
    readonly tokenPlaceholder: FieldRef<"ChannelDefinition", 'String'>
    readonly helpUrl: FieldRef<"ChannelDefinition", 'String'>
    readonly helpText: FieldRef<"ChannelDefinition", 'String'>
    readonly sortOrder: FieldRef<"ChannelDefinition", 'Int'>
    readonly isDeleted: FieldRef<"ChannelDefinition", 'Boolean'>
    readonly createdAt: FieldRef<"ChannelDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"ChannelDefinition", 'DateTime'>
    readonly deletedAt: FieldRef<"ChannelDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelDefinition findUnique
   */
  export type ChannelDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition findUniqueOrThrow
   */
  export type ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition findFirst
   */
  export type ChannelDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelDefinitions.
     */
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition findFirstOrThrow
   */
  export type ChannelDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelDefinitions.
     */
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition findMany
   */
  export type ChannelDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinitions to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition create
   */
  export type ChannelDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelDefinition.
     */
    data: XOR<ChannelDefinitionCreateInput, ChannelDefinitionUncheckedCreateInput>
  }

  /**
   * ChannelDefinition createMany
   */
  export type ChannelDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelDefinitions.
     */
    data: ChannelDefinitionCreateManyInput | ChannelDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelDefinition createManyAndReturn
   */
  export type ChannelDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many ChannelDefinitions.
     */
    data: ChannelDefinitionCreateManyInput | ChannelDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelDefinition update
   */
  export type ChannelDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelDefinition.
     */
    data: XOR<ChannelDefinitionUpdateInput, ChannelDefinitionUncheckedUpdateInput>
    /**
     * Choose, which ChannelDefinition to update.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition updateMany
   */
  export type ChannelDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelDefinitions.
     */
    data: XOR<ChannelDefinitionUpdateManyMutationInput, ChannelDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ChannelDefinitions to update
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to update.
     */
    limit?: number
  }

  /**
   * ChannelDefinition updateManyAndReturn
   */
  export type ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update ChannelDefinitions.
     */
    data: XOR<ChannelDefinitionUpdateManyMutationInput, ChannelDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ChannelDefinitions to update
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to update.
     */
    limit?: number
  }

  /**
   * ChannelDefinition upsert
   */
  export type ChannelDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelDefinition to update in case it exists.
     */
    where: ChannelDefinitionWhereUniqueInput
    /**
     * In case the ChannelDefinition found by the `where` argument doesn't exist, create a new ChannelDefinition with this data.
     */
    create: XOR<ChannelDefinitionCreateInput, ChannelDefinitionUncheckedCreateInput>
    /**
     * In case the ChannelDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelDefinitionUpdateInput, ChannelDefinitionUncheckedUpdateInput>
  }

  /**
   * ChannelDefinition delete
   */
  export type ChannelDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter which ChannelDefinition to delete.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition deleteMany
   */
  export type ChannelDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelDefinitions to delete
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to delete.
     */
    limit?: number
  }

  /**
   * ChannelDefinition.credentialFields
   */
  export type ChannelDefinition$credentialFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    where?: ChannelCredentialFieldWhereInput
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    cursor?: ChannelCredentialFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelDefinition without action
   */
  export type ChannelDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model ChannelCredentialField
   */

  export type AggregateChannelCredentialField = {
    _count: ChannelCredentialFieldCountAggregateOutputType | null
    _avg: ChannelCredentialFieldAvgAggregateOutputType | null
    _sum: ChannelCredentialFieldSumAggregateOutputType | null
    _min: ChannelCredentialFieldMinAggregateOutputType | null
    _max: ChannelCredentialFieldMaxAggregateOutputType | null
  }

  export type ChannelCredentialFieldAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelCredentialFieldSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelCredentialFieldMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    key: string | null
    label: string | null
    placeholder: string | null
    fieldType: string | null
    required: boolean | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelCredentialFieldMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    key: string | null
    label: string | null
    placeholder: string | null
    fieldType: string | null
    required: boolean | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelCredentialFieldCountAggregateOutputType = {
    id: number
    channelId: number
    key: number
    label: number
    placeholder: number
    fieldType: number
    required: number
    sortOrder: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChannelCredentialFieldAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelCredentialFieldSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelCredentialFieldMinAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelCredentialFieldMaxAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelCredentialFieldCountAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChannelCredentialFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCredentialField to aggregate.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelCredentialFields
    **/
    _count?: true | ChannelCredentialFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelCredentialFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelCredentialFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelCredentialFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelCredentialFieldMaxAggregateInputType
  }

  export type GetChannelCredentialFieldAggregateType<T extends ChannelCredentialFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelCredentialField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelCredentialField[P]>
      : GetScalarType<T[P], AggregateChannelCredentialField[P]>
  }




  export type ChannelCredentialFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCredentialFieldWhereInput
    orderBy?: ChannelCredentialFieldOrderByWithAggregationInput | ChannelCredentialFieldOrderByWithAggregationInput[]
    by: ChannelCredentialFieldScalarFieldEnum[] | ChannelCredentialFieldScalarFieldEnum
    having?: ChannelCredentialFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCredentialFieldCountAggregateInputType | true
    _avg?: ChannelCredentialFieldAvgAggregateInputType
    _sum?: ChannelCredentialFieldSumAggregateInputType
    _min?: ChannelCredentialFieldMinAggregateInputType
    _max?: ChannelCredentialFieldMaxAggregateInputType
  }

  export type ChannelCredentialFieldGroupByOutputType = {
    id: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType: string
    required: boolean
    sortOrder: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ChannelCredentialFieldCountAggregateOutputType | null
    _avg: ChannelCredentialFieldAvgAggregateOutputType | null
    _sum: ChannelCredentialFieldSumAggregateOutputType | null
    _min: ChannelCredentialFieldMinAggregateOutputType | null
    _max: ChannelCredentialFieldMaxAggregateOutputType | null
  }

  type GetChannelCredentialFieldGroupByPayload<T extends ChannelCredentialFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelCredentialFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelCredentialFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelCredentialFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelCredentialFieldGroupByOutputType[P]>
        }
      >
    >


  export type ChannelCredentialFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectScalar = {
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChannelCredentialFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "channelId" | "key" | "label" | "placeholder" | "fieldType" | "required" | "sortOrder" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["channelCredentialField"]>
  export type ChannelCredentialFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }
  export type ChannelCredentialFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }
  export type ChannelCredentialFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }

  export type $ChannelCredentialFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelCredentialField"
    objects: {
      channel: Prisma.$ChannelDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      key: string
      label: string
      placeholder: string
      fieldType: string
      required: boolean
      sortOrder: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["channelCredentialField"]>
    composites: {}
  }

  type ChannelCredentialFieldGetPayload<S extends boolean | null | undefined | ChannelCredentialFieldDefaultArgs> = $Result.GetResult<Prisma.$ChannelCredentialFieldPayload, S>

  type ChannelCredentialFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelCredentialFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCredentialFieldCountAggregateInputType | true
    }

  export interface ChannelCredentialFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelCredentialField'], meta: { name: 'ChannelCredentialField' } }
    /**
     * Find zero or one ChannelCredentialField that matches the filter.
     * @param {ChannelCredentialFieldFindUniqueArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelCredentialFieldFindUniqueArgs>(args: SelectSubset<T, ChannelCredentialFieldFindUniqueArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelCredentialField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelCredentialFieldFindUniqueOrThrowArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelCredentialFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelCredentialField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindFirstArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelCredentialFieldFindFirstArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindFirstArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelCredentialField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindFirstOrThrowArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelCredentialFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelCredentialFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelCredentialFields
     * const channelCredentialFields = await prisma.channelCredentialField.findMany()
     * 
     * // Get first 10 ChannelCredentialFields
     * const channelCredentialFields = await prisma.channelCredentialField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelCredentialFieldFindManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelCredentialField.
     * @param {ChannelCredentialFieldCreateArgs} args - Arguments to create a ChannelCredentialField.
     * @example
     * // Create one ChannelCredentialField
     * const ChannelCredentialField = await prisma.channelCredentialField.create({
     *   data: {
     *     // ... data to create a ChannelCredentialField
     *   }
     * })
     * 
     */
    create<T extends ChannelCredentialFieldCreateArgs>(args: SelectSubset<T, ChannelCredentialFieldCreateArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelCredentialFields.
     * @param {ChannelCredentialFieldCreateManyArgs} args - Arguments to create many ChannelCredentialFields.
     * @example
     * // Create many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCredentialFieldCreateManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelCredentialFields and returns the data saved in the database.
     * @param {ChannelCredentialFieldCreateManyAndReturnArgs} args - Arguments to create many ChannelCredentialFields.
     * @example
     * // Create many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelCredentialFields and only return the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCredentialFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChannelCredentialField.
     * @param {ChannelCredentialFieldDeleteArgs} args - Arguments to delete one ChannelCredentialField.
     * @example
     * // Delete one ChannelCredentialField
     * const ChannelCredentialField = await prisma.channelCredentialField.delete({
     *   where: {
     *     // ... filter to delete one ChannelCredentialField
     *   }
     * })
     * 
     */
    delete<T extends ChannelCredentialFieldDeleteArgs>(args: SelectSubset<T, ChannelCredentialFieldDeleteArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelCredentialField.
     * @param {ChannelCredentialFieldUpdateArgs} args - Arguments to update one ChannelCredentialField.
     * @example
     * // Update one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelCredentialFieldUpdateArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelCredentialFields.
     * @param {ChannelCredentialFieldDeleteManyArgs} args - Arguments to filter ChannelCredentialFields to delete.
     * @example
     * // Delete a few ChannelCredentialFields
     * const { count } = await prisma.channelCredentialField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelCredentialFieldDeleteManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCredentialFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelCredentialFieldUpdateManyArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCredentialFields and returns the data updated in the database.
     * @param {ChannelCredentialFieldUpdateManyAndReturnArgs} args - Arguments to update many ChannelCredentialFields.
     * @example
     * // Update many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChannelCredentialFields and only return the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelCredentialFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChannelCredentialField.
     * @param {ChannelCredentialFieldUpsertArgs} args - Arguments to update or create a ChannelCredentialField.
     * @example
     * // Update or create a ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.upsert({
     *   create: {
     *     // ... data to create a ChannelCredentialField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelCredentialField we want to update
     *   }
     * })
     */
    upsert<T extends ChannelCredentialFieldUpsertArgs>(args: SelectSubset<T, ChannelCredentialFieldUpsertArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChannelCredentialFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldCountArgs} args - Arguments to filter ChannelCredentialFields to count.
     * @example
     * // Count the number of ChannelCredentialFields
     * const count = await prisma.channelCredentialField.count({
     *   where: {
     *     // ... the filter for the ChannelCredentialFields we want to count
     *   }
     * })
    **/
    count<T extends ChannelCredentialFieldCountArgs>(
      args?: Subset<T, ChannelCredentialFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCredentialFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelCredentialField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelCredentialFieldAggregateArgs>(args: Subset<T, ChannelCredentialFieldAggregateArgs>): Prisma.PrismaPromise<GetChannelCredentialFieldAggregateType<T>>

    /**
     * Group by ChannelCredentialField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelCredentialFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelCredentialFieldGroupByArgs['orderBy'] }
        : { orderBy?: ChannelCredentialFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelCredentialFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelCredentialFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelCredentialField model
   */
  readonly fields: ChannelCredentialFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelCredentialField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelCredentialFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefinitionDefaultArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelCredentialField model
   */
  interface ChannelCredentialFieldFieldRefs {
    readonly id: FieldRef<"ChannelCredentialField", 'String'>
    readonly channelId: FieldRef<"ChannelCredentialField", 'String'>
    readonly key: FieldRef<"ChannelCredentialField", 'String'>
    readonly label: FieldRef<"ChannelCredentialField", 'String'>
    readonly placeholder: FieldRef<"ChannelCredentialField", 'String'>
    readonly fieldType: FieldRef<"ChannelCredentialField", 'String'>
    readonly required: FieldRef<"ChannelCredentialField", 'Boolean'>
    readonly sortOrder: FieldRef<"ChannelCredentialField", 'Int'>
    readonly isDeleted: FieldRef<"ChannelCredentialField", 'Boolean'>
    readonly createdAt: FieldRef<"ChannelCredentialField", 'DateTime'>
    readonly updatedAt: FieldRef<"ChannelCredentialField", 'DateTime'>
    readonly deletedAt: FieldRef<"ChannelCredentialField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelCredentialField findUnique
   */
  export type ChannelCredentialFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField findUniqueOrThrow
   */
  export type ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField findFirst
   */
  export type ChannelCredentialFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCredentialFields.
     */
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField findFirstOrThrow
   */
  export type ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCredentialFields.
     */
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField findMany
   */
  export type ChannelCredentialFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialFields to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField create
   */
  export type ChannelCredentialFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelCredentialField.
     */
    data: XOR<ChannelCredentialFieldCreateInput, ChannelCredentialFieldUncheckedCreateInput>
  }

  /**
   * ChannelCredentialField createMany
   */
  export type ChannelCredentialFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelCredentialFields.
     */
    data: ChannelCredentialFieldCreateManyInput | ChannelCredentialFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelCredentialField createManyAndReturn
   */
  export type ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * The data used to create many ChannelCredentialFields.
     */
    data: ChannelCredentialFieldCreateManyInput | ChannelCredentialFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelCredentialField update
   */
  export type ChannelCredentialFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelCredentialField.
     */
    data: XOR<ChannelCredentialFieldUpdateInput, ChannelCredentialFieldUncheckedUpdateInput>
    /**
     * Choose, which ChannelCredentialField to update.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField updateMany
   */
  export type ChannelCredentialFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelCredentialFields.
     */
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCredentialFields to update
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to update.
     */
    limit?: number
  }

  /**
   * ChannelCredentialField updateManyAndReturn
   */
  export type ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * The data used to update ChannelCredentialFields.
     */
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCredentialFields to update
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelCredentialField upsert
   */
  export type ChannelCredentialFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelCredentialField to update in case it exists.
     */
    where: ChannelCredentialFieldWhereUniqueInput
    /**
     * In case the ChannelCredentialField found by the `where` argument doesn't exist, create a new ChannelCredentialField with this data.
     */
    create: XOR<ChannelCredentialFieldCreateInput, ChannelCredentialFieldUncheckedCreateInput>
    /**
     * In case the ChannelCredentialField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelCredentialFieldUpdateInput, ChannelCredentialFieldUncheckedUpdateInput>
  }

  /**
   * ChannelCredentialField delete
   */
  export type ChannelCredentialFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter which ChannelCredentialField to delete.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField deleteMany
   */
  export type ChannelCredentialFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCredentialFields to delete
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to delete.
     */
    limit?: number
  }

  /**
   * ChannelCredentialField without action
   */
  export type ChannelCredentialFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
  }


  /**
   * Model Plugin
   */

  export type AggregatePlugin = {
    _count: PluginCountAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  export type PluginMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    version: string | null
    author: string | null
    category: $Enums.PluginCategory | null
    region: string | null
    isOfficial: boolean | null
    isEnabled: boolean | null
    downloadUrl: string | null
    iconEmoji: string | null
    iconUrl: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PluginMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    version: string | null
    author: string | null
    category: $Enums.PluginCategory | null
    region: string | null
    isOfficial: boolean | null
    isEnabled: boolean | null
    downloadUrl: string | null
    iconEmoji: string | null
    iconUrl: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PluginCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    version: number
    author: number
    category: number
    region: number
    configSchema: number
    defaultConfig: number
    mcpConfig: number
    isOfficial: number
    isEnabled: number
    downloadUrl: number
    iconEmoji: number
    iconUrl: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PluginMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    version?: true
    author?: true
    category?: true
    region?: true
    isOfficial?: true
    isEnabled?: true
    downloadUrl?: true
    iconEmoji?: true
    iconUrl?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PluginMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    version?: true
    author?: true
    category?: true
    region?: true
    isOfficial?: true
    isEnabled?: true
    downloadUrl?: true
    iconEmoji?: true
    iconUrl?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PluginCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    version?: true
    author?: true
    category?: true
    region?: true
    configSchema?: true
    defaultConfig?: true
    mcpConfig?: true
    isOfficial?: true
    isEnabled?: true
    downloadUrl?: true
    iconEmoji?: true
    iconUrl?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugin to aggregate.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Plugins
    **/
    _count?: true | PluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PluginMaxAggregateInputType
  }

  export type GetPluginAggregateType<T extends PluginAggregateArgs> = {
        [P in keyof T & keyof AggregatePlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlugin[P]>
      : GetScalarType<T[P], AggregatePlugin[P]>
  }




  export type PluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PluginWhereInput
    orderBy?: PluginOrderByWithAggregationInput | PluginOrderByWithAggregationInput[]
    by: PluginScalarFieldEnum[] | PluginScalarFieldEnum
    having?: PluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PluginCountAggregateInputType | true
    _min?: PluginMinAggregateInputType
    _max?: PluginMaxAggregateInputType
  }

  export type PluginGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    version: string
    author: string | null
    category: $Enums.PluginCategory
    region: string
    configSchema: JsonValue | null
    defaultConfig: JsonValue | null
    mcpConfig: JsonValue | null
    isOfficial: boolean
    isEnabled: boolean
    downloadUrl: string | null
    iconEmoji: string | null
    iconUrl: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PluginCountAggregateOutputType | null
    _min: PluginMinAggregateOutputType | null
    _max: PluginMaxAggregateOutputType | null
  }

  type GetPluginGroupByPayload<T extends PluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PluginGroupByOutputType[P]>
            : GetScalarType<T[P], PluginGroupByOutputType[P]>
        }
      >
    >


  export type PluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    region?: boolean
    configSchema?: boolean
    defaultConfig?: boolean
    mcpConfig?: boolean
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: boolean
    iconEmoji?: boolean
    iconUrl?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    installations?: boolean | Plugin$installationsArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    region?: boolean
    configSchema?: boolean
    defaultConfig?: boolean
    mcpConfig?: boolean
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: boolean
    iconEmoji?: boolean
    iconUrl?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    region?: boolean
    configSchema?: boolean
    defaultConfig?: boolean
    mcpConfig?: boolean
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: boolean
    iconEmoji?: boolean
    iconUrl?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["plugin"]>

  export type PluginSelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    version?: boolean
    author?: boolean
    category?: boolean
    region?: boolean
    configSchema?: boolean
    defaultConfig?: boolean
    mcpConfig?: boolean
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: boolean
    iconEmoji?: boolean
    iconUrl?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PluginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "slug" | "description" | "version" | "author" | "category" | "region" | "configSchema" | "defaultConfig" | "mcpConfig" | "isOfficial" | "isEnabled" | "downloadUrl" | "iconEmoji" | "iconUrl" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["plugin"]>
  export type PluginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    installations?: boolean | Plugin$installationsArgs<ExtArgs>
    _count?: boolean | PluginCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PluginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PluginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Plugin"
    objects: {
      installations: Prisma.$BotPluginPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      version: string
      author: string | null
      category: $Enums.PluginCategory
      region: string
      configSchema: Prisma.JsonValue | null
      defaultConfig: Prisma.JsonValue | null
      mcpConfig: Prisma.JsonValue | null
      isOfficial: boolean
      isEnabled: boolean
      downloadUrl: string | null
      iconEmoji: string | null
      iconUrl: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["plugin"]>
    composites: {}
  }

  type PluginGetPayload<S extends boolean | null | undefined | PluginDefaultArgs> = $Result.GetResult<Prisma.$PluginPayload, S>

  type PluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PluginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PluginCountAggregateInputType | true
    }

  export interface PluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Plugin'], meta: { name: 'Plugin' } }
    /**
     * Find zero or one Plugin that matches the filter.
     * @param {PluginFindUniqueArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PluginFindUniqueArgs>(args: SelectSubset<T, PluginFindUniqueArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Plugin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PluginFindUniqueOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PluginFindUniqueOrThrowArgs>(args: SelectSubset<T, PluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PluginFindFirstArgs>(args?: SelectSubset<T, PluginFindFirstArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Plugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindFirstOrThrowArgs} args - Arguments to find a Plugin
     * @example
     * // Get one Plugin
     * const plugin = await prisma.plugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PluginFindFirstOrThrowArgs>(args?: SelectSubset<T, PluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Plugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Plugins
     * const plugins = await prisma.plugin.findMany()
     * 
     * // Get first 10 Plugins
     * const plugins = await prisma.plugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const pluginWithIdOnly = await prisma.plugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PluginFindManyArgs>(args?: SelectSubset<T, PluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Plugin.
     * @param {PluginCreateArgs} args - Arguments to create a Plugin.
     * @example
     * // Create one Plugin
     * const Plugin = await prisma.plugin.create({
     *   data: {
     *     // ... data to create a Plugin
     *   }
     * })
     * 
     */
    create<T extends PluginCreateArgs>(args: SelectSubset<T, PluginCreateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Plugins.
     * @param {PluginCreateManyArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PluginCreateManyArgs>(args?: SelectSubset<T, PluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Plugins and returns the data saved in the database.
     * @param {PluginCreateManyAndReturnArgs} args - Arguments to create many Plugins.
     * @example
     * // Create many Plugins
     * const plugin = await prisma.plugin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PluginCreateManyAndReturnArgs>(args?: SelectSubset<T, PluginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Plugin.
     * @param {PluginDeleteArgs} args - Arguments to delete one Plugin.
     * @example
     * // Delete one Plugin
     * const Plugin = await prisma.plugin.delete({
     *   where: {
     *     // ... filter to delete one Plugin
     *   }
     * })
     * 
     */
    delete<T extends PluginDeleteArgs>(args: SelectSubset<T, PluginDeleteArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Plugin.
     * @param {PluginUpdateArgs} args - Arguments to update one Plugin.
     * @example
     * // Update one Plugin
     * const plugin = await prisma.plugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PluginUpdateArgs>(args: SelectSubset<T, PluginUpdateArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Plugins.
     * @param {PluginDeleteManyArgs} args - Arguments to filter Plugins to delete.
     * @example
     * // Delete a few Plugins
     * const { count } = await prisma.plugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PluginDeleteManyArgs>(args?: SelectSubset<T, PluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PluginUpdateManyArgs>(args: SelectSubset<T, PluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Plugins and returns the data updated in the database.
     * @param {PluginUpdateManyAndReturnArgs} args - Arguments to update many Plugins.
     * @example
     * // Update many Plugins
     * const plugin = await prisma.plugin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Plugins and only return the `id`
     * const pluginWithIdOnly = await prisma.plugin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PluginUpdateManyAndReturnArgs>(args: SelectSubset<T, PluginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Plugin.
     * @param {PluginUpsertArgs} args - Arguments to update or create a Plugin.
     * @example
     * // Update or create a Plugin
     * const plugin = await prisma.plugin.upsert({
     *   create: {
     *     // ... data to create a Plugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Plugin we want to update
     *   }
     * })
     */
    upsert<T extends PluginUpsertArgs>(args: SelectSubset<T, PluginUpsertArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Plugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginCountArgs} args - Arguments to filter Plugins to count.
     * @example
     * // Count the number of Plugins
     * const count = await prisma.plugin.count({
     *   where: {
     *     // ... the filter for the Plugins we want to count
     *   }
     * })
    **/
    count<T extends PluginCountArgs>(
      args?: Subset<T, PluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PluginAggregateArgs>(args: Subset<T, PluginAggregateArgs>): Prisma.PrismaPromise<GetPluginAggregateType<T>>

    /**
     * Group by Plugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PluginGroupByArgs['orderBy'] }
        : { orderBy?: PluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Plugin model
   */
  readonly fields: PluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Plugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    installations<T extends Plugin$installationsArgs<ExtArgs> = {}>(args?: Subset<T, Plugin$installationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Plugin model
   */
  interface PluginFieldRefs {
    readonly id: FieldRef<"Plugin", 'String'>
    readonly name: FieldRef<"Plugin", 'String'>
    readonly slug: FieldRef<"Plugin", 'String'>
    readonly description: FieldRef<"Plugin", 'String'>
    readonly version: FieldRef<"Plugin", 'String'>
    readonly author: FieldRef<"Plugin", 'String'>
    readonly category: FieldRef<"Plugin", 'PluginCategory'>
    readonly region: FieldRef<"Plugin", 'String'>
    readonly configSchema: FieldRef<"Plugin", 'Json'>
    readonly defaultConfig: FieldRef<"Plugin", 'Json'>
    readonly mcpConfig: FieldRef<"Plugin", 'Json'>
    readonly isOfficial: FieldRef<"Plugin", 'Boolean'>
    readonly isEnabled: FieldRef<"Plugin", 'Boolean'>
    readonly downloadUrl: FieldRef<"Plugin", 'String'>
    readonly iconEmoji: FieldRef<"Plugin", 'String'>
    readonly iconUrl: FieldRef<"Plugin", 'String'>
    readonly isDeleted: FieldRef<"Plugin", 'Boolean'>
    readonly createdAt: FieldRef<"Plugin", 'DateTime'>
    readonly updatedAt: FieldRef<"Plugin", 'DateTime'>
    readonly deletedAt: FieldRef<"Plugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Plugin findUnique
   */
  export type PluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findUniqueOrThrow
   */
  export type PluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin findFirst
   */
  export type PluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findFirstOrThrow
   */
  export type PluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugin to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Plugins.
     */
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin findMany
   */
  export type PluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter, which Plugins to fetch.
     */
    where?: PluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Plugins to fetch.
     */
    orderBy?: PluginOrderByWithRelationInput | PluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Plugins.
     */
    cursor?: PluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Plugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Plugins.
     */
    skip?: number
    distinct?: PluginScalarFieldEnum | PluginScalarFieldEnum[]
  }

  /**
   * Plugin create
   */
  export type PluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to create a Plugin.
     */
    data: XOR<PluginCreateInput, PluginUncheckedCreateInput>
  }

  /**
   * Plugin createMany
   */
  export type PluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Plugins.
     */
    data: PluginCreateManyInput | PluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plugin createManyAndReturn
   */
  export type PluginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * The data used to create many Plugins.
     */
    data: PluginCreateManyInput | PluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Plugin update
   */
  export type PluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The data needed to update a Plugin.
     */
    data: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
    /**
     * Choose, which Plugin to update.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin updateMany
   */
  export type PluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Plugins.
     */
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyInput>
    /**
     * Filter which Plugins to update
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to update.
     */
    limit?: number
  }

  /**
   * Plugin updateManyAndReturn
   */
  export type PluginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * The data used to update Plugins.
     */
    data: XOR<PluginUpdateManyMutationInput, PluginUncheckedUpdateManyInput>
    /**
     * Filter which Plugins to update
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to update.
     */
    limit?: number
  }

  /**
   * Plugin upsert
   */
  export type PluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * The filter to search for the Plugin to update in case it exists.
     */
    where: PluginWhereUniqueInput
    /**
     * In case the Plugin found by the `where` argument doesn't exist, create a new Plugin with this data.
     */
    create: XOR<PluginCreateInput, PluginUncheckedCreateInput>
    /**
     * In case the Plugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PluginUpdateInput, PluginUncheckedUpdateInput>
  }

  /**
   * Plugin delete
   */
  export type PluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
    /**
     * Filter which Plugin to delete.
     */
    where: PluginWhereUniqueInput
  }

  /**
   * Plugin deleteMany
   */
  export type PluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Plugins to delete
     */
    where?: PluginWhereInput
    /**
     * Limit how many Plugins to delete.
     */
    limit?: number
  }

  /**
   * Plugin.installations
   */
  export type Plugin$installationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    where?: BotPluginWhereInput
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    cursor?: BotPluginWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotPluginScalarFieldEnum | BotPluginScalarFieldEnum[]
  }

  /**
   * Plugin without action
   */
  export type PluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Plugin
     */
    select?: PluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Plugin
     */
    omit?: PluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PluginInclude<ExtArgs> | null
  }


  /**
   * Model BotPlugin
   */

  export type AggregateBotPlugin = {
    _count: BotPluginCountAggregateOutputType | null
    _min: BotPluginMinAggregateOutputType | null
    _max: BotPluginMaxAggregateOutputType | null
  }

  export type BotPluginMinAggregateOutputType = {
    id: string | null
    botId: string | null
    pluginId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotPluginMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    pluginId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotPluginCountAggregateOutputType = {
    id: number
    botId: number
    pluginId: number
    config: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotPluginMinAggregateInputType = {
    id?: true
    botId?: true
    pluginId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotPluginMaxAggregateInputType = {
    id?: true
    botId?: true
    pluginId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotPluginCountAggregateInputType = {
    id?: true
    botId?: true
    pluginId?: true
    config?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotPluginAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotPlugin to aggregate.
     */
    where?: BotPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPlugins to fetch.
     */
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotPlugins
    **/
    _count?: true | BotPluginCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotPluginMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotPluginMaxAggregateInputType
  }

  export type GetBotPluginAggregateType<T extends BotPluginAggregateArgs> = {
        [P in keyof T & keyof AggregateBotPlugin]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotPlugin[P]>
      : GetScalarType<T[P], AggregateBotPlugin[P]>
  }




  export type BotPluginGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotPluginWhereInput
    orderBy?: BotPluginOrderByWithAggregationInput | BotPluginOrderByWithAggregationInput[]
    by: BotPluginScalarFieldEnum[] | BotPluginScalarFieldEnum
    having?: BotPluginScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotPluginCountAggregateInputType | true
    _min?: BotPluginMinAggregateInputType
    _max?: BotPluginMaxAggregateInputType
  }

  export type BotPluginGroupByOutputType = {
    id: string
    botId: string
    pluginId: string
    config: JsonValue | null
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: BotPluginCountAggregateOutputType | null
    _min: BotPluginMinAggregateOutputType | null
    _max: BotPluginMaxAggregateOutputType | null
  }

  type GetBotPluginGroupByPayload<T extends BotPluginGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotPluginGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotPluginGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotPluginGroupByOutputType[P]>
            : GetScalarType<T[P], BotPluginGroupByOutputType[P]>
        }
      >
    >


  export type BotPluginSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    pluginId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botPlugin"]>

  export type BotPluginSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    pluginId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botPlugin"]>

  export type BotPluginSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    pluginId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botPlugin"]>

  export type BotPluginSelectScalar = {
    id?: boolean
    botId?: boolean
    pluginId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BotPluginOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "pluginId" | "config" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["botPlugin"]>
  export type BotPluginInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }
  export type BotPluginIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }
  export type BotPluginIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    plugin?: boolean | PluginDefaultArgs<ExtArgs>
  }

  export type $BotPluginPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotPlugin"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      plugin: Prisma.$PluginPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      pluginId: string
      config: Prisma.JsonValue | null
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["botPlugin"]>
    composites: {}
  }

  type BotPluginGetPayload<S extends boolean | null | undefined | BotPluginDefaultArgs> = $Result.GetResult<Prisma.$BotPluginPayload, S>

  type BotPluginCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotPluginFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotPluginCountAggregateInputType | true
    }

  export interface BotPluginDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotPlugin'], meta: { name: 'BotPlugin' } }
    /**
     * Find zero or one BotPlugin that matches the filter.
     * @param {BotPluginFindUniqueArgs} args - Arguments to find a BotPlugin
     * @example
     * // Get one BotPlugin
     * const botPlugin = await prisma.botPlugin.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotPluginFindUniqueArgs>(args: SelectSubset<T, BotPluginFindUniqueArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotPlugin that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotPluginFindUniqueOrThrowArgs} args - Arguments to find a BotPlugin
     * @example
     * // Get one BotPlugin
     * const botPlugin = await prisma.botPlugin.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotPluginFindUniqueOrThrowArgs>(args: SelectSubset<T, BotPluginFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotPlugin that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginFindFirstArgs} args - Arguments to find a BotPlugin
     * @example
     * // Get one BotPlugin
     * const botPlugin = await prisma.botPlugin.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotPluginFindFirstArgs>(args?: SelectSubset<T, BotPluginFindFirstArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotPlugin that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginFindFirstOrThrowArgs} args - Arguments to find a BotPlugin
     * @example
     * // Get one BotPlugin
     * const botPlugin = await prisma.botPlugin.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotPluginFindFirstOrThrowArgs>(args?: SelectSubset<T, BotPluginFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotPlugins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotPlugins
     * const botPlugins = await prisma.botPlugin.findMany()
     * 
     * // Get first 10 BotPlugins
     * const botPlugins = await prisma.botPlugin.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botPluginWithIdOnly = await prisma.botPlugin.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotPluginFindManyArgs>(args?: SelectSubset<T, BotPluginFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotPlugin.
     * @param {BotPluginCreateArgs} args - Arguments to create a BotPlugin.
     * @example
     * // Create one BotPlugin
     * const BotPlugin = await prisma.botPlugin.create({
     *   data: {
     *     // ... data to create a BotPlugin
     *   }
     * })
     * 
     */
    create<T extends BotPluginCreateArgs>(args: SelectSubset<T, BotPluginCreateArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotPlugins.
     * @param {BotPluginCreateManyArgs} args - Arguments to create many BotPlugins.
     * @example
     * // Create many BotPlugins
     * const botPlugin = await prisma.botPlugin.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotPluginCreateManyArgs>(args?: SelectSubset<T, BotPluginCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotPlugins and returns the data saved in the database.
     * @param {BotPluginCreateManyAndReturnArgs} args - Arguments to create many BotPlugins.
     * @example
     * // Create many BotPlugins
     * const botPlugin = await prisma.botPlugin.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotPlugins and only return the `id`
     * const botPluginWithIdOnly = await prisma.botPlugin.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotPluginCreateManyAndReturnArgs>(args?: SelectSubset<T, BotPluginCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotPlugin.
     * @param {BotPluginDeleteArgs} args - Arguments to delete one BotPlugin.
     * @example
     * // Delete one BotPlugin
     * const BotPlugin = await prisma.botPlugin.delete({
     *   where: {
     *     // ... filter to delete one BotPlugin
     *   }
     * })
     * 
     */
    delete<T extends BotPluginDeleteArgs>(args: SelectSubset<T, BotPluginDeleteArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotPlugin.
     * @param {BotPluginUpdateArgs} args - Arguments to update one BotPlugin.
     * @example
     * // Update one BotPlugin
     * const botPlugin = await prisma.botPlugin.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotPluginUpdateArgs>(args: SelectSubset<T, BotPluginUpdateArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotPlugins.
     * @param {BotPluginDeleteManyArgs} args - Arguments to filter BotPlugins to delete.
     * @example
     * // Delete a few BotPlugins
     * const { count } = await prisma.botPlugin.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotPluginDeleteManyArgs>(args?: SelectSubset<T, BotPluginDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotPlugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotPlugins
     * const botPlugin = await prisma.botPlugin.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotPluginUpdateManyArgs>(args: SelectSubset<T, BotPluginUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotPlugins and returns the data updated in the database.
     * @param {BotPluginUpdateManyAndReturnArgs} args - Arguments to update many BotPlugins.
     * @example
     * // Update many BotPlugins
     * const botPlugin = await prisma.botPlugin.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotPlugins and only return the `id`
     * const botPluginWithIdOnly = await prisma.botPlugin.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotPluginUpdateManyAndReturnArgs>(args: SelectSubset<T, BotPluginUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotPlugin.
     * @param {BotPluginUpsertArgs} args - Arguments to update or create a BotPlugin.
     * @example
     * // Update or create a BotPlugin
     * const botPlugin = await prisma.botPlugin.upsert({
     *   create: {
     *     // ... data to create a BotPlugin
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotPlugin we want to update
     *   }
     * })
     */
    upsert<T extends BotPluginUpsertArgs>(args: SelectSubset<T, BotPluginUpsertArgs<ExtArgs>>): Prisma__BotPluginClient<$Result.GetResult<Prisma.$BotPluginPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotPlugins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginCountArgs} args - Arguments to filter BotPlugins to count.
     * @example
     * // Count the number of BotPlugins
     * const count = await prisma.botPlugin.count({
     *   where: {
     *     // ... the filter for the BotPlugins we want to count
     *   }
     * })
    **/
    count<T extends BotPluginCountArgs>(
      args?: Subset<T, BotPluginCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotPluginCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotPlugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotPluginAggregateArgs>(args: Subset<T, BotPluginAggregateArgs>): Prisma.PrismaPromise<GetBotPluginAggregateType<T>>

    /**
     * Group by BotPlugin.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotPluginGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotPluginGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotPluginGroupByArgs['orderBy'] }
        : { orderBy?: BotPluginGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotPluginGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotPluginGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotPlugin model
   */
  readonly fields: BotPluginFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotPlugin.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotPluginClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    plugin<T extends PluginDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PluginDefaultArgs<ExtArgs>>): Prisma__PluginClient<$Result.GetResult<Prisma.$PluginPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotPlugin model
   */
  interface BotPluginFieldRefs {
    readonly id: FieldRef<"BotPlugin", 'String'>
    readonly botId: FieldRef<"BotPlugin", 'String'>
    readonly pluginId: FieldRef<"BotPlugin", 'String'>
    readonly config: FieldRef<"BotPlugin", 'Json'>
    readonly isEnabled: FieldRef<"BotPlugin", 'Boolean'>
    readonly createdAt: FieldRef<"BotPlugin", 'DateTime'>
    readonly updatedAt: FieldRef<"BotPlugin", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotPlugin findUnique
   */
  export type BotPluginFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter, which BotPlugin to fetch.
     */
    where: BotPluginWhereUniqueInput
  }

  /**
   * BotPlugin findUniqueOrThrow
   */
  export type BotPluginFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter, which BotPlugin to fetch.
     */
    where: BotPluginWhereUniqueInput
  }

  /**
   * BotPlugin findFirst
   */
  export type BotPluginFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter, which BotPlugin to fetch.
     */
    where?: BotPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPlugins to fetch.
     */
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotPlugins.
     */
    cursor?: BotPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotPlugins.
     */
    distinct?: BotPluginScalarFieldEnum | BotPluginScalarFieldEnum[]
  }

  /**
   * BotPlugin findFirstOrThrow
   */
  export type BotPluginFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter, which BotPlugin to fetch.
     */
    where?: BotPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPlugins to fetch.
     */
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotPlugins.
     */
    cursor?: BotPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPlugins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotPlugins.
     */
    distinct?: BotPluginScalarFieldEnum | BotPluginScalarFieldEnum[]
  }

  /**
   * BotPlugin findMany
   */
  export type BotPluginFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter, which BotPlugins to fetch.
     */
    where?: BotPluginWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotPlugins to fetch.
     */
    orderBy?: BotPluginOrderByWithRelationInput | BotPluginOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotPlugins.
     */
    cursor?: BotPluginWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotPlugins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotPlugins.
     */
    skip?: number
    distinct?: BotPluginScalarFieldEnum | BotPluginScalarFieldEnum[]
  }

  /**
   * BotPlugin create
   */
  export type BotPluginCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * The data needed to create a BotPlugin.
     */
    data: XOR<BotPluginCreateInput, BotPluginUncheckedCreateInput>
  }

  /**
   * BotPlugin createMany
   */
  export type BotPluginCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotPlugins.
     */
    data: BotPluginCreateManyInput | BotPluginCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotPlugin createManyAndReturn
   */
  export type BotPluginCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * The data used to create many BotPlugins.
     */
    data: BotPluginCreateManyInput | BotPluginCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotPlugin update
   */
  export type BotPluginUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * The data needed to update a BotPlugin.
     */
    data: XOR<BotPluginUpdateInput, BotPluginUncheckedUpdateInput>
    /**
     * Choose, which BotPlugin to update.
     */
    where: BotPluginWhereUniqueInput
  }

  /**
   * BotPlugin updateMany
   */
  export type BotPluginUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotPlugins.
     */
    data: XOR<BotPluginUpdateManyMutationInput, BotPluginUncheckedUpdateManyInput>
    /**
     * Filter which BotPlugins to update
     */
    where?: BotPluginWhereInput
    /**
     * Limit how many BotPlugins to update.
     */
    limit?: number
  }

  /**
   * BotPlugin updateManyAndReturn
   */
  export type BotPluginUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * The data used to update BotPlugins.
     */
    data: XOR<BotPluginUpdateManyMutationInput, BotPluginUncheckedUpdateManyInput>
    /**
     * Filter which BotPlugins to update
     */
    where?: BotPluginWhereInput
    /**
     * Limit how many BotPlugins to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotPlugin upsert
   */
  export type BotPluginUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * The filter to search for the BotPlugin to update in case it exists.
     */
    where: BotPluginWhereUniqueInput
    /**
     * In case the BotPlugin found by the `where` argument doesn't exist, create a new BotPlugin with this data.
     */
    create: XOR<BotPluginCreateInput, BotPluginUncheckedCreateInput>
    /**
     * In case the BotPlugin was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotPluginUpdateInput, BotPluginUncheckedUpdateInput>
  }

  /**
   * BotPlugin delete
   */
  export type BotPluginDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
    /**
     * Filter which BotPlugin to delete.
     */
    where: BotPluginWhereUniqueInput
  }

  /**
   * BotPlugin deleteMany
   */
  export type BotPluginDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotPlugins to delete
     */
    where?: BotPluginWhereInput
    /**
     * Limit how many BotPlugins to delete.
     */
    limit?: number
  }

  /**
   * BotPlugin without action
   */
  export type BotPluginDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotPlugin
     */
    select?: BotPluginSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotPlugin
     */
    omit?: BotPluginOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotPluginInclude<ExtArgs> | null
  }


  /**
   * Model SkillType
   */

  export type AggregateSkillType = {
    _count: SkillTypeCountAggregateOutputType | null
    _avg: SkillTypeAvgAggregateOutputType | null
    _sum: SkillTypeSumAggregateOutputType | null
    _min: SkillTypeMinAggregateOutputType | null
    _max: SkillTypeMaxAggregateOutputType | null
  }

  export type SkillTypeAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type SkillTypeSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type SkillTypeMinAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    nameZh: string | null
    description: string | null
    descriptionZh: string | null
    icon: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SkillTypeMaxAggregateOutputType = {
    id: string | null
    slug: string | null
    name: string | null
    nameZh: string | null
    description: string | null
    descriptionZh: string | null
    icon: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SkillTypeCountAggregateOutputType = {
    id: number
    slug: number
    name: number
    nameZh: number
    description: number
    descriptionZh: number
    icon: number
    sortOrder: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SkillTypeAvgAggregateInputType = {
    sortOrder?: true
  }

  export type SkillTypeSumAggregateInputType = {
    sortOrder?: true
  }

  export type SkillTypeMinAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameZh?: true
    description?: true
    descriptionZh?: true
    icon?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SkillTypeMaxAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameZh?: true
    description?: true
    descriptionZh?: true
    icon?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SkillTypeCountAggregateInputType = {
    id?: true
    slug?: true
    name?: true
    nameZh?: true
    description?: true
    descriptionZh?: true
    icon?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SkillTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillType to aggregate.
     */
    where?: SkillTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillTypes to fetch.
     */
    orderBy?: SkillTypeOrderByWithRelationInput | SkillTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SkillTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SkillTypes
    **/
    _count?: true | SkillTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SkillTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SkillTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillTypeMaxAggregateInputType
  }

  export type GetSkillTypeAggregateType<T extends SkillTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateSkillType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkillType[P]>
      : GetScalarType<T[P], AggregateSkillType[P]>
  }




  export type SkillTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillTypeWhereInput
    orderBy?: SkillTypeOrderByWithAggregationInput | SkillTypeOrderByWithAggregationInput[]
    by: SkillTypeScalarFieldEnum[] | SkillTypeScalarFieldEnum
    having?: SkillTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillTypeCountAggregateInputType | true
    _avg?: SkillTypeAvgAggregateInputType
    _sum?: SkillTypeSumAggregateInputType
    _min?: SkillTypeMinAggregateInputType
    _max?: SkillTypeMaxAggregateInputType
  }

  export type SkillTypeGroupByOutputType = {
    id: string
    slug: string
    name: string
    nameZh: string | null
    description: string | null
    descriptionZh: string | null
    icon: string | null
    sortOrder: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SkillTypeCountAggregateOutputType | null
    _avg: SkillTypeAvgAggregateOutputType | null
    _sum: SkillTypeSumAggregateOutputType | null
    _min: SkillTypeMinAggregateOutputType | null
    _max: SkillTypeMaxAggregateOutputType | null
  }

  type GetSkillTypeGroupByPayload<T extends SkillTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillTypeGroupByOutputType[P]>
            : GetScalarType<T[P], SkillTypeGroupByOutputType[P]>
        }
      >
    >


  export type SkillTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameZh?: boolean
    description?: boolean
    descriptionZh?: boolean
    icon?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    skills?: boolean | SkillType$skillsArgs<ExtArgs>
    _count?: boolean | SkillTypeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skillType"]>

  export type SkillTypeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameZh?: boolean
    description?: boolean
    descriptionZh?: boolean
    icon?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["skillType"]>

  export type SkillTypeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    slug?: boolean
    name?: boolean
    nameZh?: boolean
    description?: boolean
    descriptionZh?: boolean
    icon?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["skillType"]>

  export type SkillTypeSelectScalar = {
    id?: boolean
    slug?: boolean
    name?: boolean
    nameZh?: boolean
    description?: boolean
    descriptionZh?: boolean
    icon?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SkillTypeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "slug" | "name" | "nameZh" | "description" | "descriptionZh" | "icon" | "sortOrder" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["skillType"]>
  export type SkillTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skills?: boolean | SkillType$skillsArgs<ExtArgs>
    _count?: boolean | SkillTypeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillTypeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type SkillTypeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $SkillTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SkillType"
    objects: {
      skills: Prisma.$SkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * ç±»å‹æ ‡è¯†ï¼ˆå¦‚ coding-agents, git-githubï¼‰
       */
      slug: string
      /**
       * è‹±æ–‡åç§°ï¼ˆå¦‚ Coding Agents & IDEsï¼‰
       */
      name: string
      /**
       * ä¸­æ–‡åç§°
       */
      nameZh: string | null
      /**
       * è‹±æ–‡æè¿°
       */
      description: string | null
      /**
       * ä¸­æ–‡æè¿°
       */
      descriptionZh: string | null
      /**
       * å›¾æ ‡ï¼ˆemoji æˆ–å›¾æ ‡åç§°ï¼‰
       */
      icon: string | null
      /**
       * æ’åºæƒé‡ï¼ˆè¶Šå°è¶Šé å‰ï¼‰
       */
      sortOrder: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["skillType"]>
    composites: {}
  }

  type SkillTypeGetPayload<S extends boolean | null | undefined | SkillTypeDefaultArgs> = $Result.GetResult<Prisma.$SkillTypePayload, S>

  type SkillTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillTypeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillTypeCountAggregateInputType | true
    }

  export interface SkillTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SkillType'], meta: { name: 'SkillType' } }
    /**
     * Find zero or one SkillType that matches the filter.
     * @param {SkillTypeFindUniqueArgs} args - Arguments to find a SkillType
     * @example
     * // Get one SkillType
     * const skillType = await prisma.skillType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillTypeFindUniqueArgs>(args: SelectSubset<T, SkillTypeFindUniqueArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SkillType that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillTypeFindUniqueOrThrowArgs} args - Arguments to find a SkillType
     * @example
     * // Get one SkillType
     * const skillType = await prisma.skillType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeFindFirstArgs} args - Arguments to find a SkillType
     * @example
     * // Get one SkillType
     * const skillType = await prisma.skillType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillTypeFindFirstArgs>(args?: SelectSubset<T, SkillTypeFindFirstArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SkillType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeFindFirstOrThrowArgs} args - Arguments to find a SkillType
     * @example
     * // Get one SkillType
     * const skillType = await prisma.skillType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SkillTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SkillTypes
     * const skillTypes = await prisma.skillType.findMany()
     * 
     * // Get first 10 SkillTypes
     * const skillTypes = await prisma.skillType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillTypeWithIdOnly = await prisma.skillType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillTypeFindManyArgs>(args?: SelectSubset<T, SkillTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SkillType.
     * @param {SkillTypeCreateArgs} args - Arguments to create a SkillType.
     * @example
     * // Create one SkillType
     * const SkillType = await prisma.skillType.create({
     *   data: {
     *     // ... data to create a SkillType
     *   }
     * })
     * 
     */
    create<T extends SkillTypeCreateArgs>(args: SelectSubset<T, SkillTypeCreateArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SkillTypes.
     * @param {SkillTypeCreateManyArgs} args - Arguments to create many SkillTypes.
     * @example
     * // Create many SkillTypes
     * const skillType = await prisma.skillType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillTypeCreateManyArgs>(args?: SelectSubset<T, SkillTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SkillTypes and returns the data saved in the database.
     * @param {SkillTypeCreateManyAndReturnArgs} args - Arguments to create many SkillTypes.
     * @example
     * // Create many SkillTypes
     * const skillType = await prisma.skillType.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SkillTypes and only return the `id`
     * const skillTypeWithIdOnly = await prisma.skillType.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillTypeCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillTypeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SkillType.
     * @param {SkillTypeDeleteArgs} args - Arguments to delete one SkillType.
     * @example
     * // Delete one SkillType
     * const SkillType = await prisma.skillType.delete({
     *   where: {
     *     // ... filter to delete one SkillType
     *   }
     * })
     * 
     */
    delete<T extends SkillTypeDeleteArgs>(args: SelectSubset<T, SkillTypeDeleteArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SkillType.
     * @param {SkillTypeUpdateArgs} args - Arguments to update one SkillType.
     * @example
     * // Update one SkillType
     * const skillType = await prisma.skillType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillTypeUpdateArgs>(args: SelectSubset<T, SkillTypeUpdateArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SkillTypes.
     * @param {SkillTypeDeleteManyArgs} args - Arguments to filter SkillTypes to delete.
     * @example
     * // Delete a few SkillTypes
     * const { count } = await prisma.skillType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillTypeDeleteManyArgs>(args?: SelectSubset<T, SkillTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SkillTypes
     * const skillType = await prisma.skillType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillTypeUpdateManyArgs>(args: SelectSubset<T, SkillTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SkillTypes and returns the data updated in the database.
     * @param {SkillTypeUpdateManyAndReturnArgs} args - Arguments to update many SkillTypes.
     * @example
     * // Update many SkillTypes
     * const skillType = await prisma.skillType.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SkillTypes and only return the `id`
     * const skillTypeWithIdOnly = await prisma.skillType.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillTypeUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillTypeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SkillType.
     * @param {SkillTypeUpsertArgs} args - Arguments to update or create a SkillType.
     * @example
     * // Update or create a SkillType
     * const skillType = await prisma.skillType.upsert({
     *   create: {
     *     // ... data to create a SkillType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SkillType we want to update
     *   }
     * })
     */
    upsert<T extends SkillTypeUpsertArgs>(args: SelectSubset<T, SkillTypeUpsertArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SkillTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeCountArgs} args - Arguments to filter SkillTypes to count.
     * @example
     * // Count the number of SkillTypes
     * const count = await prisma.skillType.count({
     *   where: {
     *     // ... the filter for the SkillTypes we want to count
     *   }
     * })
    **/
    count<T extends SkillTypeCountArgs>(
      args?: Subset<T, SkillTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SkillType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillTypeAggregateArgs>(args: Subset<T, SkillTypeAggregateArgs>): Prisma.PrismaPromise<GetSkillTypeAggregateType<T>>

    /**
     * Group by SkillType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillTypeGroupByArgs['orderBy'] }
        : { orderBy?: SkillTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SkillType model
   */
  readonly fields: SkillTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SkillType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skills<T extends SkillType$skillsArgs<ExtArgs> = {}>(args?: Subset<T, SkillType$skillsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SkillType model
   */
  interface SkillTypeFieldRefs {
    readonly id: FieldRef<"SkillType", 'String'>
    readonly slug: FieldRef<"SkillType", 'String'>
    readonly name: FieldRef<"SkillType", 'String'>
    readonly nameZh: FieldRef<"SkillType", 'String'>
    readonly description: FieldRef<"SkillType", 'String'>
    readonly descriptionZh: FieldRef<"SkillType", 'String'>
    readonly icon: FieldRef<"SkillType", 'String'>
    readonly sortOrder: FieldRef<"SkillType", 'Int'>
    readonly isDeleted: FieldRef<"SkillType", 'Boolean'>
    readonly createdAt: FieldRef<"SkillType", 'DateTime'>
    readonly updatedAt: FieldRef<"SkillType", 'DateTime'>
    readonly deletedAt: FieldRef<"SkillType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SkillType findUnique
   */
  export type SkillTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter, which SkillType to fetch.
     */
    where: SkillTypeWhereUniqueInput
  }

  /**
   * SkillType findUniqueOrThrow
   */
  export type SkillTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter, which SkillType to fetch.
     */
    where: SkillTypeWhereUniqueInput
  }

  /**
   * SkillType findFirst
   */
  export type SkillTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter, which SkillType to fetch.
     */
    where?: SkillTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillTypes to fetch.
     */
    orderBy?: SkillTypeOrderByWithRelationInput | SkillTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillTypes.
     */
    cursor?: SkillTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SkillTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillTypes.
     */
    distinct?: SkillTypeScalarFieldEnum | SkillTypeScalarFieldEnum[]
  }

  /**
   * SkillType findFirstOrThrow
   */
  export type SkillTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter, which SkillType to fetch.
     */
    where?: SkillTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillTypes to fetch.
     */
    orderBy?: SkillTypeOrderByWithRelationInput | SkillTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SkillTypes.
     */
    cursor?: SkillTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SkillTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SkillTypes.
     */
    distinct?: SkillTypeScalarFieldEnum | SkillTypeScalarFieldEnum[]
  }

  /**
   * SkillType findMany
   */
  export type SkillTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter, which SkillTypes to fetch.
     */
    where?: SkillTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SkillTypes to fetch.
     */
    orderBy?: SkillTypeOrderByWithRelationInput | SkillTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SkillTypes.
     */
    cursor?: SkillTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SkillTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SkillTypes.
     */
    skip?: number
    distinct?: SkillTypeScalarFieldEnum | SkillTypeScalarFieldEnum[]
  }

  /**
   * SkillType create
   */
  export type SkillTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a SkillType.
     */
    data: XOR<SkillTypeCreateInput, SkillTypeUncheckedCreateInput>
  }

  /**
   * SkillType createMany
   */
  export type SkillTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SkillTypes.
     */
    data: SkillTypeCreateManyInput | SkillTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillType createManyAndReturn
   */
  export type SkillTypeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * The data used to create many SkillTypes.
     */
    data: SkillTypeCreateManyInput | SkillTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SkillType update
   */
  export type SkillTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a SkillType.
     */
    data: XOR<SkillTypeUpdateInput, SkillTypeUncheckedUpdateInput>
    /**
     * Choose, which SkillType to update.
     */
    where: SkillTypeWhereUniqueInput
  }

  /**
   * SkillType updateMany
   */
  export type SkillTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SkillTypes.
     */
    data: XOR<SkillTypeUpdateManyMutationInput, SkillTypeUncheckedUpdateManyInput>
    /**
     * Filter which SkillTypes to update
     */
    where?: SkillTypeWhereInput
    /**
     * Limit how many SkillTypes to update.
     */
    limit?: number
  }

  /**
   * SkillType updateManyAndReturn
   */
  export type SkillTypeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * The data used to update SkillTypes.
     */
    data: XOR<SkillTypeUpdateManyMutationInput, SkillTypeUncheckedUpdateManyInput>
    /**
     * Filter which SkillTypes to update
     */
    where?: SkillTypeWhereInput
    /**
     * Limit how many SkillTypes to update.
     */
    limit?: number
  }

  /**
   * SkillType upsert
   */
  export type SkillTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the SkillType to update in case it exists.
     */
    where: SkillTypeWhereUniqueInput
    /**
     * In case the SkillType found by the `where` argument doesn't exist, create a new SkillType with this data.
     */
    create: XOR<SkillTypeCreateInput, SkillTypeUncheckedCreateInput>
    /**
     * In case the SkillType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillTypeUpdateInput, SkillTypeUncheckedUpdateInput>
  }

  /**
   * SkillType delete
   */
  export type SkillTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    /**
     * Filter which SkillType to delete.
     */
    where: SkillTypeWhereUniqueInput
  }

  /**
   * SkillType deleteMany
   */
  export type SkillTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SkillTypes to delete
     */
    where?: SkillTypeWhereInput
    /**
     * Limit how many SkillTypes to delete.
     */
    limit?: number
  }

  /**
   * SkillType.skills
   */
  export type SkillType$skillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    cursor?: SkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * SkillType without action
   */
  export type SkillTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
  }


  /**
   * Model Skill
   */

  export type AggregateSkill = {
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  export type SkillMinAggregateOutputType = {
    id: string | null
    name: string | null
    nameZh: string | null
    slug: string | null
    description: string | null
    descriptionZh: string | null
    version: string | null
    skillTypeId: string | null
    isSystem: boolean | null
    isEnabled: boolean | null
    createdById: string | null
    source: string | null
    sourceUrl: string | null
    author: string | null
    lastSyncedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SkillMaxAggregateOutputType = {
    id: string | null
    name: string | null
    nameZh: string | null
    slug: string | null
    description: string | null
    descriptionZh: string | null
    version: string | null
    skillTypeId: string | null
    isSystem: boolean | null
    isEnabled: boolean | null
    createdById: string | null
    source: string | null
    sourceUrl: string | null
    author: string | null
    lastSyncedAt: Date | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type SkillCountAggregateOutputType = {
    id: number
    name: number
    nameZh: number
    slug: number
    description: number
    descriptionZh: number
    version: number
    skillTypeId: number
    definition: number
    examples: number
    isSystem: number
    isEnabled: number
    createdById: number
    source: number
    sourceUrl: number
    author: number
    lastSyncedAt: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type SkillMinAggregateInputType = {
    id?: true
    name?: true
    nameZh?: true
    slug?: true
    description?: true
    descriptionZh?: true
    version?: true
    skillTypeId?: true
    isSystem?: true
    isEnabled?: true
    createdById?: true
    source?: true
    sourceUrl?: true
    author?: true
    lastSyncedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SkillMaxAggregateInputType = {
    id?: true
    name?: true
    nameZh?: true
    slug?: true
    description?: true
    descriptionZh?: true
    version?: true
    skillTypeId?: true
    isSystem?: true
    isEnabled?: true
    createdById?: true
    source?: true
    sourceUrl?: true
    author?: true
    lastSyncedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type SkillCountAggregateInputType = {
    id?: true
    name?: true
    nameZh?: true
    slug?: true
    description?: true
    descriptionZh?: true
    version?: true
    skillTypeId?: true
    definition?: true
    examples?: true
    isSystem?: true
    isEnabled?: true
    createdById?: true
    source?: true
    sourceUrl?: true
    author?: true
    lastSyncedAt?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type SkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skill to aggregate.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Skills
    **/
    _count?: true | SkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SkillMaxAggregateInputType
  }

  export type GetSkillAggregateType<T extends SkillAggregateArgs> = {
        [P in keyof T & keyof AggregateSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSkill[P]>
      : GetScalarType<T[P], AggregateSkill[P]>
  }




  export type SkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SkillWhereInput
    orderBy?: SkillOrderByWithAggregationInput | SkillOrderByWithAggregationInput[]
    by: SkillScalarFieldEnum[] | SkillScalarFieldEnum
    having?: SkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SkillCountAggregateInputType | true
    _min?: SkillMinAggregateInputType
    _max?: SkillMaxAggregateInputType
  }

  export type SkillGroupByOutputType = {
    id: string
    name: string
    nameZh: string | null
    slug: string
    description: string | null
    descriptionZh: string | null
    version: string
    skillTypeId: string | null
    definition: JsonValue
    examples: JsonValue | null
    isSystem: boolean
    isEnabled: boolean
    createdById: string | null
    source: string | null
    sourceUrl: string | null
    author: string | null
    lastSyncedAt: Date | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: SkillCountAggregateOutputType | null
    _min: SkillMinAggregateOutputType | null
    _max: SkillMaxAggregateOutputType | null
  }

  type GetSkillGroupByPayload<T extends SkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SkillGroupByOutputType[P]>
            : GetScalarType<T[P], SkillGroupByOutputType[P]>
        }
      >
    >


  export type SkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameZh?: boolean
    slug?: boolean
    description?: boolean
    descriptionZh?: boolean
    version?: boolean
    skillTypeId?: boolean
    definition?: boolean
    examples?: boolean
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: boolean
    source?: boolean
    sourceUrl?: boolean
    author?: boolean
    lastSyncedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
    installations?: boolean | Skill$installationsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameZh?: boolean
    slug?: boolean
    description?: boolean
    descriptionZh?: boolean
    version?: boolean
    skillTypeId?: boolean
    definition?: boolean
    examples?: boolean
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: boolean
    source?: boolean
    sourceUrl?: boolean
    author?: boolean
    lastSyncedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    nameZh?: boolean
    slug?: boolean
    description?: boolean
    descriptionZh?: boolean
    version?: boolean
    skillTypeId?: boolean
    definition?: boolean
    examples?: boolean
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: boolean
    source?: boolean
    sourceUrl?: boolean
    author?: boolean
    lastSyncedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
  }, ExtArgs["result"]["skill"]>

  export type SkillSelectScalar = {
    id?: boolean
    name?: boolean
    nameZh?: boolean
    slug?: boolean
    description?: boolean
    descriptionZh?: boolean
    version?: boolean
    skillTypeId?: boolean
    definition?: boolean
    examples?: boolean
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: boolean
    source?: boolean
    sourceUrl?: boolean
    author?: boolean
    lastSyncedAt?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type SkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "nameZh" | "slug" | "description" | "descriptionZh" | "version" | "skillTypeId" | "definition" | "examples" | "isSystem" | "isEnabled" | "createdById" | "source" | "sourceUrl" | "author" | "lastSyncedAt" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["skill"]>
  export type SkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
    installations?: boolean | Skill$installationsArgs<ExtArgs>
    _count?: boolean | SkillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
  }
  export type SkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    skillType?: boolean | Skill$skillTypeArgs<ExtArgs>
  }

  export type $SkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Skill"
    objects: {
      skillType: Prisma.$SkillTypePayload<ExtArgs> | null
      installations: Prisma.$BotSkillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      /**
       * ä¸­æ–‡åç§°ï¼ˆç¿»è¯‘è‡ª nameï¼‰
       */
      nameZh: string | null
      slug: string
      /**
       * è‹±æ–‡æè¿°ï¼ˆåŸå§‹æè¿°ï¼‰
       */
      description: string | null
      /**
       * ä¸­æ–‡æè¿°ï¼ˆç¿»è¯‘è‡ª descriptionï¼‰
       */
      descriptionZh: string | null
      version: string
      skillTypeId: string | null
      definition: Prisma.JsonValue
      examples: Prisma.JsonValue | null
      isSystem: boolean
      isEnabled: boolean
      createdById: string | null
      /**
       * å¤–éƒ¨æ¥æºæ ‡è¯†ï¼ˆå¦‚ openclaw, clawhubï¼‰
       */
      source: string | null
      /**
       * å¤–éƒ¨æ¥æº URLï¼ˆå¦‚ GitHub ä»“åº“é“¾æ¥ï¼‰
       */
      sourceUrl: string | null
      /**
       * æŠ€èƒ½ä½œè€…ï¼ˆå¤–éƒ¨æ¥æºçš„ä½œè€…ï¼‰
       */
      author: string | null
      /**
       * æœ€ååŒæ­¥æ—¶é—´
       */
      lastSyncedAt: Date | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["skill"]>
    composites: {}
  }

  type SkillGetPayload<S extends boolean | null | undefined | SkillDefaultArgs> = $Result.GetResult<Prisma.$SkillPayload, S>

  type SkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SkillCountAggregateInputType | true
    }

  export interface SkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Skill'], meta: { name: 'Skill' } }
    /**
     * Find zero or one Skill that matches the filter.
     * @param {SkillFindUniqueArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SkillFindUniqueArgs>(args: SelectSubset<T, SkillFindUniqueArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Skill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SkillFindUniqueOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SkillFindUniqueOrThrowArgs>(args: SelectSubset<T, SkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SkillFindFirstArgs>(args?: SelectSubset<T, SkillFindFirstArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Skill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindFirstOrThrowArgs} args - Arguments to find a Skill
     * @example
     * // Get one Skill
     * const skill = await prisma.skill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SkillFindFirstOrThrowArgs>(args?: SelectSubset<T, SkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Skills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Skills
     * const skills = await prisma.skill.findMany()
     * 
     * // Get first 10 Skills
     * const skills = await prisma.skill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const skillWithIdOnly = await prisma.skill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SkillFindManyArgs>(args?: SelectSubset<T, SkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Skill.
     * @param {SkillCreateArgs} args - Arguments to create a Skill.
     * @example
     * // Create one Skill
     * const Skill = await prisma.skill.create({
     *   data: {
     *     // ... data to create a Skill
     *   }
     * })
     * 
     */
    create<T extends SkillCreateArgs>(args: SelectSubset<T, SkillCreateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Skills.
     * @param {SkillCreateManyArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SkillCreateManyArgs>(args?: SelectSubset<T, SkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Skills and returns the data saved in the database.
     * @param {SkillCreateManyAndReturnArgs} args - Arguments to create many Skills.
     * @example
     * // Create many Skills
     * const skill = await prisma.skill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SkillCreateManyAndReturnArgs>(args?: SelectSubset<T, SkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Skill.
     * @param {SkillDeleteArgs} args - Arguments to delete one Skill.
     * @example
     * // Delete one Skill
     * const Skill = await prisma.skill.delete({
     *   where: {
     *     // ... filter to delete one Skill
     *   }
     * })
     * 
     */
    delete<T extends SkillDeleteArgs>(args: SelectSubset<T, SkillDeleteArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Skill.
     * @param {SkillUpdateArgs} args - Arguments to update one Skill.
     * @example
     * // Update one Skill
     * const skill = await prisma.skill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SkillUpdateArgs>(args: SelectSubset<T, SkillUpdateArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Skills.
     * @param {SkillDeleteManyArgs} args - Arguments to filter Skills to delete.
     * @example
     * // Delete a few Skills
     * const { count } = await prisma.skill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SkillDeleteManyArgs>(args?: SelectSubset<T, SkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SkillUpdateManyArgs>(args: SelectSubset<T, SkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Skills and returns the data updated in the database.
     * @param {SkillUpdateManyAndReturnArgs} args - Arguments to update many Skills.
     * @example
     * // Update many Skills
     * const skill = await prisma.skill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Skills and only return the `id`
     * const skillWithIdOnly = await prisma.skill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SkillUpdateManyAndReturnArgs>(args: SelectSubset<T, SkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Skill.
     * @param {SkillUpsertArgs} args - Arguments to update or create a Skill.
     * @example
     * // Update or create a Skill
     * const skill = await prisma.skill.upsert({
     *   create: {
     *     // ... data to create a Skill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Skill we want to update
     *   }
     * })
     */
    upsert<T extends SkillUpsertArgs>(args: SelectSubset<T, SkillUpsertArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Skills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillCountArgs} args - Arguments to filter Skills to count.
     * @example
     * // Count the number of Skills
     * const count = await prisma.skill.count({
     *   where: {
     *     // ... the filter for the Skills we want to count
     *   }
     * })
    **/
    count<T extends SkillCountArgs>(
      args?: Subset<T, SkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SkillAggregateArgs>(args: Subset<T, SkillAggregateArgs>): Prisma.PrismaPromise<GetSkillAggregateType<T>>

    /**
     * Group by Skill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SkillGroupByArgs['orderBy'] }
        : { orderBy?: SkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Skill model
   */
  readonly fields: SkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Skill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    skillType<T extends Skill$skillTypeArgs<ExtArgs> = {}>(args?: Subset<T, Skill$skillTypeArgs<ExtArgs>>): Prisma__SkillTypeClient<$Result.GetResult<Prisma.$SkillTypePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    installations<T extends Skill$installationsArgs<ExtArgs> = {}>(args?: Subset<T, Skill$installationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Skill model
   */
  interface SkillFieldRefs {
    readonly id: FieldRef<"Skill", 'String'>
    readonly name: FieldRef<"Skill", 'String'>
    readonly nameZh: FieldRef<"Skill", 'String'>
    readonly slug: FieldRef<"Skill", 'String'>
    readonly description: FieldRef<"Skill", 'String'>
    readonly descriptionZh: FieldRef<"Skill", 'String'>
    readonly version: FieldRef<"Skill", 'String'>
    readonly skillTypeId: FieldRef<"Skill", 'String'>
    readonly definition: FieldRef<"Skill", 'Json'>
    readonly examples: FieldRef<"Skill", 'Json'>
    readonly isSystem: FieldRef<"Skill", 'Boolean'>
    readonly isEnabled: FieldRef<"Skill", 'Boolean'>
    readonly createdById: FieldRef<"Skill", 'String'>
    readonly source: FieldRef<"Skill", 'String'>
    readonly sourceUrl: FieldRef<"Skill", 'String'>
    readonly author: FieldRef<"Skill", 'String'>
    readonly lastSyncedAt: FieldRef<"Skill", 'DateTime'>
    readonly isDeleted: FieldRef<"Skill", 'Boolean'>
    readonly createdAt: FieldRef<"Skill", 'DateTime'>
    readonly updatedAt: FieldRef<"Skill", 'DateTime'>
    readonly deletedAt: FieldRef<"Skill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Skill findUnique
   */
  export type SkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findUniqueOrThrow
   */
  export type SkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill findFirst
   */
  export type SkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findFirstOrThrow
   */
  export type SkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skill to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Skills.
     */
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill findMany
   */
  export type SkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter, which Skills to fetch.
     */
    where?: SkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Skills to fetch.
     */
    orderBy?: SkillOrderByWithRelationInput | SkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Skills.
     */
    cursor?: SkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Skills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Skills.
     */
    skip?: number
    distinct?: SkillScalarFieldEnum | SkillScalarFieldEnum[]
  }

  /**
   * Skill create
   */
  export type SkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to create a Skill.
     */
    data: XOR<SkillCreateInput, SkillUncheckedCreateInput>
  }

  /**
   * Skill createMany
   */
  export type SkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Skill createManyAndReturn
   */
  export type SkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to create many Skills.
     */
    data: SkillCreateManyInput | SkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill update
   */
  export type SkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The data needed to update a Skill.
     */
    data: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
    /**
     * Choose, which Skill to update.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill updateMany
   */
  export type SkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
  }

  /**
   * Skill updateManyAndReturn
   */
  export type SkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * The data used to update Skills.
     */
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyInput>
    /**
     * Filter which Skills to update
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Skill upsert
   */
  export type SkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * The filter to search for the Skill to update in case it exists.
     */
    where: SkillWhereUniqueInput
    /**
     * In case the Skill found by the `where` argument doesn't exist, create a new Skill with this data.
     */
    create: XOR<SkillCreateInput, SkillUncheckedCreateInput>
    /**
     * In case the Skill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SkillUpdateInput, SkillUncheckedUpdateInput>
  }

  /**
   * Skill delete
   */
  export type SkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
    /**
     * Filter which Skill to delete.
     */
    where: SkillWhereUniqueInput
  }

  /**
   * Skill deleteMany
   */
  export type SkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Skills to delete
     */
    where?: SkillWhereInput
    /**
     * Limit how many Skills to delete.
     */
    limit?: number
  }

  /**
   * Skill.skillType
   */
  export type Skill$skillTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SkillType
     */
    select?: SkillTypeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SkillType
     */
    omit?: SkillTypeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillTypeInclude<ExtArgs> | null
    where?: SkillTypeWhereInput
  }

  /**
   * Skill.installations
   */
  export type Skill$installationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    where?: BotSkillWhereInput
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    cursor?: BotSkillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotSkillScalarFieldEnum | BotSkillScalarFieldEnum[]
  }

  /**
   * Skill without action
   */
  export type SkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Skill
     */
    select?: SkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Skill
     */
    omit?: SkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SkillInclude<ExtArgs> | null
  }


  /**
   * Model BotSkill
   */

  export type AggregateBotSkill = {
    _count: BotSkillCountAggregateOutputType | null
    _min: BotSkillMinAggregateOutputType | null
    _max: BotSkillMaxAggregateOutputType | null
  }

  export type BotSkillMinAggregateOutputType = {
    id: string | null
    botId: string | null
    skillId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotSkillMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    skillId: string | null
    isEnabled: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotSkillCountAggregateOutputType = {
    id: number
    botId: number
    skillId: number
    config: number
    isEnabled: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotSkillMinAggregateInputType = {
    id?: true
    botId?: true
    skillId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotSkillMaxAggregateInputType = {
    id?: true
    botId?: true
    skillId?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotSkillCountAggregateInputType = {
    id?: true
    botId?: true
    skillId?: true
    config?: true
    isEnabled?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotSkillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotSkill to aggregate.
     */
    where?: BotSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotSkills to fetch.
     */
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotSkills
    **/
    _count?: true | BotSkillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotSkillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotSkillMaxAggregateInputType
  }

  export type GetBotSkillAggregateType<T extends BotSkillAggregateArgs> = {
        [P in keyof T & keyof AggregateBotSkill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotSkill[P]>
      : GetScalarType<T[P], AggregateBotSkill[P]>
  }




  export type BotSkillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotSkillWhereInput
    orderBy?: BotSkillOrderByWithAggregationInput | BotSkillOrderByWithAggregationInput[]
    by: BotSkillScalarFieldEnum[] | BotSkillScalarFieldEnum
    having?: BotSkillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotSkillCountAggregateInputType | true
    _min?: BotSkillMinAggregateInputType
    _max?: BotSkillMaxAggregateInputType
  }

  export type BotSkillGroupByOutputType = {
    id: string
    botId: string
    skillId: string
    config: JsonValue | null
    isEnabled: boolean
    createdAt: Date
    updatedAt: Date
    _count: BotSkillCountAggregateOutputType | null
    _min: BotSkillMinAggregateOutputType | null
    _max: BotSkillMaxAggregateOutputType | null
  }

  type GetBotSkillGroupByPayload<T extends BotSkillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotSkillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotSkillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotSkillGroupByOutputType[P]>
            : GetScalarType<T[P], BotSkillGroupByOutputType[P]>
        }
      >
    >


  export type BotSkillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    skillId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botSkill"]>

  export type BotSkillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    skillId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botSkill"]>

  export type BotSkillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    skillId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botSkill"]>

  export type BotSkillSelectScalar = {
    id?: boolean
    botId?: boolean
    skillId?: boolean
    config?: boolean
    isEnabled?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BotSkillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "skillId" | "config" | "isEnabled" | "createdAt" | "updatedAt", ExtArgs["result"]["botSkill"]>
  export type BotSkillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type BotSkillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }
  export type BotSkillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    skill?: boolean | SkillDefaultArgs<ExtArgs>
  }

  export type $BotSkillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotSkill"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      skill: Prisma.$SkillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      skillId: string
      config: Prisma.JsonValue | null
      isEnabled: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["botSkill"]>
    composites: {}
  }

  type BotSkillGetPayload<S extends boolean | null | undefined | BotSkillDefaultArgs> = $Result.GetResult<Prisma.$BotSkillPayload, S>

  type BotSkillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotSkillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotSkillCountAggregateInputType | true
    }

  export interface BotSkillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotSkill'], meta: { name: 'BotSkill' } }
    /**
     * Find zero or one BotSkill that matches the filter.
     * @param {BotSkillFindUniqueArgs} args - Arguments to find a BotSkill
     * @example
     * // Get one BotSkill
     * const botSkill = await prisma.botSkill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotSkillFindUniqueArgs>(args: SelectSubset<T, BotSkillFindUniqueArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotSkill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotSkillFindUniqueOrThrowArgs} args - Arguments to find a BotSkill
     * @example
     * // Get one BotSkill
     * const botSkill = await prisma.botSkill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotSkillFindUniqueOrThrowArgs>(args: SelectSubset<T, BotSkillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotSkill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillFindFirstArgs} args - Arguments to find a BotSkill
     * @example
     * // Get one BotSkill
     * const botSkill = await prisma.botSkill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotSkillFindFirstArgs>(args?: SelectSubset<T, BotSkillFindFirstArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotSkill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillFindFirstOrThrowArgs} args - Arguments to find a BotSkill
     * @example
     * // Get one BotSkill
     * const botSkill = await prisma.botSkill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotSkillFindFirstOrThrowArgs>(args?: SelectSubset<T, BotSkillFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotSkills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotSkills
     * const botSkills = await prisma.botSkill.findMany()
     * 
     * // Get first 10 BotSkills
     * const botSkills = await prisma.botSkill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botSkillWithIdOnly = await prisma.botSkill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotSkillFindManyArgs>(args?: SelectSubset<T, BotSkillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotSkill.
     * @param {BotSkillCreateArgs} args - Arguments to create a BotSkill.
     * @example
     * // Create one BotSkill
     * const BotSkill = await prisma.botSkill.create({
     *   data: {
     *     // ... data to create a BotSkill
     *   }
     * })
     * 
     */
    create<T extends BotSkillCreateArgs>(args: SelectSubset<T, BotSkillCreateArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotSkills.
     * @param {BotSkillCreateManyArgs} args - Arguments to create many BotSkills.
     * @example
     * // Create many BotSkills
     * const botSkill = await prisma.botSkill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotSkillCreateManyArgs>(args?: SelectSubset<T, BotSkillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotSkills and returns the data saved in the database.
     * @param {BotSkillCreateManyAndReturnArgs} args - Arguments to create many BotSkills.
     * @example
     * // Create many BotSkills
     * const botSkill = await prisma.botSkill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotSkills and only return the `id`
     * const botSkillWithIdOnly = await prisma.botSkill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotSkillCreateManyAndReturnArgs>(args?: SelectSubset<T, BotSkillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotSkill.
     * @param {BotSkillDeleteArgs} args - Arguments to delete one BotSkill.
     * @example
     * // Delete one BotSkill
     * const BotSkill = await prisma.botSkill.delete({
     *   where: {
     *     // ... filter to delete one BotSkill
     *   }
     * })
     * 
     */
    delete<T extends BotSkillDeleteArgs>(args: SelectSubset<T, BotSkillDeleteArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotSkill.
     * @param {BotSkillUpdateArgs} args - Arguments to update one BotSkill.
     * @example
     * // Update one BotSkill
     * const botSkill = await prisma.botSkill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotSkillUpdateArgs>(args: SelectSubset<T, BotSkillUpdateArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotSkills.
     * @param {BotSkillDeleteManyArgs} args - Arguments to filter BotSkills to delete.
     * @example
     * // Delete a few BotSkills
     * const { count } = await prisma.botSkill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotSkillDeleteManyArgs>(args?: SelectSubset<T, BotSkillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotSkills
     * const botSkill = await prisma.botSkill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotSkillUpdateManyArgs>(args: SelectSubset<T, BotSkillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotSkills and returns the data updated in the database.
     * @param {BotSkillUpdateManyAndReturnArgs} args - Arguments to update many BotSkills.
     * @example
     * // Update many BotSkills
     * const botSkill = await prisma.botSkill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotSkills and only return the `id`
     * const botSkillWithIdOnly = await prisma.botSkill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotSkillUpdateManyAndReturnArgs>(args: SelectSubset<T, BotSkillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotSkill.
     * @param {BotSkillUpsertArgs} args - Arguments to update or create a BotSkill.
     * @example
     * // Update or create a BotSkill
     * const botSkill = await prisma.botSkill.upsert({
     *   create: {
     *     // ... data to create a BotSkill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotSkill we want to update
     *   }
     * })
     */
    upsert<T extends BotSkillUpsertArgs>(args: SelectSubset<T, BotSkillUpsertArgs<ExtArgs>>): Prisma__BotSkillClient<$Result.GetResult<Prisma.$BotSkillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotSkills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillCountArgs} args - Arguments to filter BotSkills to count.
     * @example
     * // Count the number of BotSkills
     * const count = await prisma.botSkill.count({
     *   where: {
     *     // ... the filter for the BotSkills we want to count
     *   }
     * })
    **/
    count<T extends BotSkillCountArgs>(
      args?: Subset<T, BotSkillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotSkillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotSkillAggregateArgs>(args: Subset<T, BotSkillAggregateArgs>): Prisma.PrismaPromise<GetBotSkillAggregateType<T>>

    /**
     * Group by BotSkill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotSkillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotSkillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotSkillGroupByArgs['orderBy'] }
        : { orderBy?: BotSkillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotSkillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotSkillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotSkill model
   */
  readonly fields: BotSkillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotSkill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotSkillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    skill<T extends SkillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SkillDefaultArgs<ExtArgs>>): Prisma__SkillClient<$Result.GetResult<Prisma.$SkillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotSkill model
   */
  interface BotSkillFieldRefs {
    readonly id: FieldRef<"BotSkill", 'String'>
    readonly botId: FieldRef<"BotSkill", 'String'>
    readonly skillId: FieldRef<"BotSkill", 'String'>
    readonly config: FieldRef<"BotSkill", 'Json'>
    readonly isEnabled: FieldRef<"BotSkill", 'Boolean'>
    readonly createdAt: FieldRef<"BotSkill", 'DateTime'>
    readonly updatedAt: FieldRef<"BotSkill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotSkill findUnique
   */
  export type BotSkillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter, which BotSkill to fetch.
     */
    where: BotSkillWhereUniqueInput
  }

  /**
   * BotSkill findUniqueOrThrow
   */
  export type BotSkillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter, which BotSkill to fetch.
     */
    where: BotSkillWhereUniqueInput
  }

  /**
   * BotSkill findFirst
   */
  export type BotSkillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter, which BotSkill to fetch.
     */
    where?: BotSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotSkills to fetch.
     */
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotSkills.
     */
    cursor?: BotSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotSkills.
     */
    distinct?: BotSkillScalarFieldEnum | BotSkillScalarFieldEnum[]
  }

  /**
   * BotSkill findFirstOrThrow
   */
  export type BotSkillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter, which BotSkill to fetch.
     */
    where?: BotSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotSkills to fetch.
     */
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotSkills.
     */
    cursor?: BotSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotSkills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotSkills.
     */
    distinct?: BotSkillScalarFieldEnum | BotSkillScalarFieldEnum[]
  }

  /**
   * BotSkill findMany
   */
  export type BotSkillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter, which BotSkills to fetch.
     */
    where?: BotSkillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotSkills to fetch.
     */
    orderBy?: BotSkillOrderByWithRelationInput | BotSkillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotSkills.
     */
    cursor?: BotSkillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotSkills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotSkills.
     */
    skip?: number
    distinct?: BotSkillScalarFieldEnum | BotSkillScalarFieldEnum[]
  }

  /**
   * BotSkill create
   */
  export type BotSkillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * The data needed to create a BotSkill.
     */
    data: XOR<BotSkillCreateInput, BotSkillUncheckedCreateInput>
  }

  /**
   * BotSkill createMany
   */
  export type BotSkillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotSkills.
     */
    data: BotSkillCreateManyInput | BotSkillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotSkill createManyAndReturn
   */
  export type BotSkillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * The data used to create many BotSkills.
     */
    data: BotSkillCreateManyInput | BotSkillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotSkill update
   */
  export type BotSkillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * The data needed to update a BotSkill.
     */
    data: XOR<BotSkillUpdateInput, BotSkillUncheckedUpdateInput>
    /**
     * Choose, which BotSkill to update.
     */
    where: BotSkillWhereUniqueInput
  }

  /**
   * BotSkill updateMany
   */
  export type BotSkillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotSkills.
     */
    data: XOR<BotSkillUpdateManyMutationInput, BotSkillUncheckedUpdateManyInput>
    /**
     * Filter which BotSkills to update
     */
    where?: BotSkillWhereInput
    /**
     * Limit how many BotSkills to update.
     */
    limit?: number
  }

  /**
   * BotSkill updateManyAndReturn
   */
  export type BotSkillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * The data used to update BotSkills.
     */
    data: XOR<BotSkillUpdateManyMutationInput, BotSkillUncheckedUpdateManyInput>
    /**
     * Filter which BotSkills to update
     */
    where?: BotSkillWhereInput
    /**
     * Limit how many BotSkills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotSkill upsert
   */
  export type BotSkillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * The filter to search for the BotSkill to update in case it exists.
     */
    where: BotSkillWhereUniqueInput
    /**
     * In case the BotSkill found by the `where` argument doesn't exist, create a new BotSkill with this data.
     */
    create: XOR<BotSkillCreateInput, BotSkillUncheckedCreateInput>
    /**
     * In case the BotSkill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotSkillUpdateInput, BotSkillUncheckedUpdateInput>
  }

  /**
   * BotSkill delete
   */
  export type BotSkillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
    /**
     * Filter which BotSkill to delete.
     */
    where: BotSkillWhereUniqueInput
  }

  /**
   * BotSkill deleteMany
   */
  export type BotSkillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotSkills to delete
     */
    where?: BotSkillWhereInput
    /**
     * Limit how many BotSkills to delete.
     */
    limit?: number
  }

  /**
   * BotSkill without action
   */
  export type BotSkillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotSkill
     */
    select?: BotSkillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotSkill
     */
    omit?: BotSkillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotSkillInclude<ExtArgs> | null
  }


  /**
   * Model ModelPricing
   */

  export type AggregateModelPricing = {
    _count: ModelPricingCountAggregateOutputType | null
    _avg: ModelPricingAvgAggregateOutputType | null
    _sum: ModelPricingSumAggregateOutputType | null
    _min: ModelPricingMinAggregateOutputType | null
    _max: ModelPricingMaxAggregateOutputType | null
  }

  export type ModelPricingAvgAggregateOutputType = {
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    cacheReadPrice: Decimal | null
    cacheWritePrice: Decimal | null
    thinkingPrice: Decimal | null
    reasoningScore: number | null
    codingScore: number | null
    creativityScore: number | null
    speedScore: number | null
    contextLength: number | null
  }

  export type ModelPricingSumAggregateOutputType = {
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    cacheReadPrice: Decimal | null
    cacheWritePrice: Decimal | null
    thinkingPrice: Decimal | null
    reasoningScore: number | null
    codingScore: number | null
    creativityScore: number | null
    speedScore: number | null
    contextLength: number | null
  }

  export type ModelPricingMinAggregateOutputType = {
    id: string | null
    model: string | null
    vendor: string | null
    displayName: string | null
    description: string | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    cacheReadPrice: Decimal | null
    cacheWritePrice: Decimal | null
    thinkingPrice: Decimal | null
    reasoningScore: number | null
    codingScore: number | null
    creativityScore: number | null
    speedScore: number | null
    contextLength: number | null
    supportsExtendedThinking: boolean | null
    supportsCacheControl: boolean | null
    supportsVision: boolean | null
    supportsFunctionCalling: boolean | null
    supportsStreaming: boolean | null
    isEnabled: boolean | null
    isDeprecated: boolean | null
    deprecationDate: Date | null
    priceUpdatedAt: Date | null
    notes: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ModelPricingMaxAggregateOutputType = {
    id: string | null
    model: string | null
    vendor: string | null
    displayName: string | null
    description: string | null
    inputPrice: Decimal | null
    outputPrice: Decimal | null
    cacheReadPrice: Decimal | null
    cacheWritePrice: Decimal | null
    thinkingPrice: Decimal | null
    reasoningScore: number | null
    codingScore: number | null
    creativityScore: number | null
    speedScore: number | null
    contextLength: number | null
    supportsExtendedThinking: boolean | null
    supportsCacheControl: boolean | null
    supportsVision: boolean | null
    supportsFunctionCalling: boolean | null
    supportsStreaming: boolean | null
    isEnabled: boolean | null
    isDeprecated: boolean | null
    deprecationDate: Date | null
    priceUpdatedAt: Date | null
    notes: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ModelPricingCountAggregateOutputType = {
    id: number
    model: number
    vendor: number
    displayName: number
    description: number
    inputPrice: number
    outputPrice: number
    cacheReadPrice: number
    cacheWritePrice: number
    thinkingPrice: number
    reasoningScore: number
    codingScore: number
    creativityScore: number
    speedScore: number
    contextLength: number
    supportsExtendedThinking: number
    supportsCacheControl: number
    supportsVision: number
    supportsFunctionCalling: number
    supportsStreaming: number
    recommendedScenarios: number
    isEnabled: number
    isDeprecated: number
    deprecationDate: number
    priceUpdatedAt: number
    notes: number
    metadata: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ModelPricingAvgAggregateInputType = {
    inputPrice?: true
    outputPrice?: true
    cacheReadPrice?: true
    cacheWritePrice?: true
    thinkingPrice?: true
    reasoningScore?: true
    codingScore?: true
    creativityScore?: true
    speedScore?: true
    contextLength?: true
  }

  export type ModelPricingSumAggregateInputType = {
    inputPrice?: true
    outputPrice?: true
    cacheReadPrice?: true
    cacheWritePrice?: true
    thinkingPrice?: true
    reasoningScore?: true
    codingScore?: true
    creativityScore?: true
    speedScore?: true
    contextLength?: true
  }

  export type ModelPricingMinAggregateInputType = {
    id?: true
    model?: true
    vendor?: true
    displayName?: true
    description?: true
    inputPrice?: true
    outputPrice?: true
    cacheReadPrice?: true
    cacheWritePrice?: true
    thinkingPrice?: true
    reasoningScore?: true
    codingScore?: true
    creativityScore?: true
    speedScore?: true
    contextLength?: true
    supportsExtendedThinking?: true
    supportsCacheControl?: true
    supportsVision?: true
    supportsFunctionCalling?: true
    supportsStreaming?: true
    isEnabled?: true
    isDeprecated?: true
    deprecationDate?: true
    priceUpdatedAt?: true
    notes?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ModelPricingMaxAggregateInputType = {
    id?: true
    model?: true
    vendor?: true
    displayName?: true
    description?: true
    inputPrice?: true
    outputPrice?: true
    cacheReadPrice?: true
    cacheWritePrice?: true
    thinkingPrice?: true
    reasoningScore?: true
    codingScore?: true
    creativityScore?: true
    speedScore?: true
    contextLength?: true
    supportsExtendedThinking?: true
    supportsCacheControl?: true
    supportsVision?: true
    supportsFunctionCalling?: true
    supportsStreaming?: true
    isEnabled?: true
    isDeprecated?: true
    deprecationDate?: true
    priceUpdatedAt?: true
    notes?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ModelPricingCountAggregateInputType = {
    id?: true
    model?: true
    vendor?: true
    displayName?: true
    description?: true
    inputPrice?: true
    outputPrice?: true
    cacheReadPrice?: true
    cacheWritePrice?: true
    thinkingPrice?: true
    reasoningScore?: true
    codingScore?: true
    creativityScore?: true
    speedScore?: true
    contextLength?: true
    supportsExtendedThinking?: true
    supportsCacheControl?: true
    supportsVision?: true
    supportsFunctionCalling?: true
    supportsStreaming?: true
    recommendedScenarios?: true
    isEnabled?: true
    isDeprecated?: true
    deprecationDate?: true
    priceUpdatedAt?: true
    notes?: true
    metadata?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ModelPricingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricing to aggregate.
     */
    where?: ModelPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricings to fetch.
     */
    orderBy?: ModelPricingOrderByWithRelationInput | ModelPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ModelPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ModelPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ModelPricings
    **/
    _count?: true | ModelPricingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ModelPricingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ModelPricingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelPricingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelPricingMaxAggregateInputType
  }

  export type GetModelPricingAggregateType<T extends ModelPricingAggregateArgs> = {
        [P in keyof T & keyof AggregateModelPricing]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModelPricing[P]>
      : GetScalarType<T[P], AggregateModelPricing[P]>
  }




  export type ModelPricingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ModelPricingWhereInput
    orderBy?: ModelPricingOrderByWithAggregationInput | ModelPricingOrderByWithAggregationInput[]
    by: ModelPricingScalarFieldEnum[] | ModelPricingScalarFieldEnum
    having?: ModelPricingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelPricingCountAggregateInputType | true
    _avg?: ModelPricingAvgAggregateInputType
    _sum?: ModelPricingSumAggregateInputType
    _min?: ModelPricingMinAggregateInputType
    _max?: ModelPricingMaxAggregateInputType
  }

  export type ModelPricingGroupByOutputType = {
    id: string
    model: string
    vendor: string
    displayName: string | null
    description: string | null
    inputPrice: Decimal
    outputPrice: Decimal
    cacheReadPrice: Decimal | null
    cacheWritePrice: Decimal | null
    thinkingPrice: Decimal | null
    reasoningScore: number
    codingScore: number
    creativityScore: number
    speedScore: number
    contextLength: number
    supportsExtendedThinking: boolean
    supportsCacheControl: boolean
    supportsVision: boolean
    supportsFunctionCalling: boolean
    supportsStreaming: boolean
    recommendedScenarios: JsonValue | null
    isEnabled: boolean
    isDeprecated: boolean
    deprecationDate: Date | null
    priceUpdatedAt: Date
    notes: string | null
    metadata: JsonValue | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ModelPricingCountAggregateOutputType | null
    _avg: ModelPricingAvgAggregateOutputType | null
    _sum: ModelPricingSumAggregateOutputType | null
    _min: ModelPricingMinAggregateOutputType | null
    _max: ModelPricingMaxAggregateOutputType | null
  }

  type GetModelPricingGroupByPayload<T extends ModelPricingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelPricingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelPricingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelPricingGroupByOutputType[P]>
            : GetScalarType<T[P], ModelPricingGroupByOutputType[P]>
        }
      >
    >


  export type ModelPricingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    vendor?: boolean
    displayName?: boolean
    description?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    cacheReadPrice?: boolean
    cacheWritePrice?: boolean
    thinkingPrice?: boolean
    reasoningScore?: boolean
    codingScore?: boolean
    creativityScore?: boolean
    speedScore?: boolean
    contextLength?: boolean
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: boolean
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: boolean
    priceUpdatedAt?: boolean
    notes?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["modelPricing"]>

  export type ModelPricingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    vendor?: boolean
    displayName?: boolean
    description?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    cacheReadPrice?: boolean
    cacheWritePrice?: boolean
    thinkingPrice?: boolean
    reasoningScore?: boolean
    codingScore?: boolean
    creativityScore?: boolean
    speedScore?: boolean
    contextLength?: boolean
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: boolean
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: boolean
    priceUpdatedAt?: boolean
    notes?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["modelPricing"]>

  export type ModelPricingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    model?: boolean
    vendor?: boolean
    displayName?: boolean
    description?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    cacheReadPrice?: boolean
    cacheWritePrice?: boolean
    thinkingPrice?: boolean
    reasoningScore?: boolean
    codingScore?: boolean
    creativityScore?: boolean
    speedScore?: boolean
    contextLength?: boolean
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: boolean
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: boolean
    priceUpdatedAt?: boolean
    notes?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["modelPricing"]>

  export type ModelPricingSelectScalar = {
    id?: boolean
    model?: boolean
    vendor?: boolean
    displayName?: boolean
    description?: boolean
    inputPrice?: boolean
    outputPrice?: boolean
    cacheReadPrice?: boolean
    cacheWritePrice?: boolean
    thinkingPrice?: boolean
    reasoningScore?: boolean
    codingScore?: boolean
    creativityScore?: boolean
    speedScore?: boolean
    contextLength?: boolean
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: boolean
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: boolean
    priceUpdatedAt?: boolean
    notes?: boolean
    metadata?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ModelPricingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "model" | "vendor" | "displayName" | "description" | "inputPrice" | "outputPrice" | "cacheReadPrice" | "cacheWritePrice" | "thinkingPrice" | "reasoningScore" | "codingScore" | "creativityScore" | "speedScore" | "contextLength" | "supportsExtendedThinking" | "supportsCacheControl" | "supportsVision" | "supportsFunctionCalling" | "supportsStreaming" | "recommendedScenarios" | "isEnabled" | "isDeprecated" | "deprecationDate" | "priceUpdatedAt" | "notes" | "metadata" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["modelPricing"]>

  export type $ModelPricingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ModelPricing"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * æ¨¡å‹åç§°ï¼ˆå¦‚ gpt-4o, claude-sonnet-4-20250514ï¼‰
       */
      model: string
      /**
       * æœåŠ¡å•†æ ‡è¯†ï¼ˆopenai, anthropic, google, deepseek ç­‰ï¼‰
       */
      vendor: string
      /**
       * æ¨¡å‹æ˜¾ç¤ºåç§°
       */
      displayName: string | null
      /**
       * æ¨¡å‹æè¿°
       */
      description: string | null
      /**
       * è¾“å…¥ token ä»·æ ¼
       */
      inputPrice: Prisma.Decimal
      /**
       * è¾“å‡º token ä»·æ ¼
       */
      outputPrice: Prisma.Decimal
      /**
       * ç¼“å­˜è¯»å–ä»·æ ¼ï¼ˆAnthropic Cache Controlï¼‰
       */
      cacheReadPrice: Prisma.Decimal | null
      /**
       * ç¼“å­˜å†™å…¥ä»·æ ¼ï¼ˆAnthropic Cache Controlï¼‰
       */
      cacheWritePrice: Prisma.Decimal | null
      /**
       * æ€è€ƒ token ä»·æ ¼ï¼ˆAnthropic Extended Thinkingï¼‰
       */
      thinkingPrice: Prisma.Decimal | null
      /**
       * æ¨ç†èƒ½åŠ›è¯„åˆ†
       */
      reasoningScore: number
      /**
       * ç¼–ç èƒ½åŠ›è¯„åˆ†
       */
      codingScore: number
      /**
       * åˆ›é€ åŠ›è¯„åˆ†
       */
      creativityScore: number
      /**
       * å“åº”é€Ÿåº¦è¯„åˆ†
       */
      speedScore: number
      /**
       * ä¸Šä¸‹æ–‡é•¿åº¦ï¼ˆK tokensï¼‰
       */
      contextLength: number
      /**
       * æ˜¯å¦æ”¯æŒ Extended Thinkingï¼ˆAnthropicï¼‰
       */
      supportsExtendedThinking: boolean
      /**
       * æ˜¯å¦æ”¯æŒ Cache Controlï¼ˆAnthropicï¼‰
       */
      supportsCacheControl: boolean
      /**
       * æ˜¯å¦æ”¯æŒè§†è§‰/å¤šæ¨¡æ€
       */
      supportsVision: boolean
      /**
       * æ˜¯å¦æ”¯æŒ Function Calling
       */
      supportsFunctionCalling: boolean
      /**
       * æ˜¯å¦æ”¯æŒæµå¼å“åº”
       */
      supportsStreaming: boolean
      /**
       * æ¨èä½¿ç”¨åœºæ™¯ï¼ˆJSON æ•°ç»„ï¼‰
       * å¦‚ ["deep-reasoning", "coding", "general-purpose"]
       */
      recommendedScenarios: Prisma.JsonValue | null
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isEnabled: boolean
      /**
       * æ˜¯å¦å·²å¼ƒç”¨
       */
      isDeprecated: boolean
      /**
       * å¼ƒç”¨æ—¥æœŸ
       */
      deprecationDate: Date | null
      /**
       * ä»·æ ¼æ›´æ–°æ—¶é—´
       */
      priceUpdatedAt: Date
      /**
       * å¤‡æ³¨
       */
      notes: string | null
      /**
       * å…¶ä»–æ‰©å±•å…ƒæ•°æ®
       */
      metadata: Prisma.JsonValue | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["modelPricing"]>
    composites: {}
  }

  type ModelPricingGetPayload<S extends boolean | null | undefined | ModelPricingDefaultArgs> = $Result.GetResult<Prisma.$ModelPricingPayload, S>

  type ModelPricingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ModelPricingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelPricingCountAggregateInputType | true
    }

  export interface ModelPricingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ModelPricing'], meta: { name: 'ModelPricing' } }
    /**
     * Find zero or one ModelPricing that matches the filter.
     * @param {ModelPricingFindUniqueArgs} args - Arguments to find a ModelPricing
     * @example
     * // Get one ModelPricing
     * const modelPricing = await prisma.modelPricing.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ModelPricingFindUniqueArgs>(args: SelectSubset<T, ModelPricingFindUniqueArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ModelPricing that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ModelPricingFindUniqueOrThrowArgs} args - Arguments to find a ModelPricing
     * @example
     * // Get one ModelPricing
     * const modelPricing = await prisma.modelPricing.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ModelPricingFindUniqueOrThrowArgs>(args: SelectSubset<T, ModelPricingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricing that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingFindFirstArgs} args - Arguments to find a ModelPricing
     * @example
     * // Get one ModelPricing
     * const modelPricing = await prisma.modelPricing.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ModelPricingFindFirstArgs>(args?: SelectSubset<T, ModelPricingFindFirstArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ModelPricing that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingFindFirstOrThrowArgs} args - Arguments to find a ModelPricing
     * @example
     * // Get one ModelPricing
     * const modelPricing = await prisma.modelPricing.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ModelPricingFindFirstOrThrowArgs>(args?: SelectSubset<T, ModelPricingFindFirstOrThrowArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ModelPricings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ModelPricings
     * const modelPricings = await prisma.modelPricing.findMany()
     * 
     * // Get first 10 ModelPricings
     * const modelPricings = await prisma.modelPricing.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelPricingWithIdOnly = await prisma.modelPricing.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ModelPricingFindManyArgs>(args?: SelectSubset<T, ModelPricingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ModelPricing.
     * @param {ModelPricingCreateArgs} args - Arguments to create a ModelPricing.
     * @example
     * // Create one ModelPricing
     * const ModelPricing = await prisma.modelPricing.create({
     *   data: {
     *     // ... data to create a ModelPricing
     *   }
     * })
     * 
     */
    create<T extends ModelPricingCreateArgs>(args: SelectSubset<T, ModelPricingCreateArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ModelPricings.
     * @param {ModelPricingCreateManyArgs} args - Arguments to create many ModelPricings.
     * @example
     * // Create many ModelPricings
     * const modelPricing = await prisma.modelPricing.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ModelPricingCreateManyArgs>(args?: SelectSubset<T, ModelPricingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ModelPricings and returns the data saved in the database.
     * @param {ModelPricingCreateManyAndReturnArgs} args - Arguments to create many ModelPricings.
     * @example
     * // Create many ModelPricings
     * const modelPricing = await prisma.modelPricing.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ModelPricings and only return the `id`
     * const modelPricingWithIdOnly = await prisma.modelPricing.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ModelPricingCreateManyAndReturnArgs>(args?: SelectSubset<T, ModelPricingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ModelPricing.
     * @param {ModelPricingDeleteArgs} args - Arguments to delete one ModelPricing.
     * @example
     * // Delete one ModelPricing
     * const ModelPricing = await prisma.modelPricing.delete({
     *   where: {
     *     // ... filter to delete one ModelPricing
     *   }
     * })
     * 
     */
    delete<T extends ModelPricingDeleteArgs>(args: SelectSubset<T, ModelPricingDeleteArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ModelPricing.
     * @param {ModelPricingUpdateArgs} args - Arguments to update one ModelPricing.
     * @example
     * // Update one ModelPricing
     * const modelPricing = await prisma.modelPricing.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ModelPricingUpdateArgs>(args: SelectSubset<T, ModelPricingUpdateArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ModelPricings.
     * @param {ModelPricingDeleteManyArgs} args - Arguments to filter ModelPricings to delete.
     * @example
     * // Delete a few ModelPricings
     * const { count } = await prisma.modelPricing.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ModelPricingDeleteManyArgs>(args?: SelectSubset<T, ModelPricingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ModelPricings
     * const modelPricing = await prisma.modelPricing.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ModelPricingUpdateManyArgs>(args: SelectSubset<T, ModelPricingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ModelPricings and returns the data updated in the database.
     * @param {ModelPricingUpdateManyAndReturnArgs} args - Arguments to update many ModelPricings.
     * @example
     * // Update many ModelPricings
     * const modelPricing = await prisma.modelPricing.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ModelPricings and only return the `id`
     * const modelPricingWithIdOnly = await prisma.modelPricing.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ModelPricingUpdateManyAndReturnArgs>(args: SelectSubset<T, ModelPricingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ModelPricing.
     * @param {ModelPricingUpsertArgs} args - Arguments to update or create a ModelPricing.
     * @example
     * // Update or create a ModelPricing
     * const modelPricing = await prisma.modelPricing.upsert({
     *   create: {
     *     // ... data to create a ModelPricing
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ModelPricing we want to update
     *   }
     * })
     */
    upsert<T extends ModelPricingUpsertArgs>(args: SelectSubset<T, ModelPricingUpsertArgs<ExtArgs>>): Prisma__ModelPricingClient<$Result.GetResult<Prisma.$ModelPricingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ModelPricings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingCountArgs} args - Arguments to filter ModelPricings to count.
     * @example
     * // Count the number of ModelPricings
     * const count = await prisma.modelPricing.count({
     *   where: {
     *     // ... the filter for the ModelPricings we want to count
     *   }
     * })
    **/
    count<T extends ModelPricingCountArgs>(
      args?: Subset<T, ModelPricingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelPricingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ModelPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelPricingAggregateArgs>(args: Subset<T, ModelPricingAggregateArgs>): Prisma.PrismaPromise<GetModelPricingAggregateType<T>>

    /**
     * Group by ModelPricing.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelPricingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ModelPricingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ModelPricingGroupByArgs['orderBy'] }
        : { orderBy?: ModelPricingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ModelPricingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelPricingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ModelPricing model
   */
  readonly fields: ModelPricingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ModelPricing.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ModelPricingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ModelPricing model
   */
  interface ModelPricingFieldRefs {
    readonly id: FieldRef<"ModelPricing", 'String'>
    readonly model: FieldRef<"ModelPricing", 'String'>
    readonly vendor: FieldRef<"ModelPricing", 'String'>
    readonly displayName: FieldRef<"ModelPricing", 'String'>
    readonly description: FieldRef<"ModelPricing", 'String'>
    readonly inputPrice: FieldRef<"ModelPricing", 'Decimal'>
    readonly outputPrice: FieldRef<"ModelPricing", 'Decimal'>
    readonly cacheReadPrice: FieldRef<"ModelPricing", 'Decimal'>
    readonly cacheWritePrice: FieldRef<"ModelPricing", 'Decimal'>
    readonly thinkingPrice: FieldRef<"ModelPricing", 'Decimal'>
    readonly reasoningScore: FieldRef<"ModelPricing", 'Int'>
    readonly codingScore: FieldRef<"ModelPricing", 'Int'>
    readonly creativityScore: FieldRef<"ModelPricing", 'Int'>
    readonly speedScore: FieldRef<"ModelPricing", 'Int'>
    readonly contextLength: FieldRef<"ModelPricing", 'Int'>
    readonly supportsExtendedThinking: FieldRef<"ModelPricing", 'Boolean'>
    readonly supportsCacheControl: FieldRef<"ModelPricing", 'Boolean'>
    readonly supportsVision: FieldRef<"ModelPricing", 'Boolean'>
    readonly supportsFunctionCalling: FieldRef<"ModelPricing", 'Boolean'>
    readonly supportsStreaming: FieldRef<"ModelPricing", 'Boolean'>
    readonly recommendedScenarios: FieldRef<"ModelPricing", 'Json'>
    readonly isEnabled: FieldRef<"ModelPricing", 'Boolean'>
    readonly isDeprecated: FieldRef<"ModelPricing", 'Boolean'>
    readonly deprecationDate: FieldRef<"ModelPricing", 'DateTime'>
    readonly priceUpdatedAt: FieldRef<"ModelPricing", 'DateTime'>
    readonly notes: FieldRef<"ModelPricing", 'String'>
    readonly metadata: FieldRef<"ModelPricing", 'Json'>
    readonly isDeleted: FieldRef<"ModelPricing", 'Boolean'>
    readonly createdAt: FieldRef<"ModelPricing", 'DateTime'>
    readonly updatedAt: FieldRef<"ModelPricing", 'DateTime'>
    readonly deletedAt: FieldRef<"ModelPricing", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ModelPricing findUnique
   */
  export type ModelPricingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricing to fetch.
     */
    where: ModelPricingWhereUniqueInput
  }

  /**
   * ModelPricing findUniqueOrThrow
   */
  export type ModelPricingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricing to fetch.
     */
    where: ModelPricingWhereUniqueInput
  }

  /**
   * ModelPricing findFirst
   */
  export type ModelPricingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricing to fetch.
     */
    where?: ModelPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricings to fetch.
     */
    orderBy?: ModelPricingOrderByWithRelationInput | ModelPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricings.
     */
    cursor?: ModelPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ModelPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricings.
     */
    distinct?: ModelPricingScalarFieldEnum | ModelPricingScalarFieldEnum[]
  }

  /**
   * ModelPricing findFirstOrThrow
   */
  export type ModelPricingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricing to fetch.
     */
    where?: ModelPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricings to fetch.
     */
    orderBy?: ModelPricingOrderByWithRelationInput | ModelPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ModelPricings.
     */
    cursor?: ModelPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ModelPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ModelPricings.
     */
    distinct?: ModelPricingScalarFieldEnum | ModelPricingScalarFieldEnum[]
  }

  /**
   * ModelPricing findMany
   */
  export type ModelPricingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter, which ModelPricings to fetch.
     */
    where?: ModelPricingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ModelPricings to fetch.
     */
    orderBy?: ModelPricingOrderByWithRelationInput | ModelPricingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ModelPricings.
     */
    cursor?: ModelPricingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ModelPricings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ModelPricings.
     */
    skip?: number
    distinct?: ModelPricingScalarFieldEnum | ModelPricingScalarFieldEnum[]
  }

  /**
   * ModelPricing create
   */
  export type ModelPricingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * The data needed to create a ModelPricing.
     */
    data: XOR<ModelPricingCreateInput, ModelPricingUncheckedCreateInput>
  }

  /**
   * ModelPricing createMany
   */
  export type ModelPricingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ModelPricings.
     */
    data: ModelPricingCreateManyInput | ModelPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricing createManyAndReturn
   */
  export type ModelPricingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * The data used to create many ModelPricings.
     */
    data: ModelPricingCreateManyInput | ModelPricingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ModelPricing update
   */
  export type ModelPricingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * The data needed to update a ModelPricing.
     */
    data: XOR<ModelPricingUpdateInput, ModelPricingUncheckedUpdateInput>
    /**
     * Choose, which ModelPricing to update.
     */
    where: ModelPricingWhereUniqueInput
  }

  /**
   * ModelPricing updateMany
   */
  export type ModelPricingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ModelPricings.
     */
    data: XOR<ModelPricingUpdateManyMutationInput, ModelPricingUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricings to update
     */
    where?: ModelPricingWhereInput
    /**
     * Limit how many ModelPricings to update.
     */
    limit?: number
  }

  /**
   * ModelPricing updateManyAndReturn
   */
  export type ModelPricingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * The data used to update ModelPricings.
     */
    data: XOR<ModelPricingUpdateManyMutationInput, ModelPricingUncheckedUpdateManyInput>
    /**
     * Filter which ModelPricings to update
     */
    where?: ModelPricingWhereInput
    /**
     * Limit how many ModelPricings to update.
     */
    limit?: number
  }

  /**
   * ModelPricing upsert
   */
  export type ModelPricingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * The filter to search for the ModelPricing to update in case it exists.
     */
    where: ModelPricingWhereUniqueInput
    /**
     * In case the ModelPricing found by the `where` argument doesn't exist, create a new ModelPricing with this data.
     */
    create: XOR<ModelPricingCreateInput, ModelPricingUncheckedCreateInput>
    /**
     * In case the ModelPricing was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ModelPricingUpdateInput, ModelPricingUncheckedUpdateInput>
  }

  /**
   * ModelPricing delete
   */
  export type ModelPricingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
    /**
     * Filter which ModelPricing to delete.
     */
    where: ModelPricingWhereUniqueInput
  }

  /**
   * ModelPricing deleteMany
   */
  export type ModelPricingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ModelPricings to delete
     */
    where?: ModelPricingWhereInput
    /**
     * Limit how many ModelPricings to delete.
     */
    limit?: number
  }

  /**
   * ModelPricing without action
   */
  export type ModelPricingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelPricing
     */
    select?: ModelPricingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ModelPricing
     */
    omit?: ModelPricingOmit<ExtArgs> | null
  }


  /**
   * Model BotModelRouting
   */

  export type AggregateBotModelRouting = {
    _count: BotModelRoutingCountAggregateOutputType | null
    _avg: BotModelRoutingAvgAggregateOutputType | null
    _sum: BotModelRoutingSumAggregateOutputType | null
    _min: BotModelRoutingMinAggregateOutputType | null
    _max: BotModelRoutingMaxAggregateOutputType | null
  }

  export type BotModelRoutingAvgAggregateOutputType = {
    priority: number | null
  }

  export type BotModelRoutingSumAggregateOutputType = {
    priority: number | null
  }

  export type BotModelRoutingMinAggregateOutputType = {
    id: string | null
    botId: string | null
    routingType: $Enums.ModelRoutingType | null
    name: string | null
    priority: number | null
    isEnabled: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotModelRoutingMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    routingType: $Enums.ModelRoutingType | null
    name: string | null
    priority: number | null
    isEnabled: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotModelRoutingCountAggregateOutputType = {
    id: number
    botId: number
    routingType: number
    name: number
    config: number
    priority: number
    isEnabled: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BotModelRoutingAvgAggregateInputType = {
    priority?: true
  }

  export type BotModelRoutingSumAggregateInputType = {
    priority?: true
  }

  export type BotModelRoutingMinAggregateInputType = {
    id?: true
    botId?: true
    routingType?: true
    name?: true
    priority?: true
    isEnabled?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotModelRoutingMaxAggregateInputType = {
    id?: true
    botId?: true
    routingType?: true
    name?: true
    priority?: true
    isEnabled?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotModelRoutingCountAggregateInputType = {
    id?: true
    botId?: true
    routingType?: true
    name?: true
    config?: true
    priority?: true
    isEnabled?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BotModelRoutingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotModelRouting to aggregate.
     */
    where?: BotModelRoutingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotModelRoutings to fetch.
     */
    orderBy?: BotModelRoutingOrderByWithRelationInput | BotModelRoutingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotModelRoutingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotModelRoutings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotModelRoutings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotModelRoutings
    **/
    _count?: true | BotModelRoutingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotModelRoutingAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotModelRoutingSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotModelRoutingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotModelRoutingMaxAggregateInputType
  }

  export type GetBotModelRoutingAggregateType<T extends BotModelRoutingAggregateArgs> = {
        [P in keyof T & keyof AggregateBotModelRouting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotModelRouting[P]>
      : GetScalarType<T[P], AggregateBotModelRouting[P]>
  }




  export type BotModelRoutingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotModelRoutingWhereInput
    orderBy?: BotModelRoutingOrderByWithAggregationInput | BotModelRoutingOrderByWithAggregationInput[]
    by: BotModelRoutingScalarFieldEnum[] | BotModelRoutingScalarFieldEnum
    having?: BotModelRoutingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotModelRoutingCountAggregateInputType | true
    _avg?: BotModelRoutingAvgAggregateInputType
    _sum?: BotModelRoutingSumAggregateInputType
    _min?: BotModelRoutingMinAggregateInputType
    _max?: BotModelRoutingMaxAggregateInputType
  }

  export type BotModelRoutingGroupByOutputType = {
    id: string
    botId: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonValue
    priority: number
    isEnabled: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BotModelRoutingCountAggregateOutputType | null
    _avg: BotModelRoutingAvgAggregateOutputType | null
    _sum: BotModelRoutingSumAggregateOutputType | null
    _min: BotModelRoutingMinAggregateOutputType | null
    _max: BotModelRoutingMaxAggregateOutputType | null
  }

  type GetBotModelRoutingGroupByPayload<T extends BotModelRoutingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotModelRoutingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotModelRoutingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotModelRoutingGroupByOutputType[P]>
            : GetScalarType<T[P], BotModelRoutingGroupByOutputType[P]>
        }
      >
    >


  export type BotModelRoutingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingType?: boolean
    name?: boolean
    config?: boolean
    priority?: boolean
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botModelRouting"]>

  export type BotModelRoutingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingType?: boolean
    name?: boolean
    config?: boolean
    priority?: boolean
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botModelRouting"]>

  export type BotModelRoutingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingType?: boolean
    name?: boolean
    config?: boolean
    priority?: boolean
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botModelRouting"]>

  export type BotModelRoutingSelectScalar = {
    id?: boolean
    botId?: boolean
    routingType?: boolean
    name?: boolean
    config?: boolean
    priority?: boolean
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BotModelRoutingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "routingType" | "name" | "config" | "priority" | "isEnabled" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["botModelRouting"]>
  export type BotModelRoutingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotModelRoutingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotModelRoutingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }

  export type $BotModelRoutingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotModelRouting"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      /**
       * è·¯ç”±ç±»å‹
       */
      routingType: $Enums.ModelRoutingType
      /**
       * è·¯ç”±åç§°ï¼ˆç”¨äºæ ‡è¯†ï¼‰
       */
      name: string
      /**
       * è·¯ç”±é…ç½® (JSON)
       * åŠŸèƒ½è·¯ç”±: { rules: [...], defaultTarget: {...} }
       * è´Ÿè½½å‡è¡¡: { strategy: "round_robin"|"weighted"|"least_latency", targets: [...] }
       * æ•…éšœè½¬ç§»: { primary: {...}, fallbackChain: [...], retry: {...} }
       */
      config: Prisma.JsonValue
      /**
       * ä¼˜å…ˆçº§ï¼ˆæ•°å­—è¶Šå°ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
       */
      priority: number
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isEnabled: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["botModelRouting"]>
    composites: {}
  }

  type BotModelRoutingGetPayload<S extends boolean | null | undefined | BotModelRoutingDefaultArgs> = $Result.GetResult<Prisma.$BotModelRoutingPayload, S>

  type BotModelRoutingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotModelRoutingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotModelRoutingCountAggregateInputType | true
    }

  export interface BotModelRoutingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotModelRouting'], meta: { name: 'BotModelRouting' } }
    /**
     * Find zero or one BotModelRouting that matches the filter.
     * @param {BotModelRoutingFindUniqueArgs} args - Arguments to find a BotModelRouting
     * @example
     * // Get one BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotModelRoutingFindUniqueArgs>(args: SelectSubset<T, BotModelRoutingFindUniqueArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotModelRouting that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotModelRoutingFindUniqueOrThrowArgs} args - Arguments to find a BotModelRouting
     * @example
     * // Get one BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotModelRoutingFindUniqueOrThrowArgs>(args: SelectSubset<T, BotModelRoutingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotModelRouting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingFindFirstArgs} args - Arguments to find a BotModelRouting
     * @example
     * // Get one BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotModelRoutingFindFirstArgs>(args?: SelectSubset<T, BotModelRoutingFindFirstArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotModelRouting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingFindFirstOrThrowArgs} args - Arguments to find a BotModelRouting
     * @example
     * // Get one BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotModelRoutingFindFirstOrThrowArgs>(args?: SelectSubset<T, BotModelRoutingFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotModelRoutings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotModelRoutings
     * const botModelRoutings = await prisma.botModelRouting.findMany()
     * 
     * // Get first 10 BotModelRoutings
     * const botModelRoutings = await prisma.botModelRouting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botModelRoutingWithIdOnly = await prisma.botModelRouting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotModelRoutingFindManyArgs>(args?: SelectSubset<T, BotModelRoutingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotModelRouting.
     * @param {BotModelRoutingCreateArgs} args - Arguments to create a BotModelRouting.
     * @example
     * // Create one BotModelRouting
     * const BotModelRouting = await prisma.botModelRouting.create({
     *   data: {
     *     // ... data to create a BotModelRouting
     *   }
     * })
     * 
     */
    create<T extends BotModelRoutingCreateArgs>(args: SelectSubset<T, BotModelRoutingCreateArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotModelRoutings.
     * @param {BotModelRoutingCreateManyArgs} args - Arguments to create many BotModelRoutings.
     * @example
     * // Create many BotModelRoutings
     * const botModelRouting = await prisma.botModelRouting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotModelRoutingCreateManyArgs>(args?: SelectSubset<T, BotModelRoutingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotModelRoutings and returns the data saved in the database.
     * @param {BotModelRoutingCreateManyAndReturnArgs} args - Arguments to create many BotModelRoutings.
     * @example
     * // Create many BotModelRoutings
     * const botModelRouting = await prisma.botModelRouting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotModelRoutings and only return the `id`
     * const botModelRoutingWithIdOnly = await prisma.botModelRouting.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotModelRoutingCreateManyAndReturnArgs>(args?: SelectSubset<T, BotModelRoutingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotModelRouting.
     * @param {BotModelRoutingDeleteArgs} args - Arguments to delete one BotModelRouting.
     * @example
     * // Delete one BotModelRouting
     * const BotModelRouting = await prisma.botModelRouting.delete({
     *   where: {
     *     // ... filter to delete one BotModelRouting
     *   }
     * })
     * 
     */
    delete<T extends BotModelRoutingDeleteArgs>(args: SelectSubset<T, BotModelRoutingDeleteArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotModelRouting.
     * @param {BotModelRoutingUpdateArgs} args - Arguments to update one BotModelRouting.
     * @example
     * // Update one BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotModelRoutingUpdateArgs>(args: SelectSubset<T, BotModelRoutingUpdateArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotModelRoutings.
     * @param {BotModelRoutingDeleteManyArgs} args - Arguments to filter BotModelRoutings to delete.
     * @example
     * // Delete a few BotModelRoutings
     * const { count } = await prisma.botModelRouting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotModelRoutingDeleteManyArgs>(args?: SelectSubset<T, BotModelRoutingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotModelRoutings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotModelRoutings
     * const botModelRouting = await prisma.botModelRouting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotModelRoutingUpdateManyArgs>(args: SelectSubset<T, BotModelRoutingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotModelRoutings and returns the data updated in the database.
     * @param {BotModelRoutingUpdateManyAndReturnArgs} args - Arguments to update many BotModelRoutings.
     * @example
     * // Update many BotModelRoutings
     * const botModelRouting = await prisma.botModelRouting.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotModelRoutings and only return the `id`
     * const botModelRoutingWithIdOnly = await prisma.botModelRouting.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotModelRoutingUpdateManyAndReturnArgs>(args: SelectSubset<T, BotModelRoutingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotModelRouting.
     * @param {BotModelRoutingUpsertArgs} args - Arguments to update or create a BotModelRouting.
     * @example
     * // Update or create a BotModelRouting
     * const botModelRouting = await prisma.botModelRouting.upsert({
     *   create: {
     *     // ... data to create a BotModelRouting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotModelRouting we want to update
     *   }
     * })
     */
    upsert<T extends BotModelRoutingUpsertArgs>(args: SelectSubset<T, BotModelRoutingUpsertArgs<ExtArgs>>): Prisma__BotModelRoutingClient<$Result.GetResult<Prisma.$BotModelRoutingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotModelRoutings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingCountArgs} args - Arguments to filter BotModelRoutings to count.
     * @example
     * // Count the number of BotModelRoutings
     * const count = await prisma.botModelRouting.count({
     *   where: {
     *     // ... the filter for the BotModelRoutings we want to count
     *   }
     * })
    **/
    count<T extends BotModelRoutingCountArgs>(
      args?: Subset<T, BotModelRoutingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotModelRoutingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotModelRouting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotModelRoutingAggregateArgs>(args: Subset<T, BotModelRoutingAggregateArgs>): Prisma.PrismaPromise<GetBotModelRoutingAggregateType<T>>

    /**
     * Group by BotModelRouting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotModelRoutingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotModelRoutingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotModelRoutingGroupByArgs['orderBy'] }
        : { orderBy?: BotModelRoutingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotModelRoutingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotModelRoutingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotModelRouting model
   */
  readonly fields: BotModelRoutingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotModelRouting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotModelRoutingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotModelRouting model
   */
  interface BotModelRoutingFieldRefs {
    readonly id: FieldRef<"BotModelRouting", 'String'>
    readonly botId: FieldRef<"BotModelRouting", 'String'>
    readonly routingType: FieldRef<"BotModelRouting", 'ModelRoutingType'>
    readonly name: FieldRef<"BotModelRouting", 'String'>
    readonly config: FieldRef<"BotModelRouting", 'Json'>
    readonly priority: FieldRef<"BotModelRouting", 'Int'>
    readonly isEnabled: FieldRef<"BotModelRouting", 'Boolean'>
    readonly isDeleted: FieldRef<"BotModelRouting", 'Boolean'>
    readonly createdAt: FieldRef<"BotModelRouting", 'DateTime'>
    readonly updatedAt: FieldRef<"BotModelRouting", 'DateTime'>
    readonly deletedAt: FieldRef<"BotModelRouting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotModelRouting findUnique
   */
  export type BotModelRoutingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter, which BotModelRouting to fetch.
     */
    where: BotModelRoutingWhereUniqueInput
  }

  /**
   * BotModelRouting findUniqueOrThrow
   */
  export type BotModelRoutingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter, which BotModelRouting to fetch.
     */
    where: BotModelRoutingWhereUniqueInput
  }

  /**
   * BotModelRouting findFirst
   */
  export type BotModelRoutingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter, which BotModelRouting to fetch.
     */
    where?: BotModelRoutingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotModelRoutings to fetch.
     */
    orderBy?: BotModelRoutingOrderByWithRelationInput | BotModelRoutingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotModelRoutings.
     */
    cursor?: BotModelRoutingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotModelRoutings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotModelRoutings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotModelRoutings.
     */
    distinct?: BotModelRoutingScalarFieldEnum | BotModelRoutingScalarFieldEnum[]
  }

  /**
   * BotModelRouting findFirstOrThrow
   */
  export type BotModelRoutingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter, which BotModelRouting to fetch.
     */
    where?: BotModelRoutingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotModelRoutings to fetch.
     */
    orderBy?: BotModelRoutingOrderByWithRelationInput | BotModelRoutingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotModelRoutings.
     */
    cursor?: BotModelRoutingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotModelRoutings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotModelRoutings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotModelRoutings.
     */
    distinct?: BotModelRoutingScalarFieldEnum | BotModelRoutingScalarFieldEnum[]
  }

  /**
   * BotModelRouting findMany
   */
  export type BotModelRoutingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter, which BotModelRoutings to fetch.
     */
    where?: BotModelRoutingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotModelRoutings to fetch.
     */
    orderBy?: BotModelRoutingOrderByWithRelationInput | BotModelRoutingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotModelRoutings.
     */
    cursor?: BotModelRoutingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotModelRoutings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotModelRoutings.
     */
    skip?: number
    distinct?: BotModelRoutingScalarFieldEnum | BotModelRoutingScalarFieldEnum[]
  }

  /**
   * BotModelRouting create
   */
  export type BotModelRoutingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * The data needed to create a BotModelRouting.
     */
    data: XOR<BotModelRoutingCreateInput, BotModelRoutingUncheckedCreateInput>
  }

  /**
   * BotModelRouting createMany
   */
  export type BotModelRoutingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotModelRoutings.
     */
    data: BotModelRoutingCreateManyInput | BotModelRoutingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotModelRouting createManyAndReturn
   */
  export type BotModelRoutingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * The data used to create many BotModelRoutings.
     */
    data: BotModelRoutingCreateManyInput | BotModelRoutingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotModelRouting update
   */
  export type BotModelRoutingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * The data needed to update a BotModelRouting.
     */
    data: XOR<BotModelRoutingUpdateInput, BotModelRoutingUncheckedUpdateInput>
    /**
     * Choose, which BotModelRouting to update.
     */
    where: BotModelRoutingWhereUniqueInput
  }

  /**
   * BotModelRouting updateMany
   */
  export type BotModelRoutingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotModelRoutings.
     */
    data: XOR<BotModelRoutingUpdateManyMutationInput, BotModelRoutingUncheckedUpdateManyInput>
    /**
     * Filter which BotModelRoutings to update
     */
    where?: BotModelRoutingWhereInput
    /**
     * Limit how many BotModelRoutings to update.
     */
    limit?: number
  }

  /**
   * BotModelRouting updateManyAndReturn
   */
  export type BotModelRoutingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * The data used to update BotModelRoutings.
     */
    data: XOR<BotModelRoutingUpdateManyMutationInput, BotModelRoutingUncheckedUpdateManyInput>
    /**
     * Filter which BotModelRoutings to update
     */
    where?: BotModelRoutingWhereInput
    /**
     * Limit how many BotModelRoutings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotModelRouting upsert
   */
  export type BotModelRoutingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * The filter to search for the BotModelRouting to update in case it exists.
     */
    where: BotModelRoutingWhereUniqueInput
    /**
     * In case the BotModelRouting found by the `where` argument doesn't exist, create a new BotModelRouting with this data.
     */
    create: XOR<BotModelRoutingCreateInput, BotModelRoutingUncheckedCreateInput>
    /**
     * In case the BotModelRouting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotModelRoutingUpdateInput, BotModelRoutingUncheckedUpdateInput>
  }

  /**
   * BotModelRouting delete
   */
  export type BotModelRoutingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
    /**
     * Filter which BotModelRouting to delete.
     */
    where: BotModelRoutingWhereUniqueInput
  }

  /**
   * BotModelRouting deleteMany
   */
  export type BotModelRoutingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotModelRoutings to delete
     */
    where?: BotModelRoutingWhereInput
    /**
     * Limit how many BotModelRoutings to delete.
     */
    limit?: number
  }

  /**
   * BotModelRouting without action
   */
  export type BotModelRoutingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotModelRouting
     */
    select?: BotModelRoutingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotModelRouting
     */
    omit?: BotModelRoutingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotModelRoutingInclude<ExtArgs> | null
  }


  /**
   * Model BotChannel
   */

  export type AggregateBotChannel = {
    _count: BotChannelCountAggregateOutputType | null
    _min: BotChannelMinAggregateOutputType | null
    _max: BotChannelMaxAggregateOutputType | null
  }

  export type BotChannelMinAggregateOutputType = {
    id: string | null
    botId: string | null
    channelType: string | null
    name: string | null
    credentialsEncrypted: Bytes | null
    isEnabled: boolean | null
    connectionStatus: $Enums.ChannelConnectionStatus | null
    lastConnectedAt: Date | null
    lastError: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotChannelMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    channelType: string | null
    name: string | null
    credentialsEncrypted: Bytes | null
    isEnabled: boolean | null
    connectionStatus: $Enums.ChannelConnectionStatus | null
    lastConnectedAt: Date | null
    lastError: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotChannelCountAggregateOutputType = {
    id: number
    botId: number
    channelType: number
    name: number
    credentialsEncrypted: number
    config: number
    isEnabled: number
    connectionStatus: number
    lastConnectedAt: number
    lastError: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BotChannelMinAggregateInputType = {
    id?: true
    botId?: true
    channelType?: true
    name?: true
    credentialsEncrypted?: true
    isEnabled?: true
    connectionStatus?: true
    lastConnectedAt?: true
    lastError?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotChannelMaxAggregateInputType = {
    id?: true
    botId?: true
    channelType?: true
    name?: true
    credentialsEncrypted?: true
    isEnabled?: true
    connectionStatus?: true
    lastConnectedAt?: true
    lastError?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotChannelCountAggregateInputType = {
    id?: true
    botId?: true
    channelType?: true
    name?: true
    credentialsEncrypted?: true
    config?: true
    isEnabled?: true
    connectionStatus?: true
    lastConnectedAt?: true
    lastError?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BotChannelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotChannel to aggregate.
     */
    where?: BotChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotChannels to fetch.
     */
    orderBy?: BotChannelOrderByWithRelationInput | BotChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotChannels
    **/
    _count?: true | BotChannelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotChannelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotChannelMaxAggregateInputType
  }

  export type GetBotChannelAggregateType<T extends BotChannelAggregateArgs> = {
        [P in keyof T & keyof AggregateBotChannel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotChannel[P]>
      : GetScalarType<T[P], AggregateBotChannel[P]>
  }




  export type BotChannelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotChannelWhereInput
    orderBy?: BotChannelOrderByWithAggregationInput | BotChannelOrderByWithAggregationInput[]
    by: BotChannelScalarFieldEnum[] | BotChannelScalarFieldEnum
    having?: BotChannelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotChannelCountAggregateInputType | true
    _min?: BotChannelMinAggregateInputType
    _max?: BotChannelMaxAggregateInputType
  }

  export type BotChannelGroupByOutputType = {
    id: string
    botId: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config: JsonValue | null
    isEnabled: boolean
    connectionStatus: $Enums.ChannelConnectionStatus
    lastConnectedAt: Date | null
    lastError: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BotChannelCountAggregateOutputType | null
    _min: BotChannelMinAggregateOutputType | null
    _max: BotChannelMaxAggregateOutputType | null
  }

  type GetBotChannelGroupByPayload<T extends BotChannelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotChannelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotChannelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotChannelGroupByOutputType[P]>
            : GetScalarType<T[P], BotChannelGroupByOutputType[P]>
        }
      >
    >


  export type BotChannelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    channelType?: boolean
    name?: boolean
    credentialsEncrypted?: boolean
    config?: boolean
    isEnabled?: boolean
    connectionStatus?: boolean
    lastConnectedAt?: boolean
    lastError?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botChannel"]>

  export type BotChannelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    channelType?: boolean
    name?: boolean
    credentialsEncrypted?: boolean
    config?: boolean
    isEnabled?: boolean
    connectionStatus?: boolean
    lastConnectedAt?: boolean
    lastError?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botChannel"]>

  export type BotChannelSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    channelType?: boolean
    name?: boolean
    credentialsEncrypted?: boolean
    config?: boolean
    isEnabled?: boolean
    connectionStatus?: boolean
    lastConnectedAt?: boolean
    lastError?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botChannel"]>

  export type BotChannelSelectScalar = {
    id?: boolean
    botId?: boolean
    channelType?: boolean
    name?: boolean
    credentialsEncrypted?: boolean
    config?: boolean
    isEnabled?: boolean
    connectionStatus?: boolean
    lastConnectedAt?: boolean
    lastError?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BotChannelOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "channelType" | "name" | "credentialsEncrypted" | "config" | "isEnabled" | "connectionStatus" | "lastConnectedAt" | "lastError" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["botChannel"]>
  export type BotChannelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotChannelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotChannelIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }

  export type $BotChannelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotChannel"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      channelType: string
      name: string
      credentialsEncrypted: Prisma.Bytes
      config: Prisma.JsonValue | null
      isEnabled: boolean
      connectionStatus: $Enums.ChannelConnectionStatus
      lastConnectedAt: Date | null
      lastError: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["botChannel"]>
    composites: {}
  }

  type BotChannelGetPayload<S extends boolean | null | undefined | BotChannelDefaultArgs> = $Result.GetResult<Prisma.$BotChannelPayload, S>

  type BotChannelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotChannelFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotChannelCountAggregateInputType | true
    }

  export interface BotChannelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotChannel'], meta: { name: 'BotChannel' } }
    /**
     * Find zero or one BotChannel that matches the filter.
     * @param {BotChannelFindUniqueArgs} args - Arguments to find a BotChannel
     * @example
     * // Get one BotChannel
     * const botChannel = await prisma.botChannel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotChannelFindUniqueArgs>(args: SelectSubset<T, BotChannelFindUniqueArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotChannel that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotChannelFindUniqueOrThrowArgs} args - Arguments to find a BotChannel
     * @example
     * // Get one BotChannel
     * const botChannel = await prisma.botChannel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotChannelFindUniqueOrThrowArgs>(args: SelectSubset<T, BotChannelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotChannel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelFindFirstArgs} args - Arguments to find a BotChannel
     * @example
     * // Get one BotChannel
     * const botChannel = await prisma.botChannel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotChannelFindFirstArgs>(args?: SelectSubset<T, BotChannelFindFirstArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotChannel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelFindFirstOrThrowArgs} args - Arguments to find a BotChannel
     * @example
     * // Get one BotChannel
     * const botChannel = await prisma.botChannel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotChannelFindFirstOrThrowArgs>(args?: SelectSubset<T, BotChannelFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotChannels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotChannels
     * const botChannels = await prisma.botChannel.findMany()
     * 
     * // Get first 10 BotChannels
     * const botChannels = await prisma.botChannel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botChannelWithIdOnly = await prisma.botChannel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotChannelFindManyArgs>(args?: SelectSubset<T, BotChannelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotChannel.
     * @param {BotChannelCreateArgs} args - Arguments to create a BotChannel.
     * @example
     * // Create one BotChannel
     * const BotChannel = await prisma.botChannel.create({
     *   data: {
     *     // ... data to create a BotChannel
     *   }
     * })
     * 
     */
    create<T extends BotChannelCreateArgs>(args: SelectSubset<T, BotChannelCreateArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotChannels.
     * @param {BotChannelCreateManyArgs} args - Arguments to create many BotChannels.
     * @example
     * // Create many BotChannels
     * const botChannel = await prisma.botChannel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotChannelCreateManyArgs>(args?: SelectSubset<T, BotChannelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotChannels and returns the data saved in the database.
     * @param {BotChannelCreateManyAndReturnArgs} args - Arguments to create many BotChannels.
     * @example
     * // Create many BotChannels
     * const botChannel = await prisma.botChannel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotChannels and only return the `id`
     * const botChannelWithIdOnly = await prisma.botChannel.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotChannelCreateManyAndReturnArgs>(args?: SelectSubset<T, BotChannelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotChannel.
     * @param {BotChannelDeleteArgs} args - Arguments to delete one BotChannel.
     * @example
     * // Delete one BotChannel
     * const BotChannel = await prisma.botChannel.delete({
     *   where: {
     *     // ... filter to delete one BotChannel
     *   }
     * })
     * 
     */
    delete<T extends BotChannelDeleteArgs>(args: SelectSubset<T, BotChannelDeleteArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotChannel.
     * @param {BotChannelUpdateArgs} args - Arguments to update one BotChannel.
     * @example
     * // Update one BotChannel
     * const botChannel = await prisma.botChannel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotChannelUpdateArgs>(args: SelectSubset<T, BotChannelUpdateArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotChannels.
     * @param {BotChannelDeleteManyArgs} args - Arguments to filter BotChannels to delete.
     * @example
     * // Delete a few BotChannels
     * const { count } = await prisma.botChannel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotChannelDeleteManyArgs>(args?: SelectSubset<T, BotChannelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotChannels
     * const botChannel = await prisma.botChannel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotChannelUpdateManyArgs>(args: SelectSubset<T, BotChannelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotChannels and returns the data updated in the database.
     * @param {BotChannelUpdateManyAndReturnArgs} args - Arguments to update many BotChannels.
     * @example
     * // Update many BotChannels
     * const botChannel = await prisma.botChannel.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotChannels and only return the `id`
     * const botChannelWithIdOnly = await prisma.botChannel.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotChannelUpdateManyAndReturnArgs>(args: SelectSubset<T, BotChannelUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotChannel.
     * @param {BotChannelUpsertArgs} args - Arguments to update or create a BotChannel.
     * @example
     * // Update or create a BotChannel
     * const botChannel = await prisma.botChannel.upsert({
     *   create: {
     *     // ... data to create a BotChannel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotChannel we want to update
     *   }
     * })
     */
    upsert<T extends BotChannelUpsertArgs>(args: SelectSubset<T, BotChannelUpsertArgs<ExtArgs>>): Prisma__BotChannelClient<$Result.GetResult<Prisma.$BotChannelPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotChannels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelCountArgs} args - Arguments to filter BotChannels to count.
     * @example
     * // Count the number of BotChannels
     * const count = await prisma.botChannel.count({
     *   where: {
     *     // ... the filter for the BotChannels we want to count
     *   }
     * })
    **/
    count<T extends BotChannelCountArgs>(
      args?: Subset<T, BotChannelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotChannelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotChannelAggregateArgs>(args: Subset<T, BotChannelAggregateArgs>): Prisma.PrismaPromise<GetBotChannelAggregateType<T>>

    /**
     * Group by BotChannel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotChannelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotChannelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotChannelGroupByArgs['orderBy'] }
        : { orderBy?: BotChannelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotChannelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotChannelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotChannel model
   */
  readonly fields: BotChannelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotChannel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotChannelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotChannel model
   */
  interface BotChannelFieldRefs {
    readonly id: FieldRef<"BotChannel", 'String'>
    readonly botId: FieldRef<"BotChannel", 'String'>
    readonly channelType: FieldRef<"BotChannel", 'String'>
    readonly name: FieldRef<"BotChannel", 'String'>
    readonly credentialsEncrypted: FieldRef<"BotChannel", 'Bytes'>
    readonly config: FieldRef<"BotChannel", 'Json'>
    readonly isEnabled: FieldRef<"BotChannel", 'Boolean'>
    readonly connectionStatus: FieldRef<"BotChannel", 'ChannelConnectionStatus'>
    readonly lastConnectedAt: FieldRef<"BotChannel", 'DateTime'>
    readonly lastError: FieldRef<"BotChannel", 'String'>
    readonly isDeleted: FieldRef<"BotChannel", 'Boolean'>
    readonly createdAt: FieldRef<"BotChannel", 'DateTime'>
    readonly updatedAt: FieldRef<"BotChannel", 'DateTime'>
    readonly deletedAt: FieldRef<"BotChannel", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotChannel findUnique
   */
  export type BotChannelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter, which BotChannel to fetch.
     */
    where: BotChannelWhereUniqueInput
  }

  /**
   * BotChannel findUniqueOrThrow
   */
  export type BotChannelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter, which BotChannel to fetch.
     */
    where: BotChannelWhereUniqueInput
  }

  /**
   * BotChannel findFirst
   */
  export type BotChannelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter, which BotChannel to fetch.
     */
    where?: BotChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotChannels to fetch.
     */
    orderBy?: BotChannelOrderByWithRelationInput | BotChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotChannels.
     */
    cursor?: BotChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotChannels.
     */
    distinct?: BotChannelScalarFieldEnum | BotChannelScalarFieldEnum[]
  }

  /**
   * BotChannel findFirstOrThrow
   */
  export type BotChannelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter, which BotChannel to fetch.
     */
    where?: BotChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotChannels to fetch.
     */
    orderBy?: BotChannelOrderByWithRelationInput | BotChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotChannels.
     */
    cursor?: BotChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotChannels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotChannels.
     */
    distinct?: BotChannelScalarFieldEnum | BotChannelScalarFieldEnum[]
  }

  /**
   * BotChannel findMany
   */
  export type BotChannelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter, which BotChannels to fetch.
     */
    where?: BotChannelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotChannels to fetch.
     */
    orderBy?: BotChannelOrderByWithRelationInput | BotChannelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotChannels.
     */
    cursor?: BotChannelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotChannels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotChannels.
     */
    skip?: number
    distinct?: BotChannelScalarFieldEnum | BotChannelScalarFieldEnum[]
  }

  /**
   * BotChannel create
   */
  export type BotChannelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * The data needed to create a BotChannel.
     */
    data: XOR<BotChannelCreateInput, BotChannelUncheckedCreateInput>
  }

  /**
   * BotChannel createMany
   */
  export type BotChannelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotChannels.
     */
    data: BotChannelCreateManyInput | BotChannelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotChannel createManyAndReturn
   */
  export type BotChannelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * The data used to create many BotChannels.
     */
    data: BotChannelCreateManyInput | BotChannelCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotChannel update
   */
  export type BotChannelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * The data needed to update a BotChannel.
     */
    data: XOR<BotChannelUpdateInput, BotChannelUncheckedUpdateInput>
    /**
     * Choose, which BotChannel to update.
     */
    where: BotChannelWhereUniqueInput
  }

  /**
   * BotChannel updateMany
   */
  export type BotChannelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotChannels.
     */
    data: XOR<BotChannelUpdateManyMutationInput, BotChannelUncheckedUpdateManyInput>
    /**
     * Filter which BotChannels to update
     */
    where?: BotChannelWhereInput
    /**
     * Limit how many BotChannels to update.
     */
    limit?: number
  }

  /**
   * BotChannel updateManyAndReturn
   */
  export type BotChannelUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * The data used to update BotChannels.
     */
    data: XOR<BotChannelUpdateManyMutationInput, BotChannelUncheckedUpdateManyInput>
    /**
     * Filter which BotChannels to update
     */
    where?: BotChannelWhereInput
    /**
     * Limit how many BotChannels to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotChannel upsert
   */
  export type BotChannelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * The filter to search for the BotChannel to update in case it exists.
     */
    where: BotChannelWhereUniqueInput
    /**
     * In case the BotChannel found by the `where` argument doesn't exist, create a new BotChannel with this data.
     */
    create: XOR<BotChannelCreateInput, BotChannelUncheckedCreateInput>
    /**
     * In case the BotChannel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotChannelUpdateInput, BotChannelUncheckedUpdateInput>
  }

  /**
   * BotChannel delete
   */
  export type BotChannelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
    /**
     * Filter which BotChannel to delete.
     */
    where: BotChannelWhereUniqueInput
  }

  /**
   * BotChannel deleteMany
   */
  export type BotChannelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotChannels to delete
     */
    where?: BotChannelWhereInput
    /**
     * Limit how many BotChannels to delete.
     */
    limit?: number
  }

  /**
   * BotChannel without action
   */
  export type BotChannelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotChannel
     */
    select?: BotChannelSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotChannel
     */
    omit?: BotChannelOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotChannelInclude<ExtArgs> | null
  }


  /**
   * Model CapabilityTag
   */

  export type AggregateCapabilityTag = {
    _count: CapabilityTagCountAggregateOutputType | null
    _avg: CapabilityTagAvgAggregateOutputType | null
    _sum: CapabilityTagSumAggregateOutputType | null
    _min: CapabilityTagMinAggregateOutputType | null
    _max: CapabilityTagMaxAggregateOutputType | null
  }

  export type CapabilityTagAvgAggregateOutputType = {
    priority: number | null
    maxCostPerMToken: Decimal | null
  }

  export type CapabilityTagSumAggregateOutputType = {
    priority: number | null
    maxCostPerMToken: Decimal | null
  }

  export type CapabilityTagMinAggregateOutputType = {
    id: string | null
    tagId: string | null
    name: string | null
    description: string | null
    category: string | null
    priority: number | null
    requiredProtocol: string | null
    requiresExtendedThinking: boolean | null
    requiresCacheControl: boolean | null
    requiresVision: boolean | null
    maxCostPerMToken: Decimal | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CapabilityTagMaxAggregateOutputType = {
    id: string | null
    tagId: string | null
    name: string | null
    description: string | null
    category: string | null
    priority: number | null
    requiredProtocol: string | null
    requiresExtendedThinking: boolean | null
    requiresCacheControl: boolean | null
    requiresVision: boolean | null
    maxCostPerMToken: Decimal | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CapabilityTagCountAggregateOutputType = {
    id: number
    tagId: number
    name: number
    description: number
    category: number
    priority: number
    requiredProtocol: number
    requiredSkills: number
    requiredModels: number
    requiresExtendedThinking: number
    requiresCacheControl: number
    requiresVision: number
    maxCostPerMToken: number
    isActive: number
    isBuiltin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CapabilityTagAvgAggregateInputType = {
    priority?: true
    maxCostPerMToken?: true
  }

  export type CapabilityTagSumAggregateInputType = {
    priority?: true
    maxCostPerMToken?: true
  }

  export type CapabilityTagMinAggregateInputType = {
    id?: true
    tagId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    requiredProtocol?: true
    requiresExtendedThinking?: true
    requiresCacheControl?: true
    requiresVision?: true
    maxCostPerMToken?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CapabilityTagMaxAggregateInputType = {
    id?: true
    tagId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    requiredProtocol?: true
    requiresExtendedThinking?: true
    requiresCacheControl?: true
    requiresVision?: true
    maxCostPerMToken?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CapabilityTagCountAggregateInputType = {
    id?: true
    tagId?: true
    name?: true
    description?: true
    category?: true
    priority?: true
    requiredProtocol?: true
    requiredSkills?: true
    requiredModels?: true
    requiresExtendedThinking?: true
    requiresCacheControl?: true
    requiresVision?: true
    maxCostPerMToken?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CapabilityTagAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityTag to aggregate.
     */
    where?: CapabilityTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityTags to fetch.
     */
    orderBy?: CapabilityTagOrderByWithRelationInput | CapabilityTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CapabilityTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CapabilityTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CapabilityTags
    **/
    _count?: true | CapabilityTagCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CapabilityTagAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CapabilityTagSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CapabilityTagMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CapabilityTagMaxAggregateInputType
  }

  export type GetCapabilityTagAggregateType<T extends CapabilityTagAggregateArgs> = {
        [P in keyof T & keyof AggregateCapabilityTag]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCapabilityTag[P]>
      : GetScalarType<T[P], AggregateCapabilityTag[P]>
  }




  export type CapabilityTagGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CapabilityTagWhereInput
    orderBy?: CapabilityTagOrderByWithAggregationInput | CapabilityTagOrderByWithAggregationInput[]
    by: CapabilityTagScalarFieldEnum[] | CapabilityTagScalarFieldEnum
    having?: CapabilityTagScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CapabilityTagCountAggregateInputType | true
    _avg?: CapabilityTagAvgAggregateInputType
    _sum?: CapabilityTagSumAggregateInputType
    _min?: CapabilityTagMinAggregateInputType
    _max?: CapabilityTagMaxAggregateInputType
  }

  export type CapabilityTagGroupByOutputType = {
    id: string
    tagId: string
    name: string
    description: string | null
    category: string
    priority: number
    requiredProtocol: string | null
    requiredSkills: JsonValue | null
    requiredModels: JsonValue | null
    requiresExtendedThinking: boolean
    requiresCacheControl: boolean
    requiresVision: boolean
    maxCostPerMToken: Decimal | null
    isActive: boolean
    isBuiltin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CapabilityTagCountAggregateOutputType | null
    _avg: CapabilityTagAvgAggregateOutputType | null
    _sum: CapabilityTagSumAggregateOutputType | null
    _min: CapabilityTagMinAggregateOutputType | null
    _max: CapabilityTagMaxAggregateOutputType | null
  }

  type GetCapabilityTagGroupByPayload<T extends CapabilityTagGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CapabilityTagGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CapabilityTagGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CapabilityTagGroupByOutputType[P]>
            : GetScalarType<T[P], CapabilityTagGroupByOutputType[P]>
        }
      >
    >


  export type CapabilityTagSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    requiredProtocol?: boolean
    requiredSkills?: boolean
    requiredModels?: boolean
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["capabilityTag"]>

  export type CapabilityTagSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    requiredProtocol?: boolean
    requiredSkills?: boolean
    requiredModels?: boolean
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["capabilityTag"]>

  export type CapabilityTagSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tagId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    requiredProtocol?: boolean
    requiredSkills?: boolean
    requiredModels?: boolean
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["capabilityTag"]>

  export type CapabilityTagSelectScalar = {
    id?: boolean
    tagId?: boolean
    name?: boolean
    description?: boolean
    category?: boolean
    priority?: boolean
    requiredProtocol?: boolean
    requiredSkills?: boolean
    requiredModels?: boolean
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CapabilityTagOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "tagId" | "name" | "description" | "category" | "priority" | "requiredProtocol" | "requiredSkills" | "requiredModels" | "requiresExtendedThinking" | "requiresCacheControl" | "requiresVision" | "maxCostPerMToken" | "isActive" | "isBuiltin" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["capabilityTag"]>

  export type $CapabilityTagPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CapabilityTag"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * æ ‡ç­¾æ ‡è¯†ï¼ˆå¦‚ deep-reasoning, cost-optimized, web-searchï¼‰
       */
      tagId: string
      /**
       * æ˜¾ç¤ºåç§°
       */
      name: string
      /**
       * æ ‡ç­¾æè¿°
       */
      description: string | null
      /**
       * åˆ†ç±»ï¼šreasoning | search | code | vision | audio | cost | context
       */
      category: string
      /**
       * è·¯ç”±ä¼˜å…ˆçº§ï¼ˆæ•°å€¼è¶Šé«˜ä¼˜å…ˆçº§è¶Šé«˜ï¼‰
       */
      priority: number
      /**
       * è¦æ±‚çš„åè®®ç±»å‹ï¼šopenai-compatible | anthropic-native | null
       */
      requiredProtocol: string | null
      /**
       * è¦æ±‚çš„ Skillsï¼ˆJSON æ•°ç»„ï¼‰å¦‚ ["web_search", "code_runner"]
       */
      requiredSkills: Prisma.JsonValue | null
      /**
       * è¦æ±‚çš„æ¨¡å‹åˆ—è¡¨ï¼ˆJSON æ•°ç»„ï¼‰å¦‚ ["claude-sonnet-4-*", "gpt-4o"]
       */
      requiredModels: Prisma.JsonValue | null
      /**
       * æ˜¯å¦è¦æ±‚ Extended Thinking
       */
      requiresExtendedThinking: boolean
      /**
       * æ˜¯å¦è¦æ±‚ Cache Control
       */
      requiresCacheControl: boolean
      /**
       * æ˜¯å¦è¦æ±‚è§†è§‰èƒ½åŠ›
       */
      requiresVision: boolean
      /**
       * å•æ¬¡è¯·æ±‚æœ€å¤§æˆæœ¬çº¦æŸï¼ˆç¾å…ƒï¼‰
       */
      maxCostPerMToken: Prisma.Decimal | null
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isActive: boolean
      /**
       * æ˜¯å¦ä¸ºå†…ç½®æ ‡ç­¾
       */
      isBuiltin: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["capabilityTag"]>
    composites: {}
  }

  type CapabilityTagGetPayload<S extends boolean | null | undefined | CapabilityTagDefaultArgs> = $Result.GetResult<Prisma.$CapabilityTagPayload, S>

  type CapabilityTagCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CapabilityTagFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CapabilityTagCountAggregateInputType | true
    }

  export interface CapabilityTagDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CapabilityTag'], meta: { name: 'CapabilityTag' } }
    /**
     * Find zero or one CapabilityTag that matches the filter.
     * @param {CapabilityTagFindUniqueArgs} args - Arguments to find a CapabilityTag
     * @example
     * // Get one CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CapabilityTagFindUniqueArgs>(args: SelectSubset<T, CapabilityTagFindUniqueArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CapabilityTag that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CapabilityTagFindUniqueOrThrowArgs} args - Arguments to find a CapabilityTag
     * @example
     * // Get one CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CapabilityTagFindUniqueOrThrowArgs>(args: SelectSubset<T, CapabilityTagFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapabilityTag that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagFindFirstArgs} args - Arguments to find a CapabilityTag
     * @example
     * // Get one CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CapabilityTagFindFirstArgs>(args?: SelectSubset<T, CapabilityTagFindFirstArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CapabilityTag that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagFindFirstOrThrowArgs} args - Arguments to find a CapabilityTag
     * @example
     * // Get one CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CapabilityTagFindFirstOrThrowArgs>(args?: SelectSubset<T, CapabilityTagFindFirstOrThrowArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CapabilityTags that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CapabilityTags
     * const capabilityTags = await prisma.capabilityTag.findMany()
     * 
     * // Get first 10 CapabilityTags
     * const capabilityTags = await prisma.capabilityTag.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const capabilityTagWithIdOnly = await prisma.capabilityTag.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CapabilityTagFindManyArgs>(args?: SelectSubset<T, CapabilityTagFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CapabilityTag.
     * @param {CapabilityTagCreateArgs} args - Arguments to create a CapabilityTag.
     * @example
     * // Create one CapabilityTag
     * const CapabilityTag = await prisma.capabilityTag.create({
     *   data: {
     *     // ... data to create a CapabilityTag
     *   }
     * })
     * 
     */
    create<T extends CapabilityTagCreateArgs>(args: SelectSubset<T, CapabilityTagCreateArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CapabilityTags.
     * @param {CapabilityTagCreateManyArgs} args - Arguments to create many CapabilityTags.
     * @example
     * // Create many CapabilityTags
     * const capabilityTag = await prisma.capabilityTag.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CapabilityTagCreateManyArgs>(args?: SelectSubset<T, CapabilityTagCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CapabilityTags and returns the data saved in the database.
     * @param {CapabilityTagCreateManyAndReturnArgs} args - Arguments to create many CapabilityTags.
     * @example
     * // Create many CapabilityTags
     * const capabilityTag = await prisma.capabilityTag.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CapabilityTags and only return the `id`
     * const capabilityTagWithIdOnly = await prisma.capabilityTag.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CapabilityTagCreateManyAndReturnArgs>(args?: SelectSubset<T, CapabilityTagCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CapabilityTag.
     * @param {CapabilityTagDeleteArgs} args - Arguments to delete one CapabilityTag.
     * @example
     * // Delete one CapabilityTag
     * const CapabilityTag = await prisma.capabilityTag.delete({
     *   where: {
     *     // ... filter to delete one CapabilityTag
     *   }
     * })
     * 
     */
    delete<T extends CapabilityTagDeleteArgs>(args: SelectSubset<T, CapabilityTagDeleteArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CapabilityTag.
     * @param {CapabilityTagUpdateArgs} args - Arguments to update one CapabilityTag.
     * @example
     * // Update one CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CapabilityTagUpdateArgs>(args: SelectSubset<T, CapabilityTagUpdateArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CapabilityTags.
     * @param {CapabilityTagDeleteManyArgs} args - Arguments to filter CapabilityTags to delete.
     * @example
     * // Delete a few CapabilityTags
     * const { count } = await prisma.capabilityTag.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CapabilityTagDeleteManyArgs>(args?: SelectSubset<T, CapabilityTagDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapabilityTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CapabilityTags
     * const capabilityTag = await prisma.capabilityTag.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CapabilityTagUpdateManyArgs>(args: SelectSubset<T, CapabilityTagUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CapabilityTags and returns the data updated in the database.
     * @param {CapabilityTagUpdateManyAndReturnArgs} args - Arguments to update many CapabilityTags.
     * @example
     * // Update many CapabilityTags
     * const capabilityTag = await prisma.capabilityTag.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CapabilityTags and only return the `id`
     * const capabilityTagWithIdOnly = await prisma.capabilityTag.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CapabilityTagUpdateManyAndReturnArgs>(args: SelectSubset<T, CapabilityTagUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CapabilityTag.
     * @param {CapabilityTagUpsertArgs} args - Arguments to update or create a CapabilityTag.
     * @example
     * // Update or create a CapabilityTag
     * const capabilityTag = await prisma.capabilityTag.upsert({
     *   create: {
     *     // ... data to create a CapabilityTag
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CapabilityTag we want to update
     *   }
     * })
     */
    upsert<T extends CapabilityTagUpsertArgs>(args: SelectSubset<T, CapabilityTagUpsertArgs<ExtArgs>>): Prisma__CapabilityTagClient<$Result.GetResult<Prisma.$CapabilityTagPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CapabilityTags.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagCountArgs} args - Arguments to filter CapabilityTags to count.
     * @example
     * // Count the number of CapabilityTags
     * const count = await prisma.capabilityTag.count({
     *   where: {
     *     // ... the filter for the CapabilityTags we want to count
     *   }
     * })
    **/
    count<T extends CapabilityTagCountArgs>(
      args?: Subset<T, CapabilityTagCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CapabilityTagCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CapabilityTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CapabilityTagAggregateArgs>(args: Subset<T, CapabilityTagAggregateArgs>): Prisma.PrismaPromise<GetCapabilityTagAggregateType<T>>

    /**
     * Group by CapabilityTag.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CapabilityTagGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CapabilityTagGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CapabilityTagGroupByArgs['orderBy'] }
        : { orderBy?: CapabilityTagGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CapabilityTagGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCapabilityTagGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CapabilityTag model
   */
  readonly fields: CapabilityTagFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CapabilityTag.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CapabilityTagClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CapabilityTag model
   */
  interface CapabilityTagFieldRefs {
    readonly id: FieldRef<"CapabilityTag", 'String'>
    readonly tagId: FieldRef<"CapabilityTag", 'String'>
    readonly name: FieldRef<"CapabilityTag", 'String'>
    readonly description: FieldRef<"CapabilityTag", 'String'>
    readonly category: FieldRef<"CapabilityTag", 'String'>
    readonly priority: FieldRef<"CapabilityTag", 'Int'>
    readonly requiredProtocol: FieldRef<"CapabilityTag", 'String'>
    readonly requiredSkills: FieldRef<"CapabilityTag", 'Json'>
    readonly requiredModels: FieldRef<"CapabilityTag", 'Json'>
    readonly requiresExtendedThinking: FieldRef<"CapabilityTag", 'Boolean'>
    readonly requiresCacheControl: FieldRef<"CapabilityTag", 'Boolean'>
    readonly requiresVision: FieldRef<"CapabilityTag", 'Boolean'>
    readonly maxCostPerMToken: FieldRef<"CapabilityTag", 'Decimal'>
    readonly isActive: FieldRef<"CapabilityTag", 'Boolean'>
    readonly isBuiltin: FieldRef<"CapabilityTag", 'Boolean'>
    readonly isDeleted: FieldRef<"CapabilityTag", 'Boolean'>
    readonly createdAt: FieldRef<"CapabilityTag", 'DateTime'>
    readonly updatedAt: FieldRef<"CapabilityTag", 'DateTime'>
    readonly deletedAt: FieldRef<"CapabilityTag", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CapabilityTag findUnique
   */
  export type CapabilityTagFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter, which CapabilityTag to fetch.
     */
    where: CapabilityTagWhereUniqueInput
  }

  /**
   * CapabilityTag findUniqueOrThrow
   */
  export type CapabilityTagFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter, which CapabilityTag to fetch.
     */
    where: CapabilityTagWhereUniqueInput
  }

  /**
   * CapabilityTag findFirst
   */
  export type CapabilityTagFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter, which CapabilityTag to fetch.
     */
    where?: CapabilityTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityTags to fetch.
     */
    orderBy?: CapabilityTagOrderByWithRelationInput | CapabilityTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityTags.
     */
    cursor?: CapabilityTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CapabilityTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityTags.
     */
    distinct?: CapabilityTagScalarFieldEnum | CapabilityTagScalarFieldEnum[]
  }

  /**
   * CapabilityTag findFirstOrThrow
   */
  export type CapabilityTagFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter, which CapabilityTag to fetch.
     */
    where?: CapabilityTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityTags to fetch.
     */
    orderBy?: CapabilityTagOrderByWithRelationInput | CapabilityTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CapabilityTags.
     */
    cursor?: CapabilityTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CapabilityTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityTags.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CapabilityTags.
     */
    distinct?: CapabilityTagScalarFieldEnum | CapabilityTagScalarFieldEnum[]
  }

  /**
   * CapabilityTag findMany
   */
  export type CapabilityTagFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter, which CapabilityTags to fetch.
     */
    where?: CapabilityTagWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CapabilityTags to fetch.
     */
    orderBy?: CapabilityTagOrderByWithRelationInput | CapabilityTagOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CapabilityTags.
     */
    cursor?: CapabilityTagWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CapabilityTags from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CapabilityTags.
     */
    skip?: number
    distinct?: CapabilityTagScalarFieldEnum | CapabilityTagScalarFieldEnum[]
  }

  /**
   * CapabilityTag create
   */
  export type CapabilityTagCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * The data needed to create a CapabilityTag.
     */
    data: XOR<CapabilityTagCreateInput, CapabilityTagUncheckedCreateInput>
  }

  /**
   * CapabilityTag createMany
   */
  export type CapabilityTagCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CapabilityTags.
     */
    data: CapabilityTagCreateManyInput | CapabilityTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapabilityTag createManyAndReturn
   */
  export type CapabilityTagCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * The data used to create many CapabilityTags.
     */
    data: CapabilityTagCreateManyInput | CapabilityTagCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CapabilityTag update
   */
  export type CapabilityTagUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * The data needed to update a CapabilityTag.
     */
    data: XOR<CapabilityTagUpdateInput, CapabilityTagUncheckedUpdateInput>
    /**
     * Choose, which CapabilityTag to update.
     */
    where: CapabilityTagWhereUniqueInput
  }

  /**
   * CapabilityTag updateMany
   */
  export type CapabilityTagUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CapabilityTags.
     */
    data: XOR<CapabilityTagUpdateManyMutationInput, CapabilityTagUncheckedUpdateManyInput>
    /**
     * Filter which CapabilityTags to update
     */
    where?: CapabilityTagWhereInput
    /**
     * Limit how many CapabilityTags to update.
     */
    limit?: number
  }

  /**
   * CapabilityTag updateManyAndReturn
   */
  export type CapabilityTagUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * The data used to update CapabilityTags.
     */
    data: XOR<CapabilityTagUpdateManyMutationInput, CapabilityTagUncheckedUpdateManyInput>
    /**
     * Filter which CapabilityTags to update
     */
    where?: CapabilityTagWhereInput
    /**
     * Limit how many CapabilityTags to update.
     */
    limit?: number
  }

  /**
   * CapabilityTag upsert
   */
  export type CapabilityTagUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * The filter to search for the CapabilityTag to update in case it exists.
     */
    where: CapabilityTagWhereUniqueInput
    /**
     * In case the CapabilityTag found by the `where` argument doesn't exist, create a new CapabilityTag with this data.
     */
    create: XOR<CapabilityTagCreateInput, CapabilityTagUncheckedCreateInput>
    /**
     * In case the CapabilityTag was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CapabilityTagUpdateInput, CapabilityTagUncheckedUpdateInput>
  }

  /**
   * CapabilityTag delete
   */
  export type CapabilityTagDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
    /**
     * Filter which CapabilityTag to delete.
     */
    where: CapabilityTagWhereUniqueInput
  }

  /**
   * CapabilityTag deleteMany
   */
  export type CapabilityTagDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CapabilityTags to delete
     */
    where?: CapabilityTagWhereInput
    /**
     * Limit how many CapabilityTags to delete.
     */
    limit?: number
  }

  /**
   * CapabilityTag without action
   */
  export type CapabilityTagDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CapabilityTag
     */
    select?: CapabilityTagSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CapabilityTag
     */
    omit?: CapabilityTagOmit<ExtArgs> | null
  }


  /**
   * Model FallbackChain
   */

  export type AggregateFallbackChain = {
    _count: FallbackChainCountAggregateOutputType | null
    _avg: FallbackChainAvgAggregateOutputType | null
    _sum: FallbackChainSumAggregateOutputType | null
    _min: FallbackChainMinAggregateOutputType | null
    _max: FallbackChainMaxAggregateOutputType | null
  }

  export type FallbackChainAvgAggregateOutputType = {
    triggerTimeoutMs: number | null
    maxRetries: number | null
    retryDelayMs: number | null
  }

  export type FallbackChainSumAggregateOutputType = {
    triggerTimeoutMs: number | null
    maxRetries: number | null
    retryDelayMs: number | null
  }

  export type FallbackChainMinAggregateOutputType = {
    id: string | null
    chainId: string | null
    name: string | null
    description: string | null
    triggerTimeoutMs: number | null
    maxRetries: number | null
    retryDelayMs: number | null
    preserveProtocol: boolean | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FallbackChainMaxAggregateOutputType = {
    id: string | null
    chainId: string | null
    name: string | null
    description: string | null
    triggerTimeoutMs: number | null
    maxRetries: number | null
    retryDelayMs: number | null
    preserveProtocol: boolean | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FallbackChainCountAggregateOutputType = {
    id: number
    chainId: number
    name: number
    description: number
    models: number
    triggerStatusCodes: number
    triggerErrorTypes: number
    triggerTimeoutMs: number
    maxRetries: number
    retryDelayMs: number
    preserveProtocol: number
    isActive: number
    isBuiltin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FallbackChainAvgAggregateInputType = {
    triggerTimeoutMs?: true
    maxRetries?: true
    retryDelayMs?: true
  }

  export type FallbackChainSumAggregateInputType = {
    triggerTimeoutMs?: true
    maxRetries?: true
    retryDelayMs?: true
  }

  export type FallbackChainMinAggregateInputType = {
    id?: true
    chainId?: true
    name?: true
    description?: true
    triggerTimeoutMs?: true
    maxRetries?: true
    retryDelayMs?: true
    preserveProtocol?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FallbackChainMaxAggregateInputType = {
    id?: true
    chainId?: true
    name?: true
    description?: true
    triggerTimeoutMs?: true
    maxRetries?: true
    retryDelayMs?: true
    preserveProtocol?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FallbackChainCountAggregateInputType = {
    id?: true
    chainId?: true
    name?: true
    description?: true
    models?: true
    triggerStatusCodes?: true
    triggerErrorTypes?: true
    triggerTimeoutMs?: true
    maxRetries?: true
    retryDelayMs?: true
    preserveProtocol?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FallbackChainAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FallbackChain to aggregate.
     */
    where?: FallbackChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FallbackChains to fetch.
     */
    orderBy?: FallbackChainOrderByWithRelationInput | FallbackChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FallbackChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FallbackChains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FallbackChains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FallbackChains
    **/
    _count?: true | FallbackChainCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FallbackChainAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FallbackChainSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FallbackChainMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FallbackChainMaxAggregateInputType
  }

  export type GetFallbackChainAggregateType<T extends FallbackChainAggregateArgs> = {
        [P in keyof T & keyof AggregateFallbackChain]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFallbackChain[P]>
      : GetScalarType<T[P], AggregateFallbackChain[P]>
  }




  export type FallbackChainGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FallbackChainWhereInput
    orderBy?: FallbackChainOrderByWithAggregationInput | FallbackChainOrderByWithAggregationInput[]
    by: FallbackChainScalarFieldEnum[] | FallbackChainScalarFieldEnum
    having?: FallbackChainScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FallbackChainCountAggregateInputType | true
    _avg?: FallbackChainAvgAggregateInputType
    _sum?: FallbackChainSumAggregateInputType
    _min?: FallbackChainMinAggregateInputType
    _max?: FallbackChainMaxAggregateInputType
  }

  export type FallbackChainGroupByOutputType = {
    id: string
    chainId: string
    name: string
    description: string | null
    models: JsonValue
    triggerStatusCodes: JsonValue
    triggerErrorTypes: JsonValue
    triggerTimeoutMs: number
    maxRetries: number
    retryDelayMs: number
    preserveProtocol: boolean
    isActive: boolean
    isBuiltin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FallbackChainCountAggregateOutputType | null
    _avg: FallbackChainAvgAggregateOutputType | null
    _sum: FallbackChainSumAggregateOutputType | null
    _min: FallbackChainMinAggregateOutputType | null
    _max: FallbackChainMaxAggregateOutputType | null
  }

  type GetFallbackChainGroupByPayload<T extends FallbackChainGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FallbackChainGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FallbackChainGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FallbackChainGroupByOutputType[P]>
            : GetScalarType<T[P], FallbackChainGroupByOutputType[P]>
        }
      >
    >


  export type FallbackChainSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    triggerStatusCodes?: boolean
    triggerErrorTypes?: boolean
    triggerTimeoutMs?: boolean
    maxRetries?: boolean
    retryDelayMs?: boolean
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fallbackChain"]>

  export type FallbackChainSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    triggerStatusCodes?: boolean
    triggerErrorTypes?: boolean
    triggerTimeoutMs?: boolean
    maxRetries?: boolean
    retryDelayMs?: boolean
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fallbackChain"]>

  export type FallbackChainSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    chainId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    triggerStatusCodes?: boolean
    triggerErrorTypes?: boolean
    triggerTimeoutMs?: boolean
    maxRetries?: boolean
    retryDelayMs?: boolean
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fallbackChain"]>

  export type FallbackChainSelectScalar = {
    id?: boolean
    chainId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    triggerStatusCodes?: boolean
    triggerErrorTypes?: boolean
    triggerTimeoutMs?: boolean
    maxRetries?: boolean
    retryDelayMs?: boolean
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FallbackChainOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "chainId" | "name" | "description" | "models" | "triggerStatusCodes" | "triggerErrorTypes" | "triggerTimeoutMs" | "maxRetries" | "retryDelayMs" | "preserveProtocol" | "isActive" | "isBuiltin" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["fallbackChain"]>

  export type $FallbackChainPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FallbackChain"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * é“¾æ ‡è¯†ï¼ˆå¦‚ default, deep-reasoning, cost-optimizedï¼‰
       */
      chainId: string
      /**
       * æ˜¾ç¤ºåç§°
       */
      name: string
      /**
       * é“¾æè¿°
       */
      description: string | null
      /**
       * æ¨¡å‹é“¾é…ç½®ï¼ˆJSON æ•°ç»„ï¼ŒæŒ‰ä¼˜å…ˆçº§æ’åºï¼‰
       * [{ vendor: "anthropic", model: "claude-sonnet-4", protocol: "anthropic-native", features: {...} }]
       */
      models: Prisma.JsonValue
      /**
       * è§¦å‘ Fallback çš„ HTTP çŠ¶æ€ç ï¼ˆJSON æ•°ç»„ï¼‰
       */
      triggerStatusCodes: Prisma.JsonValue
      /**
       * è§¦å‘ Fallback çš„é”™è¯¯ç±»å‹ï¼ˆJSON æ•°ç»„ï¼‰
       */
      triggerErrorTypes: Prisma.JsonValue
      /**
       * è§¦å‘ Fallback çš„è¶…æ—¶æ—¶é—´ï¼ˆæ¯«ç§’ï¼‰
       */
      triggerTimeoutMs: number
      /**
       * æœ€å¤§é‡è¯•æ¬¡æ•°
       */
      maxRetries: number
      /**
       * é‡è¯•é—´éš”ï¼ˆæ¯«ç§’ï¼‰
       */
      retryDelayMs: number
      /**
       * æ˜¯å¦ä¿æŒåè®®ä¸€è‡´ï¼ˆé™çº§æ—¶æ˜¯å¦å…è®¸åˆ‡æ¢åè®®ï¼‰
       */
      preserveProtocol: boolean
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isActive: boolean
      /**
       * æ˜¯å¦ä¸ºå†…ç½®é“¾
       */
      isBuiltin: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["fallbackChain"]>
    composites: {}
  }

  type FallbackChainGetPayload<S extends boolean | null | undefined | FallbackChainDefaultArgs> = $Result.GetResult<Prisma.$FallbackChainPayload, S>

  type FallbackChainCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FallbackChainFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FallbackChainCountAggregateInputType | true
    }

  export interface FallbackChainDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FallbackChain'], meta: { name: 'FallbackChain' } }
    /**
     * Find zero or one FallbackChain that matches the filter.
     * @param {FallbackChainFindUniqueArgs} args - Arguments to find a FallbackChain
     * @example
     * // Get one FallbackChain
     * const fallbackChain = await prisma.fallbackChain.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FallbackChainFindUniqueArgs>(args: SelectSubset<T, FallbackChainFindUniqueArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FallbackChain that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FallbackChainFindUniqueOrThrowArgs} args - Arguments to find a FallbackChain
     * @example
     * // Get one FallbackChain
     * const fallbackChain = await prisma.fallbackChain.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FallbackChainFindUniqueOrThrowArgs>(args: SelectSubset<T, FallbackChainFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FallbackChain that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainFindFirstArgs} args - Arguments to find a FallbackChain
     * @example
     * // Get one FallbackChain
     * const fallbackChain = await prisma.fallbackChain.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FallbackChainFindFirstArgs>(args?: SelectSubset<T, FallbackChainFindFirstArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FallbackChain that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainFindFirstOrThrowArgs} args - Arguments to find a FallbackChain
     * @example
     * // Get one FallbackChain
     * const fallbackChain = await prisma.fallbackChain.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FallbackChainFindFirstOrThrowArgs>(args?: SelectSubset<T, FallbackChainFindFirstOrThrowArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FallbackChains that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FallbackChains
     * const fallbackChains = await prisma.fallbackChain.findMany()
     * 
     * // Get first 10 FallbackChains
     * const fallbackChains = await prisma.fallbackChain.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fallbackChainWithIdOnly = await prisma.fallbackChain.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FallbackChainFindManyArgs>(args?: SelectSubset<T, FallbackChainFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FallbackChain.
     * @param {FallbackChainCreateArgs} args - Arguments to create a FallbackChain.
     * @example
     * // Create one FallbackChain
     * const FallbackChain = await prisma.fallbackChain.create({
     *   data: {
     *     // ... data to create a FallbackChain
     *   }
     * })
     * 
     */
    create<T extends FallbackChainCreateArgs>(args: SelectSubset<T, FallbackChainCreateArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FallbackChains.
     * @param {FallbackChainCreateManyArgs} args - Arguments to create many FallbackChains.
     * @example
     * // Create many FallbackChains
     * const fallbackChain = await prisma.fallbackChain.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FallbackChainCreateManyArgs>(args?: SelectSubset<T, FallbackChainCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FallbackChains and returns the data saved in the database.
     * @param {FallbackChainCreateManyAndReturnArgs} args - Arguments to create many FallbackChains.
     * @example
     * // Create many FallbackChains
     * const fallbackChain = await prisma.fallbackChain.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FallbackChains and only return the `id`
     * const fallbackChainWithIdOnly = await prisma.fallbackChain.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FallbackChainCreateManyAndReturnArgs>(args?: SelectSubset<T, FallbackChainCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FallbackChain.
     * @param {FallbackChainDeleteArgs} args - Arguments to delete one FallbackChain.
     * @example
     * // Delete one FallbackChain
     * const FallbackChain = await prisma.fallbackChain.delete({
     *   where: {
     *     // ... filter to delete one FallbackChain
     *   }
     * })
     * 
     */
    delete<T extends FallbackChainDeleteArgs>(args: SelectSubset<T, FallbackChainDeleteArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FallbackChain.
     * @param {FallbackChainUpdateArgs} args - Arguments to update one FallbackChain.
     * @example
     * // Update one FallbackChain
     * const fallbackChain = await prisma.fallbackChain.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FallbackChainUpdateArgs>(args: SelectSubset<T, FallbackChainUpdateArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FallbackChains.
     * @param {FallbackChainDeleteManyArgs} args - Arguments to filter FallbackChains to delete.
     * @example
     * // Delete a few FallbackChains
     * const { count } = await prisma.fallbackChain.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FallbackChainDeleteManyArgs>(args?: SelectSubset<T, FallbackChainDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FallbackChains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FallbackChains
     * const fallbackChain = await prisma.fallbackChain.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FallbackChainUpdateManyArgs>(args: SelectSubset<T, FallbackChainUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FallbackChains and returns the data updated in the database.
     * @param {FallbackChainUpdateManyAndReturnArgs} args - Arguments to update many FallbackChains.
     * @example
     * // Update many FallbackChains
     * const fallbackChain = await prisma.fallbackChain.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FallbackChains and only return the `id`
     * const fallbackChainWithIdOnly = await prisma.fallbackChain.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FallbackChainUpdateManyAndReturnArgs>(args: SelectSubset<T, FallbackChainUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FallbackChain.
     * @param {FallbackChainUpsertArgs} args - Arguments to update or create a FallbackChain.
     * @example
     * // Update or create a FallbackChain
     * const fallbackChain = await prisma.fallbackChain.upsert({
     *   create: {
     *     // ... data to create a FallbackChain
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FallbackChain we want to update
     *   }
     * })
     */
    upsert<T extends FallbackChainUpsertArgs>(args: SelectSubset<T, FallbackChainUpsertArgs<ExtArgs>>): Prisma__FallbackChainClient<$Result.GetResult<Prisma.$FallbackChainPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FallbackChains.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainCountArgs} args - Arguments to filter FallbackChains to count.
     * @example
     * // Count the number of FallbackChains
     * const count = await prisma.fallbackChain.count({
     *   where: {
     *     // ... the filter for the FallbackChains we want to count
     *   }
     * })
    **/
    count<T extends FallbackChainCountArgs>(
      args?: Subset<T, FallbackChainCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FallbackChainCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FallbackChain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FallbackChainAggregateArgs>(args: Subset<T, FallbackChainAggregateArgs>): Prisma.PrismaPromise<GetFallbackChainAggregateType<T>>

    /**
     * Group by FallbackChain.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FallbackChainGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FallbackChainGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FallbackChainGroupByArgs['orderBy'] }
        : { orderBy?: FallbackChainGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FallbackChainGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFallbackChainGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FallbackChain model
   */
  readonly fields: FallbackChainFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FallbackChain.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FallbackChainClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FallbackChain model
   */
  interface FallbackChainFieldRefs {
    readonly id: FieldRef<"FallbackChain", 'String'>
    readonly chainId: FieldRef<"FallbackChain", 'String'>
    readonly name: FieldRef<"FallbackChain", 'String'>
    readonly description: FieldRef<"FallbackChain", 'String'>
    readonly models: FieldRef<"FallbackChain", 'Json'>
    readonly triggerStatusCodes: FieldRef<"FallbackChain", 'Json'>
    readonly triggerErrorTypes: FieldRef<"FallbackChain", 'Json'>
    readonly triggerTimeoutMs: FieldRef<"FallbackChain", 'Int'>
    readonly maxRetries: FieldRef<"FallbackChain", 'Int'>
    readonly retryDelayMs: FieldRef<"FallbackChain", 'Int'>
    readonly preserveProtocol: FieldRef<"FallbackChain", 'Boolean'>
    readonly isActive: FieldRef<"FallbackChain", 'Boolean'>
    readonly isBuiltin: FieldRef<"FallbackChain", 'Boolean'>
    readonly isDeleted: FieldRef<"FallbackChain", 'Boolean'>
    readonly createdAt: FieldRef<"FallbackChain", 'DateTime'>
    readonly updatedAt: FieldRef<"FallbackChain", 'DateTime'>
    readonly deletedAt: FieldRef<"FallbackChain", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FallbackChain findUnique
   */
  export type FallbackChainFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter, which FallbackChain to fetch.
     */
    where: FallbackChainWhereUniqueInput
  }

  /**
   * FallbackChain findUniqueOrThrow
   */
  export type FallbackChainFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter, which FallbackChain to fetch.
     */
    where: FallbackChainWhereUniqueInput
  }

  /**
   * FallbackChain findFirst
   */
  export type FallbackChainFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter, which FallbackChain to fetch.
     */
    where?: FallbackChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FallbackChains to fetch.
     */
    orderBy?: FallbackChainOrderByWithRelationInput | FallbackChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FallbackChains.
     */
    cursor?: FallbackChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FallbackChains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FallbackChains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FallbackChains.
     */
    distinct?: FallbackChainScalarFieldEnum | FallbackChainScalarFieldEnum[]
  }

  /**
   * FallbackChain findFirstOrThrow
   */
  export type FallbackChainFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter, which FallbackChain to fetch.
     */
    where?: FallbackChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FallbackChains to fetch.
     */
    orderBy?: FallbackChainOrderByWithRelationInput | FallbackChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FallbackChains.
     */
    cursor?: FallbackChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FallbackChains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FallbackChains.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FallbackChains.
     */
    distinct?: FallbackChainScalarFieldEnum | FallbackChainScalarFieldEnum[]
  }

  /**
   * FallbackChain findMany
   */
  export type FallbackChainFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter, which FallbackChains to fetch.
     */
    where?: FallbackChainWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FallbackChains to fetch.
     */
    orderBy?: FallbackChainOrderByWithRelationInput | FallbackChainOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FallbackChains.
     */
    cursor?: FallbackChainWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` FallbackChains from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FallbackChains.
     */
    skip?: number
    distinct?: FallbackChainScalarFieldEnum | FallbackChainScalarFieldEnum[]
  }

  /**
   * FallbackChain create
   */
  export type FallbackChainCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * The data needed to create a FallbackChain.
     */
    data: XOR<FallbackChainCreateInput, FallbackChainUncheckedCreateInput>
  }

  /**
   * FallbackChain createMany
   */
  export type FallbackChainCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FallbackChains.
     */
    data: FallbackChainCreateManyInput | FallbackChainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FallbackChain createManyAndReturn
   */
  export type FallbackChainCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * The data used to create many FallbackChains.
     */
    data: FallbackChainCreateManyInput | FallbackChainCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FallbackChain update
   */
  export type FallbackChainUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * The data needed to update a FallbackChain.
     */
    data: XOR<FallbackChainUpdateInput, FallbackChainUncheckedUpdateInput>
    /**
     * Choose, which FallbackChain to update.
     */
    where: FallbackChainWhereUniqueInput
  }

  /**
   * FallbackChain updateMany
   */
  export type FallbackChainUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FallbackChains.
     */
    data: XOR<FallbackChainUpdateManyMutationInput, FallbackChainUncheckedUpdateManyInput>
    /**
     * Filter which FallbackChains to update
     */
    where?: FallbackChainWhereInput
    /**
     * Limit how many FallbackChains to update.
     */
    limit?: number
  }

  /**
   * FallbackChain updateManyAndReturn
   */
  export type FallbackChainUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * The data used to update FallbackChains.
     */
    data: XOR<FallbackChainUpdateManyMutationInput, FallbackChainUncheckedUpdateManyInput>
    /**
     * Filter which FallbackChains to update
     */
    where?: FallbackChainWhereInput
    /**
     * Limit how many FallbackChains to update.
     */
    limit?: number
  }

  /**
   * FallbackChain upsert
   */
  export type FallbackChainUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * The filter to search for the FallbackChain to update in case it exists.
     */
    where: FallbackChainWhereUniqueInput
    /**
     * In case the FallbackChain found by the `where` argument doesn't exist, create a new FallbackChain with this data.
     */
    create: XOR<FallbackChainCreateInput, FallbackChainUncheckedCreateInput>
    /**
     * In case the FallbackChain was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FallbackChainUpdateInput, FallbackChainUncheckedUpdateInput>
  }

  /**
   * FallbackChain delete
   */
  export type FallbackChainDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
    /**
     * Filter which FallbackChain to delete.
     */
    where: FallbackChainWhereUniqueInput
  }

  /**
   * FallbackChain deleteMany
   */
  export type FallbackChainDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FallbackChains to delete
     */
    where?: FallbackChainWhereInput
    /**
     * Limit how many FallbackChains to delete.
     */
    limit?: number
  }

  /**
   * FallbackChain without action
   */
  export type FallbackChainDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FallbackChain
     */
    select?: FallbackChainSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FallbackChain
     */
    omit?: FallbackChainOmit<ExtArgs> | null
  }


  /**
   * Model CostStrategy
   */

  export type AggregateCostStrategy = {
    _count: CostStrategyCountAggregateOutputType | null
    _avg: CostStrategyAvgAggregateOutputType | null
    _sum: CostStrategySumAggregateOutputType | null
    _min: CostStrategyMinAggregateOutputType | null
    _max: CostStrategyMaxAggregateOutputType | null
  }

  export type CostStrategyAvgAggregateOutputType = {
    costWeight: Decimal | null
    performanceWeight: Decimal | null
    capabilityWeight: Decimal | null
    maxCostPerRequest: Decimal | null
    maxLatencyMs: number | null
    minCapabilityScore: number | null
  }

  export type CostStrategySumAggregateOutputType = {
    costWeight: Decimal | null
    performanceWeight: Decimal | null
    capabilityWeight: Decimal | null
    maxCostPerRequest: Decimal | null
    maxLatencyMs: number | null
    minCapabilityScore: number | null
  }

  export type CostStrategyMinAggregateOutputType = {
    id: string | null
    strategyId: string | null
    name: string | null
    description: string | null
    costWeight: Decimal | null
    performanceWeight: Decimal | null
    capabilityWeight: Decimal | null
    maxCostPerRequest: Decimal | null
    maxLatencyMs: number | null
    minCapabilityScore: number | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CostStrategyMaxAggregateOutputType = {
    id: string | null
    strategyId: string | null
    name: string | null
    description: string | null
    costWeight: Decimal | null
    performanceWeight: Decimal | null
    capabilityWeight: Decimal | null
    maxCostPerRequest: Decimal | null
    maxLatencyMs: number | null
    minCapabilityScore: number | null
    isActive: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CostStrategyCountAggregateOutputType = {
    id: number
    strategyId: number
    name: number
    description: number
    costWeight: number
    performanceWeight: number
    capabilityWeight: number
    maxCostPerRequest: number
    maxLatencyMs: number
    minCapabilityScore: number
    scenarioWeights: number
    isActive: number
    isBuiltin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CostStrategyAvgAggregateInputType = {
    costWeight?: true
    performanceWeight?: true
    capabilityWeight?: true
    maxCostPerRequest?: true
    maxLatencyMs?: true
    minCapabilityScore?: true
  }

  export type CostStrategySumAggregateInputType = {
    costWeight?: true
    performanceWeight?: true
    capabilityWeight?: true
    maxCostPerRequest?: true
    maxLatencyMs?: true
    minCapabilityScore?: true
  }

  export type CostStrategyMinAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    costWeight?: true
    performanceWeight?: true
    capabilityWeight?: true
    maxCostPerRequest?: true
    maxLatencyMs?: true
    minCapabilityScore?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CostStrategyMaxAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    costWeight?: true
    performanceWeight?: true
    capabilityWeight?: true
    maxCostPerRequest?: true
    maxLatencyMs?: true
    minCapabilityScore?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CostStrategyCountAggregateInputType = {
    id?: true
    strategyId?: true
    name?: true
    description?: true
    costWeight?: true
    performanceWeight?: true
    capabilityWeight?: true
    maxCostPerRequest?: true
    maxLatencyMs?: true
    minCapabilityScore?: true
    scenarioWeights?: true
    isActive?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CostStrategyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostStrategy to aggregate.
     */
    where?: CostStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostStrategies to fetch.
     */
    orderBy?: CostStrategyOrderByWithRelationInput | CostStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CostStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CostStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CostStrategies
    **/
    _count?: true | CostStrategyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CostStrategyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CostStrategySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CostStrategyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CostStrategyMaxAggregateInputType
  }

  export type GetCostStrategyAggregateType<T extends CostStrategyAggregateArgs> = {
        [P in keyof T & keyof AggregateCostStrategy]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCostStrategy[P]>
      : GetScalarType<T[P], AggregateCostStrategy[P]>
  }




  export type CostStrategyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CostStrategyWhereInput
    orderBy?: CostStrategyOrderByWithAggregationInput | CostStrategyOrderByWithAggregationInput[]
    by: CostStrategyScalarFieldEnum[] | CostStrategyScalarFieldEnum
    having?: CostStrategyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CostStrategyCountAggregateInputType | true
    _avg?: CostStrategyAvgAggregateInputType
    _sum?: CostStrategySumAggregateInputType
    _min?: CostStrategyMinAggregateInputType
    _max?: CostStrategyMaxAggregateInputType
  }

  export type CostStrategyGroupByOutputType = {
    id: string
    strategyId: string
    name: string
    description: string | null
    costWeight: Decimal
    performanceWeight: Decimal
    capabilityWeight: Decimal
    maxCostPerRequest: Decimal | null
    maxLatencyMs: number | null
    minCapabilityScore: number | null
    scenarioWeights: JsonValue | null
    isActive: boolean
    isBuiltin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CostStrategyCountAggregateOutputType | null
    _avg: CostStrategyAvgAggregateOutputType | null
    _sum: CostStrategySumAggregateOutputType | null
    _min: CostStrategyMinAggregateOutputType | null
    _max: CostStrategyMaxAggregateOutputType | null
  }

  type GetCostStrategyGroupByPayload<T extends CostStrategyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CostStrategyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CostStrategyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CostStrategyGroupByOutputType[P]>
            : GetScalarType<T[P], CostStrategyGroupByOutputType[P]>
        }
      >
    >


  export type CostStrategySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    costWeight?: boolean
    performanceWeight?: boolean
    capabilityWeight?: boolean
    maxCostPerRequest?: boolean
    maxLatencyMs?: boolean
    minCapabilityScore?: boolean
    scenarioWeights?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["costStrategy"]>

  export type CostStrategySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    costWeight?: boolean
    performanceWeight?: boolean
    capabilityWeight?: boolean
    maxCostPerRequest?: boolean
    maxLatencyMs?: boolean
    minCapabilityScore?: boolean
    scenarioWeights?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["costStrategy"]>

  export type CostStrategySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    costWeight?: boolean
    performanceWeight?: boolean
    capabilityWeight?: boolean
    maxCostPerRequest?: boolean
    maxLatencyMs?: boolean
    minCapabilityScore?: boolean
    scenarioWeights?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["costStrategy"]>

  export type CostStrategySelectScalar = {
    id?: boolean
    strategyId?: boolean
    name?: boolean
    description?: boolean
    costWeight?: boolean
    performanceWeight?: boolean
    capabilityWeight?: boolean
    maxCostPerRequest?: boolean
    maxLatencyMs?: boolean
    minCapabilityScore?: boolean
    scenarioWeights?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CostStrategyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "strategyId" | "name" | "description" | "costWeight" | "performanceWeight" | "capabilityWeight" | "maxCostPerRequest" | "maxLatencyMs" | "minCapabilityScore" | "scenarioWeights" | "isActive" | "isBuiltin" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["costStrategy"]>

  export type $CostStrategyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CostStrategy"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * ç­–ç•¥æ ‡è¯†ï¼ˆå¦‚ lowest-cost, best-value, performance-first, balancedï¼‰
       */
      strategyId: string
      /**
       * æ˜¾ç¤ºåç§°
       */
      name: string
      /**
       * ç­–ç•¥æè¿°
       */
      description: string | null
      /**
       * æˆæœ¬æƒé‡
       */
      costWeight: Prisma.Decimal
      /**
       * æ€§èƒ½æƒé‡
       */
      performanceWeight: Prisma.Decimal
      /**
       * èƒ½åŠ›æƒé‡
       */
      capabilityWeight: Prisma.Decimal
      /**
       * å•æ¬¡è¯·æ±‚æœ€å¤§æˆæœ¬ï¼ˆç¾å…ƒï¼‰
       */
      maxCostPerRequest: Prisma.Decimal | null
      /**
       * æœ€å¤§å»¶è¿Ÿï¼ˆæ¯«ç§’ï¼‰
       */
      maxLatencyMs: number | null
      /**
       * æœ€ä½èƒ½åŠ›è¯„åˆ†
       */
      minCapabilityScore: number | null
      /**
       * åœºæ™¯æƒé‡é…ç½®ï¼ˆJSONï¼‰
       * { "reasoning": 0.5, "coding": 0.3, "creativity": 0.2, "speed": 0.5 }
       */
      scenarioWeights: Prisma.JsonValue | null
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isActive: boolean
      /**
       * æ˜¯å¦ä¸ºå†…ç½®ç­–ç•¥
       */
      isBuiltin: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["costStrategy"]>
    composites: {}
  }

  type CostStrategyGetPayload<S extends boolean | null | undefined | CostStrategyDefaultArgs> = $Result.GetResult<Prisma.$CostStrategyPayload, S>

  type CostStrategyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CostStrategyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CostStrategyCountAggregateInputType | true
    }

  export interface CostStrategyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CostStrategy'], meta: { name: 'CostStrategy' } }
    /**
     * Find zero or one CostStrategy that matches the filter.
     * @param {CostStrategyFindUniqueArgs} args - Arguments to find a CostStrategy
     * @example
     * // Get one CostStrategy
     * const costStrategy = await prisma.costStrategy.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CostStrategyFindUniqueArgs>(args: SelectSubset<T, CostStrategyFindUniqueArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CostStrategy that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CostStrategyFindUniqueOrThrowArgs} args - Arguments to find a CostStrategy
     * @example
     * // Get one CostStrategy
     * const costStrategy = await prisma.costStrategy.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CostStrategyFindUniqueOrThrowArgs>(args: SelectSubset<T, CostStrategyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostStrategy that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyFindFirstArgs} args - Arguments to find a CostStrategy
     * @example
     * // Get one CostStrategy
     * const costStrategy = await prisma.costStrategy.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CostStrategyFindFirstArgs>(args?: SelectSubset<T, CostStrategyFindFirstArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CostStrategy that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyFindFirstOrThrowArgs} args - Arguments to find a CostStrategy
     * @example
     * // Get one CostStrategy
     * const costStrategy = await prisma.costStrategy.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CostStrategyFindFirstOrThrowArgs>(args?: SelectSubset<T, CostStrategyFindFirstOrThrowArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CostStrategies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CostStrategies
     * const costStrategies = await prisma.costStrategy.findMany()
     * 
     * // Get first 10 CostStrategies
     * const costStrategies = await prisma.costStrategy.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const costStrategyWithIdOnly = await prisma.costStrategy.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CostStrategyFindManyArgs>(args?: SelectSubset<T, CostStrategyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CostStrategy.
     * @param {CostStrategyCreateArgs} args - Arguments to create a CostStrategy.
     * @example
     * // Create one CostStrategy
     * const CostStrategy = await prisma.costStrategy.create({
     *   data: {
     *     // ... data to create a CostStrategy
     *   }
     * })
     * 
     */
    create<T extends CostStrategyCreateArgs>(args: SelectSubset<T, CostStrategyCreateArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CostStrategies.
     * @param {CostStrategyCreateManyArgs} args - Arguments to create many CostStrategies.
     * @example
     * // Create many CostStrategies
     * const costStrategy = await prisma.costStrategy.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CostStrategyCreateManyArgs>(args?: SelectSubset<T, CostStrategyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CostStrategies and returns the data saved in the database.
     * @param {CostStrategyCreateManyAndReturnArgs} args - Arguments to create many CostStrategies.
     * @example
     * // Create many CostStrategies
     * const costStrategy = await prisma.costStrategy.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CostStrategies and only return the `id`
     * const costStrategyWithIdOnly = await prisma.costStrategy.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CostStrategyCreateManyAndReturnArgs>(args?: SelectSubset<T, CostStrategyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CostStrategy.
     * @param {CostStrategyDeleteArgs} args - Arguments to delete one CostStrategy.
     * @example
     * // Delete one CostStrategy
     * const CostStrategy = await prisma.costStrategy.delete({
     *   where: {
     *     // ... filter to delete one CostStrategy
     *   }
     * })
     * 
     */
    delete<T extends CostStrategyDeleteArgs>(args: SelectSubset<T, CostStrategyDeleteArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CostStrategy.
     * @param {CostStrategyUpdateArgs} args - Arguments to update one CostStrategy.
     * @example
     * // Update one CostStrategy
     * const costStrategy = await prisma.costStrategy.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CostStrategyUpdateArgs>(args: SelectSubset<T, CostStrategyUpdateArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CostStrategies.
     * @param {CostStrategyDeleteManyArgs} args - Arguments to filter CostStrategies to delete.
     * @example
     * // Delete a few CostStrategies
     * const { count } = await prisma.costStrategy.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CostStrategyDeleteManyArgs>(args?: SelectSubset<T, CostStrategyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CostStrategies
     * const costStrategy = await prisma.costStrategy.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CostStrategyUpdateManyArgs>(args: SelectSubset<T, CostStrategyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CostStrategies and returns the data updated in the database.
     * @param {CostStrategyUpdateManyAndReturnArgs} args - Arguments to update many CostStrategies.
     * @example
     * // Update many CostStrategies
     * const costStrategy = await prisma.costStrategy.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CostStrategies and only return the `id`
     * const costStrategyWithIdOnly = await prisma.costStrategy.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CostStrategyUpdateManyAndReturnArgs>(args: SelectSubset<T, CostStrategyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CostStrategy.
     * @param {CostStrategyUpsertArgs} args - Arguments to update or create a CostStrategy.
     * @example
     * // Update or create a CostStrategy
     * const costStrategy = await prisma.costStrategy.upsert({
     *   create: {
     *     // ... data to create a CostStrategy
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CostStrategy we want to update
     *   }
     * })
     */
    upsert<T extends CostStrategyUpsertArgs>(args: SelectSubset<T, CostStrategyUpsertArgs<ExtArgs>>): Prisma__CostStrategyClient<$Result.GetResult<Prisma.$CostStrategyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CostStrategies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyCountArgs} args - Arguments to filter CostStrategies to count.
     * @example
     * // Count the number of CostStrategies
     * const count = await prisma.costStrategy.count({
     *   where: {
     *     // ... the filter for the CostStrategies we want to count
     *   }
     * })
    **/
    count<T extends CostStrategyCountArgs>(
      args?: Subset<T, CostStrategyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CostStrategyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CostStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CostStrategyAggregateArgs>(args: Subset<T, CostStrategyAggregateArgs>): Prisma.PrismaPromise<GetCostStrategyAggregateType<T>>

    /**
     * Group by CostStrategy.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CostStrategyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CostStrategyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CostStrategyGroupByArgs['orderBy'] }
        : { orderBy?: CostStrategyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CostStrategyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCostStrategyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CostStrategy model
   */
  readonly fields: CostStrategyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CostStrategy.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CostStrategyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CostStrategy model
   */
  interface CostStrategyFieldRefs {
    readonly id: FieldRef<"CostStrategy", 'String'>
    readonly strategyId: FieldRef<"CostStrategy", 'String'>
    readonly name: FieldRef<"CostStrategy", 'String'>
    readonly description: FieldRef<"CostStrategy", 'String'>
    readonly costWeight: FieldRef<"CostStrategy", 'Decimal'>
    readonly performanceWeight: FieldRef<"CostStrategy", 'Decimal'>
    readonly capabilityWeight: FieldRef<"CostStrategy", 'Decimal'>
    readonly maxCostPerRequest: FieldRef<"CostStrategy", 'Decimal'>
    readonly maxLatencyMs: FieldRef<"CostStrategy", 'Int'>
    readonly minCapabilityScore: FieldRef<"CostStrategy", 'Int'>
    readonly scenarioWeights: FieldRef<"CostStrategy", 'Json'>
    readonly isActive: FieldRef<"CostStrategy", 'Boolean'>
    readonly isBuiltin: FieldRef<"CostStrategy", 'Boolean'>
    readonly isDeleted: FieldRef<"CostStrategy", 'Boolean'>
    readonly createdAt: FieldRef<"CostStrategy", 'DateTime'>
    readonly updatedAt: FieldRef<"CostStrategy", 'DateTime'>
    readonly deletedAt: FieldRef<"CostStrategy", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CostStrategy findUnique
   */
  export type CostStrategyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter, which CostStrategy to fetch.
     */
    where: CostStrategyWhereUniqueInput
  }

  /**
   * CostStrategy findUniqueOrThrow
   */
  export type CostStrategyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter, which CostStrategy to fetch.
     */
    where: CostStrategyWhereUniqueInput
  }

  /**
   * CostStrategy findFirst
   */
  export type CostStrategyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter, which CostStrategy to fetch.
     */
    where?: CostStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostStrategies to fetch.
     */
    orderBy?: CostStrategyOrderByWithRelationInput | CostStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostStrategies.
     */
    cursor?: CostStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CostStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostStrategies.
     */
    distinct?: CostStrategyScalarFieldEnum | CostStrategyScalarFieldEnum[]
  }

  /**
   * CostStrategy findFirstOrThrow
   */
  export type CostStrategyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter, which CostStrategy to fetch.
     */
    where?: CostStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostStrategies to fetch.
     */
    orderBy?: CostStrategyOrderByWithRelationInput | CostStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CostStrategies.
     */
    cursor?: CostStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CostStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostStrategies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CostStrategies.
     */
    distinct?: CostStrategyScalarFieldEnum | CostStrategyScalarFieldEnum[]
  }

  /**
   * CostStrategy findMany
   */
  export type CostStrategyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter, which CostStrategies to fetch.
     */
    where?: CostStrategyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CostStrategies to fetch.
     */
    orderBy?: CostStrategyOrderByWithRelationInput | CostStrategyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CostStrategies.
     */
    cursor?: CostStrategyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` CostStrategies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CostStrategies.
     */
    skip?: number
    distinct?: CostStrategyScalarFieldEnum | CostStrategyScalarFieldEnum[]
  }

  /**
   * CostStrategy create
   */
  export type CostStrategyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * The data needed to create a CostStrategy.
     */
    data: XOR<CostStrategyCreateInput, CostStrategyUncheckedCreateInput>
  }

  /**
   * CostStrategy createMany
   */
  export type CostStrategyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CostStrategies.
     */
    data: CostStrategyCreateManyInput | CostStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostStrategy createManyAndReturn
   */
  export type CostStrategyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * The data used to create many CostStrategies.
     */
    data: CostStrategyCreateManyInput | CostStrategyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CostStrategy update
   */
  export type CostStrategyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * The data needed to update a CostStrategy.
     */
    data: XOR<CostStrategyUpdateInput, CostStrategyUncheckedUpdateInput>
    /**
     * Choose, which CostStrategy to update.
     */
    where: CostStrategyWhereUniqueInput
  }

  /**
   * CostStrategy updateMany
   */
  export type CostStrategyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CostStrategies.
     */
    data: XOR<CostStrategyUpdateManyMutationInput, CostStrategyUncheckedUpdateManyInput>
    /**
     * Filter which CostStrategies to update
     */
    where?: CostStrategyWhereInput
    /**
     * Limit how many CostStrategies to update.
     */
    limit?: number
  }

  /**
   * CostStrategy updateManyAndReturn
   */
  export type CostStrategyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * The data used to update CostStrategies.
     */
    data: XOR<CostStrategyUpdateManyMutationInput, CostStrategyUncheckedUpdateManyInput>
    /**
     * Filter which CostStrategies to update
     */
    where?: CostStrategyWhereInput
    /**
     * Limit how many CostStrategies to update.
     */
    limit?: number
  }

  /**
   * CostStrategy upsert
   */
  export type CostStrategyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * The filter to search for the CostStrategy to update in case it exists.
     */
    where: CostStrategyWhereUniqueInput
    /**
     * In case the CostStrategy found by the `where` argument doesn't exist, create a new CostStrategy with this data.
     */
    create: XOR<CostStrategyCreateInput, CostStrategyUncheckedCreateInput>
    /**
     * In case the CostStrategy was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CostStrategyUpdateInput, CostStrategyUncheckedUpdateInput>
  }

  /**
   * CostStrategy delete
   */
  export type CostStrategyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
    /**
     * Filter which CostStrategy to delete.
     */
    where: CostStrategyWhereUniqueInput
  }

  /**
   * CostStrategy deleteMany
   */
  export type CostStrategyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CostStrategies to delete
     */
    where?: CostStrategyWhereInput
    /**
     * Limit how many CostStrategies to delete.
     */
    limit?: number
  }

  /**
   * CostStrategy without action
   */
  export type CostStrategyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CostStrategy
     */
    select?: CostStrategySelect<ExtArgs> | null
    /**
     * Omit specific fields from the CostStrategy
     */
    omit?: CostStrategyOmit<ExtArgs> | null
  }


  /**
   * Model BotRoutingConfig
   */

  export type AggregateBotRoutingConfig = {
    _count: BotRoutingConfigCountAggregateOutputType | null
    _avg: BotRoutingConfigAvgAggregateOutputType | null
    _sum: BotRoutingConfigSumAggregateOutputType | null
    _min: BotRoutingConfigMinAggregateOutputType | null
    _max: BotRoutingConfigMaxAggregateOutputType | null
  }

  export type BotRoutingConfigAvgAggregateOutputType = {
    dailyBudget: Decimal | null
    monthlyBudget: Decimal | null
    alertThreshold: Decimal | null
  }

  export type BotRoutingConfigSumAggregateOutputType = {
    dailyBudget: Decimal | null
    monthlyBudget: Decimal | null
    alertThreshold: Decimal | null
  }

  export type BotRoutingConfigMinAggregateOutputType = {
    id: string | null
    botId: string | null
    routingEnabled: boolean | null
    routingMode: string | null
    fallbackEnabled: boolean | null
    fallbackChainId: string | null
    costControlEnabled: boolean | null
    costStrategyId: string | null
    dailyBudget: Decimal | null
    monthlyBudget: Decimal | null
    alertThreshold: Decimal | null
    autoDowngrade: boolean | null
    downgradeModel: string | null
    complexityRoutingEnabled: boolean | null
    complexityRoutingConfigId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotRoutingConfigMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    routingEnabled: boolean | null
    routingMode: string | null
    fallbackEnabled: boolean | null
    fallbackChainId: string | null
    costControlEnabled: boolean | null
    costStrategyId: string | null
    dailyBudget: Decimal | null
    monthlyBudget: Decimal | null
    alertThreshold: Decimal | null
    autoDowngrade: boolean | null
    downgradeModel: string | null
    complexityRoutingEnabled: boolean | null
    complexityRoutingConfigId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BotRoutingConfigCountAggregateOutputType = {
    id: number
    botId: number
    routingEnabled: number
    routingMode: number
    fallbackEnabled: number
    fallbackChainId: number
    costControlEnabled: number
    costStrategyId: number
    dailyBudget: number
    monthlyBudget: number
    alertThreshold: number
    autoDowngrade: number
    downgradeModel: number
    complexityRoutingEnabled: number
    complexityRoutingConfigId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BotRoutingConfigAvgAggregateInputType = {
    dailyBudget?: true
    monthlyBudget?: true
    alertThreshold?: true
  }

  export type BotRoutingConfigSumAggregateInputType = {
    dailyBudget?: true
    monthlyBudget?: true
    alertThreshold?: true
  }

  export type BotRoutingConfigMinAggregateInputType = {
    id?: true
    botId?: true
    routingEnabled?: true
    routingMode?: true
    fallbackEnabled?: true
    fallbackChainId?: true
    costControlEnabled?: true
    costStrategyId?: true
    dailyBudget?: true
    monthlyBudget?: true
    alertThreshold?: true
    autoDowngrade?: true
    downgradeModel?: true
    complexityRoutingEnabled?: true
    complexityRoutingConfigId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotRoutingConfigMaxAggregateInputType = {
    id?: true
    botId?: true
    routingEnabled?: true
    routingMode?: true
    fallbackEnabled?: true
    fallbackChainId?: true
    costControlEnabled?: true
    costStrategyId?: true
    dailyBudget?: true
    monthlyBudget?: true
    alertThreshold?: true
    autoDowngrade?: true
    downgradeModel?: true
    complexityRoutingEnabled?: true
    complexityRoutingConfigId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BotRoutingConfigCountAggregateInputType = {
    id?: true
    botId?: true
    routingEnabled?: true
    routingMode?: true
    fallbackEnabled?: true
    fallbackChainId?: true
    costControlEnabled?: true
    costStrategyId?: true
    dailyBudget?: true
    monthlyBudget?: true
    alertThreshold?: true
    autoDowngrade?: true
    downgradeModel?: true
    complexityRoutingEnabled?: true
    complexityRoutingConfigId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BotRoutingConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotRoutingConfig to aggregate.
     */
    where?: BotRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotRoutingConfigs to fetch.
     */
    orderBy?: BotRoutingConfigOrderByWithRelationInput | BotRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotRoutingConfigs
    **/
    _count?: true | BotRoutingConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotRoutingConfigAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotRoutingConfigSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotRoutingConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotRoutingConfigMaxAggregateInputType
  }

  export type GetBotRoutingConfigAggregateType<T extends BotRoutingConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateBotRoutingConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotRoutingConfig[P]>
      : GetScalarType<T[P], AggregateBotRoutingConfig[P]>
  }




  export type BotRoutingConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotRoutingConfigWhereInput
    orderBy?: BotRoutingConfigOrderByWithAggregationInput | BotRoutingConfigOrderByWithAggregationInput[]
    by: BotRoutingConfigScalarFieldEnum[] | BotRoutingConfigScalarFieldEnum
    having?: BotRoutingConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotRoutingConfigCountAggregateInputType | true
    _avg?: BotRoutingConfigAvgAggregateInputType
    _sum?: BotRoutingConfigSumAggregateInputType
    _min?: BotRoutingConfigMinAggregateInputType
    _max?: BotRoutingConfigMaxAggregateInputType
  }

  export type BotRoutingConfigGroupByOutputType = {
    id: string
    botId: string
    routingEnabled: boolean
    routingMode: string
    fallbackEnabled: boolean
    fallbackChainId: string | null
    costControlEnabled: boolean
    costStrategyId: string | null
    dailyBudget: Decimal | null
    monthlyBudget: Decimal | null
    alertThreshold: Decimal | null
    autoDowngrade: boolean
    downgradeModel: string | null
    complexityRoutingEnabled: boolean
    complexityRoutingConfigId: string | null
    createdAt: Date
    updatedAt: Date
    _count: BotRoutingConfigCountAggregateOutputType | null
    _avg: BotRoutingConfigAvgAggregateOutputType | null
    _sum: BotRoutingConfigSumAggregateOutputType | null
    _min: BotRoutingConfigMinAggregateOutputType | null
    _max: BotRoutingConfigMaxAggregateOutputType | null
  }

  type GetBotRoutingConfigGroupByPayload<T extends BotRoutingConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotRoutingConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotRoutingConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotRoutingConfigGroupByOutputType[P]>
            : GetScalarType<T[P], BotRoutingConfigGroupByOutputType[P]>
        }
      >
    >


  export type BotRoutingConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingEnabled?: boolean
    routingMode?: boolean
    fallbackEnabled?: boolean
    fallbackChainId?: boolean
    costControlEnabled?: boolean
    costStrategyId?: boolean
    dailyBudget?: boolean
    monthlyBudget?: boolean
    alertThreshold?: boolean
    autoDowngrade?: boolean
    downgradeModel?: boolean
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botRoutingConfig"]>

  export type BotRoutingConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingEnabled?: boolean
    routingMode?: boolean
    fallbackEnabled?: boolean
    fallbackChainId?: boolean
    costControlEnabled?: boolean
    costStrategyId?: boolean
    dailyBudget?: boolean
    monthlyBudget?: boolean
    alertThreshold?: boolean
    autoDowngrade?: boolean
    downgradeModel?: boolean
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botRoutingConfig"]>

  export type BotRoutingConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    routingEnabled?: boolean
    routingMode?: boolean
    fallbackEnabled?: boolean
    fallbackChainId?: boolean
    costControlEnabled?: boolean
    costStrategyId?: boolean
    dailyBudget?: boolean
    monthlyBudget?: boolean
    alertThreshold?: boolean
    autoDowngrade?: boolean
    downgradeModel?: boolean
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botRoutingConfig"]>

  export type BotRoutingConfigSelectScalar = {
    id?: boolean
    botId?: boolean
    routingEnabled?: boolean
    routingMode?: boolean
    fallbackEnabled?: boolean
    fallbackChainId?: boolean
    costControlEnabled?: boolean
    costStrategyId?: boolean
    dailyBudget?: boolean
    monthlyBudget?: boolean
    alertThreshold?: boolean
    autoDowngrade?: boolean
    downgradeModel?: boolean
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type BotRoutingConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "routingEnabled" | "routingMode" | "fallbackEnabled" | "fallbackChainId" | "costControlEnabled" | "costStrategyId" | "dailyBudget" | "monthlyBudget" | "alertThreshold" | "autoDowngrade" | "downgradeModel" | "complexityRoutingEnabled" | "complexityRoutingConfigId" | "createdAt" | "updatedAt", ExtArgs["result"]["botRoutingConfig"]>
  export type BotRoutingConfigInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotRoutingConfigIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }
  export type BotRoutingConfigIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
  }

  export type $BotRoutingConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotRoutingConfig"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      /**
       * æ˜¯å¦å¯ç”¨æ™ºèƒ½è·¯ç”±
       */
      routingEnabled: boolean
      /**
       * è·¯ç”±æ¨¡å¼ï¼šauto | manual | cost-optimized
       */
      routingMode: string
      /**
       * æ˜¯å¦å¯ç”¨ Fallback
       */
      fallbackEnabled: boolean
      /**
       * é»˜è®¤ Fallback é“¾ ID
       */
      fallbackChainId: string | null
      /**
       * æ˜¯å¦å¯ç”¨æˆæœ¬æ§åˆ¶
       */
      costControlEnabled: boolean
      /**
       * æˆæœ¬ç­–ç•¥ ID
       */
      costStrategyId: string | null
      /**
       * æ¯æ—¥é¢„ç®—ï¼ˆç¾å…ƒï¼‰
       */
      dailyBudget: Prisma.Decimal | null
      /**
       * æ¯æœˆé¢„ç®—ï¼ˆç¾å…ƒï¼‰
       */
      monthlyBudget: Prisma.Decimal | null
      /**
       * é¢„ç®—å‘Šè­¦é˜ˆå€¼ï¼ˆ0-1ï¼‰
       */
      alertThreshold: Prisma.Decimal | null
      /**
       * æ˜¯å¦å¯ç”¨è‡ªåŠ¨é™çº§
       */
      autoDowngrade: boolean
      /**
       * é™çº§ç›®æ ‡æ¨¡å‹
       */
      downgradeModel: string | null
      /**
       * æ˜¯å¦å¯ç”¨å¤æ‚åº¦è·¯ç”±
       */
      complexityRoutingEnabled: boolean
      /**
       * å¤æ‚åº¦è·¯ç”±é…ç½® ID
       */
      complexityRoutingConfigId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["botRoutingConfig"]>
    composites: {}
  }

  type BotRoutingConfigGetPayload<S extends boolean | null | undefined | BotRoutingConfigDefaultArgs> = $Result.GetResult<Prisma.$BotRoutingConfigPayload, S>

  type BotRoutingConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotRoutingConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotRoutingConfigCountAggregateInputType | true
    }

  export interface BotRoutingConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotRoutingConfig'], meta: { name: 'BotRoutingConfig' } }
    /**
     * Find zero or one BotRoutingConfig that matches the filter.
     * @param {BotRoutingConfigFindUniqueArgs} args - Arguments to find a BotRoutingConfig
     * @example
     * // Get one BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotRoutingConfigFindUniqueArgs>(args: SelectSubset<T, BotRoutingConfigFindUniqueArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotRoutingConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotRoutingConfigFindUniqueOrThrowArgs} args - Arguments to find a BotRoutingConfig
     * @example
     * // Get one BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotRoutingConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, BotRoutingConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotRoutingConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigFindFirstArgs} args - Arguments to find a BotRoutingConfig
     * @example
     * // Get one BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotRoutingConfigFindFirstArgs>(args?: SelectSubset<T, BotRoutingConfigFindFirstArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotRoutingConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigFindFirstOrThrowArgs} args - Arguments to find a BotRoutingConfig
     * @example
     * // Get one BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotRoutingConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, BotRoutingConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotRoutingConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotRoutingConfigs
     * const botRoutingConfigs = await prisma.botRoutingConfig.findMany()
     * 
     * // Get first 10 BotRoutingConfigs
     * const botRoutingConfigs = await prisma.botRoutingConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botRoutingConfigWithIdOnly = await prisma.botRoutingConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotRoutingConfigFindManyArgs>(args?: SelectSubset<T, BotRoutingConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotRoutingConfig.
     * @param {BotRoutingConfigCreateArgs} args - Arguments to create a BotRoutingConfig.
     * @example
     * // Create one BotRoutingConfig
     * const BotRoutingConfig = await prisma.botRoutingConfig.create({
     *   data: {
     *     // ... data to create a BotRoutingConfig
     *   }
     * })
     * 
     */
    create<T extends BotRoutingConfigCreateArgs>(args: SelectSubset<T, BotRoutingConfigCreateArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotRoutingConfigs.
     * @param {BotRoutingConfigCreateManyArgs} args - Arguments to create many BotRoutingConfigs.
     * @example
     * // Create many BotRoutingConfigs
     * const botRoutingConfig = await prisma.botRoutingConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotRoutingConfigCreateManyArgs>(args?: SelectSubset<T, BotRoutingConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotRoutingConfigs and returns the data saved in the database.
     * @param {BotRoutingConfigCreateManyAndReturnArgs} args - Arguments to create many BotRoutingConfigs.
     * @example
     * // Create many BotRoutingConfigs
     * const botRoutingConfig = await prisma.botRoutingConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotRoutingConfigs and only return the `id`
     * const botRoutingConfigWithIdOnly = await prisma.botRoutingConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotRoutingConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, BotRoutingConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotRoutingConfig.
     * @param {BotRoutingConfigDeleteArgs} args - Arguments to delete one BotRoutingConfig.
     * @example
     * // Delete one BotRoutingConfig
     * const BotRoutingConfig = await prisma.botRoutingConfig.delete({
     *   where: {
     *     // ... filter to delete one BotRoutingConfig
     *   }
     * })
     * 
     */
    delete<T extends BotRoutingConfigDeleteArgs>(args: SelectSubset<T, BotRoutingConfigDeleteArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotRoutingConfig.
     * @param {BotRoutingConfigUpdateArgs} args - Arguments to update one BotRoutingConfig.
     * @example
     * // Update one BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotRoutingConfigUpdateArgs>(args: SelectSubset<T, BotRoutingConfigUpdateArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotRoutingConfigs.
     * @param {BotRoutingConfigDeleteManyArgs} args - Arguments to filter BotRoutingConfigs to delete.
     * @example
     * // Delete a few BotRoutingConfigs
     * const { count } = await prisma.botRoutingConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotRoutingConfigDeleteManyArgs>(args?: SelectSubset<T, BotRoutingConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotRoutingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotRoutingConfigs
     * const botRoutingConfig = await prisma.botRoutingConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotRoutingConfigUpdateManyArgs>(args: SelectSubset<T, BotRoutingConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotRoutingConfigs and returns the data updated in the database.
     * @param {BotRoutingConfigUpdateManyAndReturnArgs} args - Arguments to update many BotRoutingConfigs.
     * @example
     * // Update many BotRoutingConfigs
     * const botRoutingConfig = await prisma.botRoutingConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotRoutingConfigs and only return the `id`
     * const botRoutingConfigWithIdOnly = await prisma.botRoutingConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotRoutingConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, BotRoutingConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotRoutingConfig.
     * @param {BotRoutingConfigUpsertArgs} args - Arguments to update or create a BotRoutingConfig.
     * @example
     * // Update or create a BotRoutingConfig
     * const botRoutingConfig = await prisma.botRoutingConfig.upsert({
     *   create: {
     *     // ... data to create a BotRoutingConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotRoutingConfig we want to update
     *   }
     * })
     */
    upsert<T extends BotRoutingConfigUpsertArgs>(args: SelectSubset<T, BotRoutingConfigUpsertArgs<ExtArgs>>): Prisma__BotRoutingConfigClient<$Result.GetResult<Prisma.$BotRoutingConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotRoutingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigCountArgs} args - Arguments to filter BotRoutingConfigs to count.
     * @example
     * // Count the number of BotRoutingConfigs
     * const count = await prisma.botRoutingConfig.count({
     *   where: {
     *     // ... the filter for the BotRoutingConfigs we want to count
     *   }
     * })
    **/
    count<T extends BotRoutingConfigCountArgs>(
      args?: Subset<T, BotRoutingConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotRoutingConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotRoutingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotRoutingConfigAggregateArgs>(args: Subset<T, BotRoutingConfigAggregateArgs>): Prisma.PrismaPromise<GetBotRoutingConfigAggregateType<T>>

    /**
     * Group by BotRoutingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotRoutingConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotRoutingConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotRoutingConfigGroupByArgs['orderBy'] }
        : { orderBy?: BotRoutingConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotRoutingConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotRoutingConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotRoutingConfig model
   */
  readonly fields: BotRoutingConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotRoutingConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotRoutingConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotRoutingConfig model
   */
  interface BotRoutingConfigFieldRefs {
    readonly id: FieldRef<"BotRoutingConfig", 'String'>
    readonly botId: FieldRef<"BotRoutingConfig", 'String'>
    readonly routingEnabled: FieldRef<"BotRoutingConfig", 'Boolean'>
    readonly routingMode: FieldRef<"BotRoutingConfig", 'String'>
    readonly fallbackEnabled: FieldRef<"BotRoutingConfig", 'Boolean'>
    readonly fallbackChainId: FieldRef<"BotRoutingConfig", 'String'>
    readonly costControlEnabled: FieldRef<"BotRoutingConfig", 'Boolean'>
    readonly costStrategyId: FieldRef<"BotRoutingConfig", 'String'>
    readonly dailyBudget: FieldRef<"BotRoutingConfig", 'Decimal'>
    readonly monthlyBudget: FieldRef<"BotRoutingConfig", 'Decimal'>
    readonly alertThreshold: FieldRef<"BotRoutingConfig", 'Decimal'>
    readonly autoDowngrade: FieldRef<"BotRoutingConfig", 'Boolean'>
    readonly downgradeModel: FieldRef<"BotRoutingConfig", 'String'>
    readonly complexityRoutingEnabled: FieldRef<"BotRoutingConfig", 'Boolean'>
    readonly complexityRoutingConfigId: FieldRef<"BotRoutingConfig", 'String'>
    readonly createdAt: FieldRef<"BotRoutingConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"BotRoutingConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotRoutingConfig findUnique
   */
  export type BotRoutingConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter, which BotRoutingConfig to fetch.
     */
    where: BotRoutingConfigWhereUniqueInput
  }

  /**
   * BotRoutingConfig findUniqueOrThrow
   */
  export type BotRoutingConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter, which BotRoutingConfig to fetch.
     */
    where: BotRoutingConfigWhereUniqueInput
  }

  /**
   * BotRoutingConfig findFirst
   */
  export type BotRoutingConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter, which BotRoutingConfig to fetch.
     */
    where?: BotRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotRoutingConfigs to fetch.
     */
    orderBy?: BotRoutingConfigOrderByWithRelationInput | BotRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotRoutingConfigs.
     */
    cursor?: BotRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotRoutingConfigs.
     */
    distinct?: BotRoutingConfigScalarFieldEnum | BotRoutingConfigScalarFieldEnum[]
  }

  /**
   * BotRoutingConfig findFirstOrThrow
   */
  export type BotRoutingConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter, which BotRoutingConfig to fetch.
     */
    where?: BotRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotRoutingConfigs to fetch.
     */
    orderBy?: BotRoutingConfigOrderByWithRelationInput | BotRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotRoutingConfigs.
     */
    cursor?: BotRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotRoutingConfigs.
     */
    distinct?: BotRoutingConfigScalarFieldEnum | BotRoutingConfigScalarFieldEnum[]
  }

  /**
   * BotRoutingConfig findMany
   */
  export type BotRoutingConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter, which BotRoutingConfigs to fetch.
     */
    where?: BotRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotRoutingConfigs to fetch.
     */
    orderBy?: BotRoutingConfigOrderByWithRelationInput | BotRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotRoutingConfigs.
     */
    cursor?: BotRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` BotRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotRoutingConfigs.
     */
    skip?: number
    distinct?: BotRoutingConfigScalarFieldEnum | BotRoutingConfigScalarFieldEnum[]
  }

  /**
   * BotRoutingConfig create
   */
  export type BotRoutingConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * The data needed to create a BotRoutingConfig.
     */
    data: XOR<BotRoutingConfigCreateInput, BotRoutingConfigUncheckedCreateInput>
  }

  /**
   * BotRoutingConfig createMany
   */
  export type BotRoutingConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotRoutingConfigs.
     */
    data: BotRoutingConfigCreateManyInput | BotRoutingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotRoutingConfig createManyAndReturn
   */
  export type BotRoutingConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * The data used to create many BotRoutingConfigs.
     */
    data: BotRoutingConfigCreateManyInput | BotRoutingConfigCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotRoutingConfig update
   */
  export type BotRoutingConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * The data needed to update a BotRoutingConfig.
     */
    data: XOR<BotRoutingConfigUpdateInput, BotRoutingConfigUncheckedUpdateInput>
    /**
     * Choose, which BotRoutingConfig to update.
     */
    where: BotRoutingConfigWhereUniqueInput
  }

  /**
   * BotRoutingConfig updateMany
   */
  export type BotRoutingConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotRoutingConfigs.
     */
    data: XOR<BotRoutingConfigUpdateManyMutationInput, BotRoutingConfigUncheckedUpdateManyInput>
    /**
     * Filter which BotRoutingConfigs to update
     */
    where?: BotRoutingConfigWhereInput
    /**
     * Limit how many BotRoutingConfigs to update.
     */
    limit?: number
  }

  /**
   * BotRoutingConfig updateManyAndReturn
   */
  export type BotRoutingConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * The data used to update BotRoutingConfigs.
     */
    data: XOR<BotRoutingConfigUpdateManyMutationInput, BotRoutingConfigUncheckedUpdateManyInput>
    /**
     * Filter which BotRoutingConfigs to update
     */
    where?: BotRoutingConfigWhereInput
    /**
     * Limit how many BotRoutingConfigs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotRoutingConfig upsert
   */
  export type BotRoutingConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * The filter to search for the BotRoutingConfig to update in case it exists.
     */
    where: BotRoutingConfigWhereUniqueInput
    /**
     * In case the BotRoutingConfig found by the `where` argument doesn't exist, create a new BotRoutingConfig with this data.
     */
    create: XOR<BotRoutingConfigCreateInput, BotRoutingConfigUncheckedCreateInput>
    /**
     * In case the BotRoutingConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotRoutingConfigUpdateInput, BotRoutingConfigUncheckedUpdateInput>
  }

  /**
   * BotRoutingConfig delete
   */
  export type BotRoutingConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
    /**
     * Filter which BotRoutingConfig to delete.
     */
    where: BotRoutingConfigWhereUniqueInput
  }

  /**
   * BotRoutingConfig deleteMany
   */
  export type BotRoutingConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotRoutingConfigs to delete
     */
    where?: BotRoutingConfigWhereInput
    /**
     * Limit how many BotRoutingConfigs to delete.
     */
    limit?: number
  }

  /**
   * BotRoutingConfig without action
   */
  export type BotRoutingConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotRoutingConfig
     */
    select?: BotRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotRoutingConfig
     */
    omit?: BotRoutingConfigOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotRoutingConfigInclude<ExtArgs> | null
  }


  /**
   * Model ComplexityRoutingConfig
   */

  export type AggregateComplexityRoutingConfig = {
    _count: ComplexityRoutingConfigCountAggregateOutputType | null
    _min: ComplexityRoutingConfigMinAggregateOutputType | null
    _max: ComplexityRoutingConfigMaxAggregateOutputType | null
  }

  export type ComplexityRoutingConfigMinAggregateOutputType = {
    id: string | null
    configId: string | null
    name: string | null
    description: string | null
    classifierModel: string | null
    classifierVendor: string | null
    toolMinComplexity: string | null
    isEnabled: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplexityRoutingConfigMaxAggregateOutputType = {
    id: string | null
    configId: string | null
    name: string | null
    description: string | null
    classifierModel: string | null
    classifierVendor: string | null
    toolMinComplexity: string | null
    isEnabled: boolean | null
    isBuiltin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ComplexityRoutingConfigCountAggregateOutputType = {
    id: number
    configId: number
    name: number
    description: number
    models: number
    classifierModel: number
    classifierVendor: number
    toolMinComplexity: number
    isEnabled: number
    isBuiltin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ComplexityRoutingConfigMinAggregateInputType = {
    id?: true
    configId?: true
    name?: true
    description?: true
    classifierModel?: true
    classifierVendor?: true
    toolMinComplexity?: true
    isEnabled?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplexityRoutingConfigMaxAggregateInputType = {
    id?: true
    configId?: true
    name?: true
    description?: true
    classifierModel?: true
    classifierVendor?: true
    toolMinComplexity?: true
    isEnabled?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ComplexityRoutingConfigCountAggregateInputType = {
    id?: true
    configId?: true
    name?: true
    description?: true
    models?: true
    classifierModel?: true
    classifierVendor?: true
    toolMinComplexity?: true
    isEnabled?: true
    isBuiltin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ComplexityRoutingConfigAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplexityRoutingConfig to aggregate.
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplexityRoutingConfigs to fetch.
     */
    orderBy?: ComplexityRoutingConfigOrderByWithRelationInput | ComplexityRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ComplexityRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ComplexityRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplexityRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ComplexityRoutingConfigs
    **/
    _count?: true | ComplexityRoutingConfigCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ComplexityRoutingConfigMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ComplexityRoutingConfigMaxAggregateInputType
  }

  export type GetComplexityRoutingConfigAggregateType<T extends ComplexityRoutingConfigAggregateArgs> = {
        [P in keyof T & keyof AggregateComplexityRoutingConfig]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateComplexityRoutingConfig[P]>
      : GetScalarType<T[P], AggregateComplexityRoutingConfig[P]>
  }




  export type ComplexityRoutingConfigGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ComplexityRoutingConfigWhereInput
    orderBy?: ComplexityRoutingConfigOrderByWithAggregationInput | ComplexityRoutingConfigOrderByWithAggregationInput[]
    by: ComplexityRoutingConfigScalarFieldEnum[] | ComplexityRoutingConfigScalarFieldEnum
    having?: ComplexityRoutingConfigScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ComplexityRoutingConfigCountAggregateInputType | true
    _min?: ComplexityRoutingConfigMinAggregateInputType
    _max?: ComplexityRoutingConfigMaxAggregateInputType
  }

  export type ComplexityRoutingConfigGroupByOutputType = {
    id: string
    configId: string
    name: string
    description: string | null
    models: JsonValue
    classifierModel: string
    classifierVendor: string
    toolMinComplexity: string | null
    isEnabled: boolean
    isBuiltin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    _count: ComplexityRoutingConfigCountAggregateOutputType | null
    _min: ComplexityRoutingConfigMinAggregateOutputType | null
    _max: ComplexityRoutingConfigMaxAggregateOutputType | null
  }

  type GetComplexityRoutingConfigGroupByPayload<T extends ComplexityRoutingConfigGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ComplexityRoutingConfigGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ComplexityRoutingConfigGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ComplexityRoutingConfigGroupByOutputType[P]>
            : GetScalarType<T[P], ComplexityRoutingConfigGroupByOutputType[P]>
        }
      >
    >


  export type ComplexityRoutingConfigSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    classifierModel?: boolean
    classifierVendor?: boolean
    toolMinComplexity?: boolean
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complexityRoutingConfig"]>

  export type ComplexityRoutingConfigSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    classifierModel?: boolean
    classifierVendor?: boolean
    toolMinComplexity?: boolean
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complexityRoutingConfig"]>

  export type ComplexityRoutingConfigSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    classifierModel?: boolean
    classifierVendor?: boolean
    toolMinComplexity?: boolean
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["complexityRoutingConfig"]>

  export type ComplexityRoutingConfigSelectScalar = {
    id?: boolean
    configId?: boolean
    name?: boolean
    description?: boolean
    models?: boolean
    classifierModel?: boolean
    classifierVendor?: boolean
    toolMinComplexity?: boolean
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ComplexityRoutingConfigOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "configId" | "name" | "description" | "models" | "classifierModel" | "classifierVendor" | "toolMinComplexity" | "isEnabled" | "isBuiltin" | "isDeleted" | "createdAt" | "updatedAt", ExtArgs["result"]["complexityRoutingConfig"]>

  export type $ComplexityRoutingConfigPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ComplexityRoutingConfig"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * é…ç½®å”¯ä¸€æ ‡è¯†ç¬¦
       */
      configId: string
      /**
       * é…ç½®åç§°
       */
      name: string
      /**
       * é…ç½®æè¿°
       */
      description: string | null
      /**
       * å„å¤æ‚åº¦å¯¹åº”çš„æ¨¡å‹é…ç½®ï¼ˆJSONï¼‰
       * æ ¼å¼: { super_easy: {vendor, model}, easy: {...}, medium: {...}, hard: {...}, super_hard: {...} }
       */
      models: Prisma.JsonValue
      /**
       * åˆ†ç±»å™¨ä½¿ç”¨çš„æ¨¡å‹
       */
      classifierModel: string
      /**
       * åˆ†ç±»å™¨ä½¿ç”¨çš„ vendor
       */
      classifierVendor: string
      /**
       * å·¥å…·è°ƒç”¨æ—¶çš„æœ€ä½å¤æ‚åº¦
       */
      toolMinComplexity: string | null
      /**
       * æ˜¯å¦å¯ç”¨
       */
      isEnabled: boolean
      /**
       * æ˜¯å¦ä¸ºå†…ç½®é…ç½®
       */
      isBuiltin: boolean
      /**
       * è½¯åˆ é™¤æ ‡è®°
       */
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["complexityRoutingConfig"]>
    composites: {}
  }

  type ComplexityRoutingConfigGetPayload<S extends boolean | null | undefined | ComplexityRoutingConfigDefaultArgs> = $Result.GetResult<Prisma.$ComplexityRoutingConfigPayload, S>

  type ComplexityRoutingConfigCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ComplexityRoutingConfigFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ComplexityRoutingConfigCountAggregateInputType | true
    }

  export interface ComplexityRoutingConfigDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ComplexityRoutingConfig'], meta: { name: 'ComplexityRoutingConfig' } }
    /**
     * Find zero or one ComplexityRoutingConfig that matches the filter.
     * @param {ComplexityRoutingConfigFindUniqueArgs} args - Arguments to find a ComplexityRoutingConfig
     * @example
     * // Get one ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ComplexityRoutingConfigFindUniqueArgs>(args: SelectSubset<T, ComplexityRoutingConfigFindUniqueArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ComplexityRoutingConfig that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ComplexityRoutingConfigFindUniqueOrThrowArgs} args - Arguments to find a ComplexityRoutingConfig
     * @example
     * // Get one ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ComplexityRoutingConfigFindUniqueOrThrowArgs>(args: SelectSubset<T, ComplexityRoutingConfigFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplexityRoutingConfig that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigFindFirstArgs} args - Arguments to find a ComplexityRoutingConfig
     * @example
     * // Get one ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ComplexityRoutingConfigFindFirstArgs>(args?: SelectSubset<T, ComplexityRoutingConfigFindFirstArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ComplexityRoutingConfig that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigFindFirstOrThrowArgs} args - Arguments to find a ComplexityRoutingConfig
     * @example
     * // Get one ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ComplexityRoutingConfigFindFirstOrThrowArgs>(args?: SelectSubset<T, ComplexityRoutingConfigFindFirstOrThrowArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ComplexityRoutingConfigs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ComplexityRoutingConfigs
     * const complexityRoutingConfigs = await prisma.complexityRoutingConfig.findMany()
     * 
     * // Get first 10 ComplexityRoutingConfigs
     * const complexityRoutingConfigs = await prisma.complexityRoutingConfig.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const complexityRoutingConfigWithIdOnly = await prisma.complexityRoutingConfig.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ComplexityRoutingConfigFindManyArgs>(args?: SelectSubset<T, ComplexityRoutingConfigFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ComplexityRoutingConfig.
     * @param {ComplexityRoutingConfigCreateArgs} args - Arguments to create a ComplexityRoutingConfig.
     * @example
     * // Create one ComplexityRoutingConfig
     * const ComplexityRoutingConfig = await prisma.complexityRoutingConfig.create({
     *   data: {
     *     // ... data to create a ComplexityRoutingConfig
     *   }
     * })
     * 
     */
    create<T extends ComplexityRoutingConfigCreateArgs>(args: SelectSubset<T, ComplexityRoutingConfigCreateArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ComplexityRoutingConfigs.
     * @param {ComplexityRoutingConfigCreateManyArgs} args - Arguments to create many ComplexityRoutingConfigs.
     * @example
     * // Create many ComplexityRoutingConfigs
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ComplexityRoutingConfigCreateManyArgs>(args?: SelectSubset<T, ComplexityRoutingConfigCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ComplexityRoutingConfigs and returns the data saved in the database.
     * @param {ComplexityRoutingConfigCreateManyAndReturnArgs} args - Arguments to create many ComplexityRoutingConfigs.
     * @example
     * // Create many ComplexityRoutingConfigs
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ComplexityRoutingConfigs and only return the `id`
     * const complexityRoutingConfigWithIdOnly = await prisma.complexityRoutingConfig.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ComplexityRoutingConfigCreateManyAndReturnArgs>(args?: SelectSubset<T, ComplexityRoutingConfigCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ComplexityRoutingConfig.
     * @param {ComplexityRoutingConfigDeleteArgs} args - Arguments to delete one ComplexityRoutingConfig.
     * @example
     * // Delete one ComplexityRoutingConfig
     * const ComplexityRoutingConfig = await prisma.complexityRoutingConfig.delete({
     *   where: {
     *     // ... filter to delete one ComplexityRoutingConfig
     *   }
     * })
     * 
     */
    delete<T extends ComplexityRoutingConfigDeleteArgs>(args: SelectSubset<T, ComplexityRoutingConfigDeleteArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ComplexityRoutingConfig.
     * @param {ComplexityRoutingConfigUpdateArgs} args - Arguments to update one ComplexityRoutingConfig.
     * @example
     * // Update one ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ComplexityRoutingConfigUpdateArgs>(args: SelectSubset<T, ComplexityRoutingConfigUpdateArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ComplexityRoutingConfigs.
     * @param {ComplexityRoutingConfigDeleteManyArgs} args - Arguments to filter ComplexityRoutingConfigs to delete.
     * @example
     * // Delete a few ComplexityRoutingConfigs
     * const { count } = await prisma.complexityRoutingConfig.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ComplexityRoutingConfigDeleteManyArgs>(args?: SelectSubset<T, ComplexityRoutingConfigDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplexityRoutingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ComplexityRoutingConfigs
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ComplexityRoutingConfigUpdateManyArgs>(args: SelectSubset<T, ComplexityRoutingConfigUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ComplexityRoutingConfigs and returns the data updated in the database.
     * @param {ComplexityRoutingConfigUpdateManyAndReturnArgs} args - Arguments to update many ComplexityRoutingConfigs.
     * @example
     * // Update many ComplexityRoutingConfigs
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ComplexityRoutingConfigs and only return the `id`
     * const complexityRoutingConfigWithIdOnly = await prisma.complexityRoutingConfig.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ComplexityRoutingConfigUpdateManyAndReturnArgs>(args: SelectSubset<T, ComplexityRoutingConfigUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ComplexityRoutingConfig.
     * @param {ComplexityRoutingConfigUpsertArgs} args - Arguments to update or create a ComplexityRoutingConfig.
     * @example
     * // Update or create a ComplexityRoutingConfig
     * const complexityRoutingConfig = await prisma.complexityRoutingConfig.upsert({
     *   create: {
     *     // ... data to create a ComplexityRoutingConfig
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ComplexityRoutingConfig we want to update
     *   }
     * })
     */
    upsert<T extends ComplexityRoutingConfigUpsertArgs>(args: SelectSubset<T, ComplexityRoutingConfigUpsertArgs<ExtArgs>>): Prisma__ComplexityRoutingConfigClient<$Result.GetResult<Prisma.$ComplexityRoutingConfigPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ComplexityRoutingConfigs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigCountArgs} args - Arguments to filter ComplexityRoutingConfigs to count.
     * @example
     * // Count the number of ComplexityRoutingConfigs
     * const count = await prisma.complexityRoutingConfig.count({
     *   where: {
     *     // ... the filter for the ComplexityRoutingConfigs we want to count
     *   }
     * })
    **/
    count<T extends ComplexityRoutingConfigCountArgs>(
      args?: Subset<T, ComplexityRoutingConfigCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ComplexityRoutingConfigCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ComplexityRoutingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ComplexityRoutingConfigAggregateArgs>(args: Subset<T, ComplexityRoutingConfigAggregateArgs>): Prisma.PrismaPromise<GetComplexityRoutingConfigAggregateType<T>>

    /**
     * Group by ComplexityRoutingConfig.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ComplexityRoutingConfigGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ComplexityRoutingConfigGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ComplexityRoutingConfigGroupByArgs['orderBy'] }
        : { orderBy?: ComplexityRoutingConfigGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ComplexityRoutingConfigGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetComplexityRoutingConfigGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ComplexityRoutingConfig model
   */
  readonly fields: ComplexityRoutingConfigFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ComplexityRoutingConfig.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ComplexityRoutingConfigClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ComplexityRoutingConfig model
   */
  interface ComplexityRoutingConfigFieldRefs {
    readonly id: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly configId: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly name: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly description: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly models: FieldRef<"ComplexityRoutingConfig", 'Json'>
    readonly classifierModel: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly classifierVendor: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly toolMinComplexity: FieldRef<"ComplexityRoutingConfig", 'String'>
    readonly isEnabled: FieldRef<"ComplexityRoutingConfig", 'Boolean'>
    readonly isBuiltin: FieldRef<"ComplexityRoutingConfig", 'Boolean'>
    readonly isDeleted: FieldRef<"ComplexityRoutingConfig", 'Boolean'>
    readonly createdAt: FieldRef<"ComplexityRoutingConfig", 'DateTime'>
    readonly updatedAt: FieldRef<"ComplexityRoutingConfig", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ComplexityRoutingConfig findUnique
   */
  export type ComplexityRoutingConfigFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter, which ComplexityRoutingConfig to fetch.
     */
    where: ComplexityRoutingConfigWhereUniqueInput
  }

  /**
   * ComplexityRoutingConfig findUniqueOrThrow
   */
  export type ComplexityRoutingConfigFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter, which ComplexityRoutingConfig to fetch.
     */
    where: ComplexityRoutingConfigWhereUniqueInput
  }

  /**
   * ComplexityRoutingConfig findFirst
   */
  export type ComplexityRoutingConfigFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter, which ComplexityRoutingConfig to fetch.
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplexityRoutingConfigs to fetch.
     */
    orderBy?: ComplexityRoutingConfigOrderByWithRelationInput | ComplexityRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplexityRoutingConfigs.
     */
    cursor?: ComplexityRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ComplexityRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplexityRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplexityRoutingConfigs.
     */
    distinct?: ComplexityRoutingConfigScalarFieldEnum | ComplexityRoutingConfigScalarFieldEnum[]
  }

  /**
   * ComplexityRoutingConfig findFirstOrThrow
   */
  export type ComplexityRoutingConfigFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter, which ComplexityRoutingConfig to fetch.
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplexityRoutingConfigs to fetch.
     */
    orderBy?: ComplexityRoutingConfigOrderByWithRelationInput | ComplexityRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ComplexityRoutingConfigs.
     */
    cursor?: ComplexityRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ComplexityRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplexityRoutingConfigs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ComplexityRoutingConfigs.
     */
    distinct?: ComplexityRoutingConfigScalarFieldEnum | ComplexityRoutingConfigScalarFieldEnum[]
  }

  /**
   * ComplexityRoutingConfig findMany
   */
  export type ComplexityRoutingConfigFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter, which ComplexityRoutingConfigs to fetch.
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ComplexityRoutingConfigs to fetch.
     */
    orderBy?: ComplexityRoutingConfigOrderByWithRelationInput | ComplexityRoutingConfigOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ComplexityRoutingConfigs.
     */
    cursor?: ComplexityRoutingConfigWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ComplexityRoutingConfigs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ComplexityRoutingConfigs.
     */
    skip?: number
    distinct?: ComplexityRoutingConfigScalarFieldEnum | ComplexityRoutingConfigScalarFieldEnum[]
  }

  /**
   * ComplexityRoutingConfig create
   */
  export type ComplexityRoutingConfigCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * The data needed to create a ComplexityRoutingConfig.
     */
    data: XOR<ComplexityRoutingConfigCreateInput, ComplexityRoutingConfigUncheckedCreateInput>
  }

  /**
   * ComplexityRoutingConfig createMany
   */
  export type ComplexityRoutingConfigCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ComplexityRoutingConfigs.
     */
    data: ComplexityRoutingConfigCreateManyInput | ComplexityRoutingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplexityRoutingConfig createManyAndReturn
   */
  export type ComplexityRoutingConfigCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * The data used to create many ComplexityRoutingConfigs.
     */
    data: ComplexityRoutingConfigCreateManyInput | ComplexityRoutingConfigCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ComplexityRoutingConfig update
   */
  export type ComplexityRoutingConfigUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * The data needed to update a ComplexityRoutingConfig.
     */
    data: XOR<ComplexityRoutingConfigUpdateInput, ComplexityRoutingConfigUncheckedUpdateInput>
    /**
     * Choose, which ComplexityRoutingConfig to update.
     */
    where: ComplexityRoutingConfigWhereUniqueInput
  }

  /**
   * ComplexityRoutingConfig updateMany
   */
  export type ComplexityRoutingConfigUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ComplexityRoutingConfigs.
     */
    data: XOR<ComplexityRoutingConfigUpdateManyMutationInput, ComplexityRoutingConfigUncheckedUpdateManyInput>
    /**
     * Filter which ComplexityRoutingConfigs to update
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * Limit how many ComplexityRoutingConfigs to update.
     */
    limit?: number
  }

  /**
   * ComplexityRoutingConfig updateManyAndReturn
   */
  export type ComplexityRoutingConfigUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * The data used to update ComplexityRoutingConfigs.
     */
    data: XOR<ComplexityRoutingConfigUpdateManyMutationInput, ComplexityRoutingConfigUncheckedUpdateManyInput>
    /**
     * Filter which ComplexityRoutingConfigs to update
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * Limit how many ComplexityRoutingConfigs to update.
     */
    limit?: number
  }

  /**
   * ComplexityRoutingConfig upsert
   */
  export type ComplexityRoutingConfigUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * The filter to search for the ComplexityRoutingConfig to update in case it exists.
     */
    where: ComplexityRoutingConfigWhereUniqueInput
    /**
     * In case the ComplexityRoutingConfig found by the `where` argument doesn't exist, create a new ComplexityRoutingConfig with this data.
     */
    create: XOR<ComplexityRoutingConfigCreateInput, ComplexityRoutingConfigUncheckedCreateInput>
    /**
     * In case the ComplexityRoutingConfig was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ComplexityRoutingConfigUpdateInput, ComplexityRoutingConfigUncheckedUpdateInput>
  }

  /**
   * ComplexityRoutingConfig delete
   */
  export type ComplexityRoutingConfigDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
    /**
     * Filter which ComplexityRoutingConfig to delete.
     */
    where: ComplexityRoutingConfigWhereUniqueInput
  }

  /**
   * ComplexityRoutingConfig deleteMany
   */
  export type ComplexityRoutingConfigDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ComplexityRoutingConfigs to delete
     */
    where?: ComplexityRoutingConfigWhereInput
    /**
     * Limit how many ComplexityRoutingConfigs to delete.
     */
    limit?: number
  }

  /**
   * ComplexityRoutingConfig without action
   */
  export type ComplexityRoutingConfigDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ComplexityRoutingConfig
     */
    select?: ComplexityRoutingConfigSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ComplexityRoutingConfig
     */
    omit?: ComplexityRoutingConfigOmit<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserInfoScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    code: 'code',
    avatarFileId: 'avatarFileId',
    sex: 'sex',
    locale: 'locale',
    isAnonymity: 'isAnonymity',
    isAdmin: 'isAdmin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    deviceId: 'deviceId',
    wechatOpenid: 'wechatOpenid',
    wechatUnionId: 'wechatUnionId',
    googleSub: 'googleSub',
    discordId: 'discordId',
    mobile: 'mobile',
    email: 'email'
  };

  export type UserInfoScalarFieldEnum = (typeof UserInfoScalarFieldEnum)[keyof typeof UserInfoScalarFieldEnum]


  export const PersonaTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    emoji: 'emoji',
    avatarFileId: 'avatarFileId',
    tagline: 'tagline',
    soulMarkdown: 'soulMarkdown',
    soulPreview: 'soulPreview',
    isSystem: 'isSystem',
    locale: 'locale',
    createdById: 'createdById',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PersonaTemplateScalarFieldEnum = (typeof PersonaTemplateScalarFieldEnum)[keyof typeof PersonaTemplateScalarFieldEnum]


  export const WechatAuthScalarFieldEnum: {
    openid: 'openid',
    sessionKey: 'sessionKey',
    refreshToken: 'refreshToken',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WechatAuthScalarFieldEnum = (typeof WechatAuthScalarFieldEnum)[keyof typeof WechatAuthScalarFieldEnum]


  export const GoogleAuthScalarFieldEnum: {
    sub: 'sub',
    email: 'email',
    verifiedEmail: 'verifiedEmail',
    atHash: 'atHash',
    name: 'name',
    picture: 'picture',
    givenName: 'givenName',
    familyName: 'familyName',
    exp: 'exp',
    iat: 'iat',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GoogleAuthScalarFieldEnum = (typeof GoogleAuthScalarFieldEnum)[keyof typeof GoogleAuthScalarFieldEnum]


  export const DiscordAuthScalarFieldEnum: {
    discordId: 'discordId',
    email: 'email',
    verifiedEmail: 'verifiedEmail',
    name: 'name',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DiscordAuthScalarFieldEnum = (typeof DiscordAuthScalarFieldEnum)[keyof typeof DiscordAuthScalarFieldEnum]


  export const MobileAuthScalarFieldEnum: {
    mobile: 'mobile',
    password: 'password',
    verified: 'verified',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type MobileAuthScalarFieldEnum = (typeof MobileAuthScalarFieldEnum)[keyof typeof MobileAuthScalarFieldEnum]


  export const EmailAuthScalarFieldEnum: {
    email: 'email',
    password: 'password',
    verified: 'verified',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmailAuthScalarFieldEnum = (typeof EmailAuthScalarFieldEnum)[keyof typeof EmailAuthScalarFieldEnum]


  export const RiskDetectionRecordScalarFieldEnum: {
    id: 'id',
    action: 'action',
    data: 'data',
    status: 'status',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RiskDetectionRecordScalarFieldEnum = (typeof RiskDetectionRecordScalarFieldEnum)[keyof typeof RiskDetectionRecordScalarFieldEnum]


  export const SystemTaskQueueScalarFieldEnum: {
    id: 'id',
    taskType: 'taskType',
    status: 'status',
    recipient: 'recipient',
    templateCode: 'templateCode',
    templateData: 'templateData',
    content: 'content',
    subject: 'subject',
    retryCount: 'retryCount',
    processedAt: 'processedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemTaskQueueScalarFieldEnum = (typeof SystemTaskQueueScalarFieldEnum)[keyof typeof SystemTaskQueueScalarFieldEnum]


  export const FileSourceScalarFieldEnum: {
    id: 'id',
    isUploaded: 'isUploaded',
    bucket: 'bucket',
    key: 'key',
    hash: 'hash',
    thumbImg: 'thumbImg',
    fsize: 'fsize',
    mimeType: 'mimeType',
    type: 'type',
    endUser: 'endUser',
    status: 'status',
    sha256: 'sha256',
    parts: 'parts',
    ext: 'ext',
    expireAt: 'expireAt',
    transitionToIaAt: 'transitionToIaAt',
    transitionToArchiveAt: 'transitionToArchiveAt',
    transitionToDeepArchiveAt: 'transitionToDeepArchiveAt',
    transitionToArchiveIRAt: 'transitionToArchiveIRAt',
    env: 'env',
    vendor: 'vendor',
    region: 'region',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FileSourceScalarFieldEnum = (typeof FileSourceScalarFieldEnum)[keyof typeof FileSourceScalarFieldEnum]


  export const CountryCodeScalarFieldEnum: {
    id: 'id',
    continent: 'continent',
    code: 'code',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CountryCodeScalarFieldEnum = (typeof CountryCodeScalarFieldEnum)[keyof typeof CountryCodeScalarFieldEnum]


  export const BotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    hostname: 'hostname',
    containerId: 'containerId',
    port: 'port',
    gatewayToken: 'gatewayToken',
    proxyTokenHash: 'proxyTokenHash',
    tags: 'tags',
    status: 'status',
    createdById: 'createdById',
    personaTemplateId: 'personaTemplateId',
    emoji: 'emoji',
    avatarFileId: 'avatarFileId',
    soulMarkdown: 'soulMarkdown',
    pendingConfig: 'pendingConfig',
    healthStatus: 'healthStatus',
    lastHealthCheck: 'lastHealthCheck',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BotScalarFieldEnum = (typeof BotScalarFieldEnum)[keyof typeof BotScalarFieldEnum]


  export const ProviderKeyScalarFieldEnum: {
    id: 'id',
    vendor: 'vendor',
    apiType: 'apiType',
    secretEncrypted: 'secretEncrypted',
    label: 'label',
    tag: 'tag',
    baseUrl: 'baseUrl',
    createdById: 'createdById',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProviderKeyScalarFieldEnum = (typeof ProviderKeyScalarFieldEnum)[keyof typeof ProviderKeyScalarFieldEnum]


  export const BotProviderKeyScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    providerKeyId: 'providerKeyId',
    isPrimary: 'isPrimary',
    allowedModels: 'allowedModels',
    primaryModel: 'primaryModel',
    createdAt: 'createdAt'
  };

  export type BotProviderKeyScalarFieldEnum = (typeof BotProviderKeyScalarFieldEnum)[keyof typeof BotProviderKeyScalarFieldEnum]


  export const BotUsageLogScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    vendor: 'vendor',
    providerKeyId: 'providerKeyId',
    statusCode: 'statusCode',
    requestTokens: 'requestTokens',
    responseTokens: 'responseTokens',
    createdAt: 'createdAt',
    model: 'model',
    endpoint: 'endpoint',
    durationMs: 'durationMs',
    errorMessage: 'errorMessage',
    thinkingTokens: 'thinkingTokens',
    cacheReadTokens: 'cacheReadTokens',
    cacheWriteTokens: 'cacheWriteTokens',
    protocolType: 'protocolType',
    inputCost: 'inputCost',
    outputCost: 'outputCost',
    thinkingCost: 'thinkingCost',
    cacheCost: 'cacheCost',
    totalCost: 'totalCost',
    fallbackUsed: 'fallbackUsed',
    fallbackLevel: 'fallbackLevel',
    originalModel: 'originalModel'
  };

  export type BotUsageLogScalarFieldEnum = (typeof BotUsageLogScalarFieldEnum)[keyof typeof BotUsageLogScalarFieldEnum]


  export const ProxyTokenScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    tokenHash: 'tokenHash',
    vendor: 'vendor',
    keyId: 'keyId',
    tags: 'tags',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    lastUsedAt: 'lastUsedAt',
    requestCount: 'requestCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProxyTokenScalarFieldEnum = (typeof ProxyTokenScalarFieldEnum)[keyof typeof ProxyTokenScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    senderId: 'senderId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageRecipientScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type MessageRecipientScalarFieldEnum = (typeof MessageRecipientScalarFieldEnum)[keyof typeof MessageRecipientScalarFieldEnum]


  export const OperateLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    operateType: 'operateType',
    target: 'target',
    targetId: 'targetId',
    targetName: 'targetName',
    detail: 'detail',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type OperateLogScalarFieldEnum = (typeof OperateLogScalarFieldEnum)[keyof typeof OperateLogScalarFieldEnum]


  export const ChannelDefinitionScalarFieldEnum: {
    id: 'id',
    label: 'label',
    icon: 'icon',
    popular: 'popular',
    popularLocales: 'popularLocales',
    tokenHint: 'tokenHint',
    tokenPlaceholder: 'tokenPlaceholder',
    helpUrl: 'helpUrl',
    helpText: 'helpText',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChannelDefinitionScalarFieldEnum = (typeof ChannelDefinitionScalarFieldEnum)[keyof typeof ChannelDefinitionScalarFieldEnum]


  export const ChannelCredentialFieldScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    key: 'key',
    label: 'label',
    placeholder: 'placeholder',
    fieldType: 'fieldType',
    required: 'required',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChannelCredentialFieldScalarFieldEnum = (typeof ChannelCredentialFieldScalarFieldEnum)[keyof typeof ChannelCredentialFieldScalarFieldEnum]


  export const PluginScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    version: 'version',
    author: 'author',
    category: 'category',
    region: 'region',
    configSchema: 'configSchema',
    defaultConfig: 'defaultConfig',
    mcpConfig: 'mcpConfig',
    isOfficial: 'isOfficial',
    isEnabled: 'isEnabled',
    downloadUrl: 'downloadUrl',
    iconEmoji: 'iconEmoji',
    iconUrl: 'iconUrl',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PluginScalarFieldEnum = (typeof PluginScalarFieldEnum)[keyof typeof PluginScalarFieldEnum]


  export const BotPluginScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    pluginId: 'pluginId',
    config: 'config',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotPluginScalarFieldEnum = (typeof BotPluginScalarFieldEnum)[keyof typeof BotPluginScalarFieldEnum]


  export const SkillTypeScalarFieldEnum: {
    id: 'id',
    slug: 'slug',
    name: 'name',
    nameZh: 'nameZh',
    description: 'description',
    descriptionZh: 'descriptionZh',
    icon: 'icon',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SkillTypeScalarFieldEnum = (typeof SkillTypeScalarFieldEnum)[keyof typeof SkillTypeScalarFieldEnum]


  export const SkillScalarFieldEnum: {
    id: 'id',
    name: 'name',
    nameZh: 'nameZh',
    slug: 'slug',
    description: 'description',
    descriptionZh: 'descriptionZh',
    version: 'version',
    skillTypeId: 'skillTypeId',
    definition: 'definition',
    examples: 'examples',
    isSystem: 'isSystem',
    isEnabled: 'isEnabled',
    createdById: 'createdById',
    source: 'source',
    sourceUrl: 'sourceUrl',
    author: 'author',
    lastSyncedAt: 'lastSyncedAt',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type SkillScalarFieldEnum = (typeof SkillScalarFieldEnum)[keyof typeof SkillScalarFieldEnum]


  export const BotSkillScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    skillId: 'skillId',
    config: 'config',
    isEnabled: 'isEnabled',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotSkillScalarFieldEnum = (typeof BotSkillScalarFieldEnum)[keyof typeof BotSkillScalarFieldEnum]


  export const ModelPricingScalarFieldEnum: {
    id: 'id',
    model: 'model',
    vendor: 'vendor',
    displayName: 'displayName',
    description: 'description',
    inputPrice: 'inputPrice',
    outputPrice: 'outputPrice',
    cacheReadPrice: 'cacheReadPrice',
    cacheWritePrice: 'cacheWritePrice',
    thinkingPrice: 'thinkingPrice',
    reasoningScore: 'reasoningScore',
    codingScore: 'codingScore',
    creativityScore: 'creativityScore',
    speedScore: 'speedScore',
    contextLength: 'contextLength',
    supportsExtendedThinking: 'supportsExtendedThinking',
    supportsCacheControl: 'supportsCacheControl',
    supportsVision: 'supportsVision',
    supportsFunctionCalling: 'supportsFunctionCalling',
    supportsStreaming: 'supportsStreaming',
    recommendedScenarios: 'recommendedScenarios',
    isEnabled: 'isEnabled',
    isDeprecated: 'isDeprecated',
    deprecationDate: 'deprecationDate',
    priceUpdatedAt: 'priceUpdatedAt',
    notes: 'notes',
    metadata: 'metadata',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ModelPricingScalarFieldEnum = (typeof ModelPricingScalarFieldEnum)[keyof typeof ModelPricingScalarFieldEnum]


  export const BotModelRoutingScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    routingType: 'routingType',
    name: 'name',
    config: 'config',
    priority: 'priority',
    isEnabled: 'isEnabled',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BotModelRoutingScalarFieldEnum = (typeof BotModelRoutingScalarFieldEnum)[keyof typeof BotModelRoutingScalarFieldEnum]


  export const BotChannelScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    channelType: 'channelType',
    name: 'name',
    credentialsEncrypted: 'credentialsEncrypted',
    config: 'config',
    isEnabled: 'isEnabled',
    connectionStatus: 'connectionStatus',
    lastConnectedAt: 'lastConnectedAt',
    lastError: 'lastError',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BotChannelScalarFieldEnum = (typeof BotChannelScalarFieldEnum)[keyof typeof BotChannelScalarFieldEnum]


  export const CapabilityTagScalarFieldEnum: {
    id: 'id',
    tagId: 'tagId',
    name: 'name',
    description: 'description',
    category: 'category',
    priority: 'priority',
    requiredProtocol: 'requiredProtocol',
    requiredSkills: 'requiredSkills',
    requiredModels: 'requiredModels',
    requiresExtendedThinking: 'requiresExtendedThinking',
    requiresCacheControl: 'requiresCacheControl',
    requiresVision: 'requiresVision',
    maxCostPerMToken: 'maxCostPerMToken',
    isActive: 'isActive',
    isBuiltin: 'isBuiltin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CapabilityTagScalarFieldEnum = (typeof CapabilityTagScalarFieldEnum)[keyof typeof CapabilityTagScalarFieldEnum]


  export const FallbackChainScalarFieldEnum: {
    id: 'id',
    chainId: 'chainId',
    name: 'name',
    description: 'description',
    models: 'models',
    triggerStatusCodes: 'triggerStatusCodes',
    triggerErrorTypes: 'triggerErrorTypes',
    triggerTimeoutMs: 'triggerTimeoutMs',
    maxRetries: 'maxRetries',
    retryDelayMs: 'retryDelayMs',
    preserveProtocol: 'preserveProtocol',
    isActive: 'isActive',
    isBuiltin: 'isBuiltin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FallbackChainScalarFieldEnum = (typeof FallbackChainScalarFieldEnum)[keyof typeof FallbackChainScalarFieldEnum]


  export const CostStrategyScalarFieldEnum: {
    id: 'id',
    strategyId: 'strategyId',
    name: 'name',
    description: 'description',
    costWeight: 'costWeight',
    performanceWeight: 'performanceWeight',
    capabilityWeight: 'capabilityWeight',
    maxCostPerRequest: 'maxCostPerRequest',
    maxLatencyMs: 'maxLatencyMs',
    minCapabilityScore: 'minCapabilityScore',
    scenarioWeights: 'scenarioWeights',
    isActive: 'isActive',
    isBuiltin: 'isBuiltin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CostStrategyScalarFieldEnum = (typeof CostStrategyScalarFieldEnum)[keyof typeof CostStrategyScalarFieldEnum]


  export const BotRoutingConfigScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    routingEnabled: 'routingEnabled',
    routingMode: 'routingMode',
    fallbackEnabled: 'fallbackEnabled',
    fallbackChainId: 'fallbackChainId',
    costControlEnabled: 'costControlEnabled',
    costStrategyId: 'costStrategyId',
    dailyBudget: 'dailyBudget',
    monthlyBudget: 'monthlyBudget',
    alertThreshold: 'alertThreshold',
    autoDowngrade: 'autoDowngrade',
    downgradeModel: 'downgradeModel',
    complexityRoutingEnabled: 'complexityRoutingEnabled',
    complexityRoutingConfigId: 'complexityRoutingConfigId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BotRoutingConfigScalarFieldEnum = (typeof BotRoutingConfigScalarFieldEnum)[keyof typeof BotRoutingConfigScalarFieldEnum]


  export const ComplexityRoutingConfigScalarFieldEnum: {
    id: 'id',
    configId: 'configId',
    name: 'name',
    description: 'description',
    models: 'models',
    classifierModel: 'classifierModel',
    classifierVendor: 'classifierVendor',
    toolMinComplexity: 'toolMinComplexity',
    isEnabled: 'isEnabled',
    isBuiltin: 'isBuiltin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ComplexityRoutingConfigScalarFieldEnum = (typeof ComplexityRoutingConfigScalarFieldEnum)[keyof typeof ComplexityRoutingConfigScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'SexType'
   */
  export type EnumSexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexType'>
    


  /**
   * Reference to a field of type 'SexType[]'
   */
  export type ListEnumSexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FileEnvType'
   */
  export type EnumFileEnvTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileEnvType'>
    


  /**
   * Reference to a field of type 'FileEnvType[]'
   */
  export type ListEnumFileEnvTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileEnvType[]'>
    


  /**
   * Reference to a field of type 'FileBucketVendor'
   */
  export type EnumFileBucketVendorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileBucketVendor'>
    


  /**
   * Reference to a field of type 'FileBucketVendor[]'
   */
  export type ListEnumFileBucketVendorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileBucketVendor[]'>
    


  /**
   * Reference to a field of type 'BotStatus'
   */
  export type EnumBotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BotStatus'>
    


  /**
   * Reference to a field of type 'BotStatus[]'
   */
  export type ListEnumBotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BotStatus[]'>
    


  /**
   * Reference to a field of type 'HealthStatus'
   */
  export type EnumHealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthStatus'>
    


  /**
   * Reference to a field of type 'HealthStatus[]'
   */
  export type ListEnumHealthStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HealthStatus[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'OperateType'
   */
  export type EnumOperateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateType'>
    


  /**
   * Reference to a field of type 'OperateType[]'
   */
  export type ListEnumOperateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateType[]'>
    


  /**
   * Reference to a field of type 'OperateTarget'
   */
  export type EnumOperateTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateTarget'>
    


  /**
   * Reference to a field of type 'OperateTarget[]'
   */
  export type ListEnumOperateTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateTarget[]'>
    


  /**
   * Reference to a field of type 'PluginCategory'
   */
  export type EnumPluginCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PluginCategory'>
    


  /**
   * Reference to a field of type 'PluginCategory[]'
   */
  export type ListEnumPluginCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PluginCategory[]'>
    


  /**
   * Reference to a field of type 'ModelRoutingType'
   */
  export type EnumModelRoutingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelRoutingType'>
    


  /**
   * Reference to a field of type 'ModelRoutingType[]'
   */
  export type ListEnumModelRoutingTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ModelRoutingType[]'>
    


  /**
   * Reference to a field of type 'ChannelConnectionStatus'
   */
  export type EnumChannelConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChannelConnectionStatus'>
    


  /**
   * Reference to a field of type 'ChannelConnectionStatus[]'
   */
  export type ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ChannelConnectionStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserInfoWhereInput = {
    AND?: UserInfoWhereInput | UserInfoWhereInput[]
    OR?: UserInfoWhereInput[]
    NOT?: UserInfoWhereInput | UserInfoWhereInput[]
    id?: UuidFilter<"UserInfo"> | string
    nickname?: StringFilter<"UserInfo"> | string
    code?: StringNullableFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableFilter<"UserInfo"> | string | null
    googleSub?: StringNullableFilter<"UserInfo"> | string | null
    discordId?: StringNullableFilter<"UserInfo"> | string | null
    mobile?: StringNullableFilter<"UserInfo"> | string | null
    email?: StringNullableFilter<"UserInfo"> | string | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    wechatAuth?: XOR<WechatAuthNullableScalarRelationFilter, WechatAuthWhereInput> | null
    googleAuth?: XOR<GoogleAuthNullableScalarRelationFilter, GoogleAuthWhereInput> | null
    discordAuth?: XOR<DiscordAuthNullableScalarRelationFilter, DiscordAuthWhereInput> | null
    mobileAuth?: XOR<MobileAuthNullableScalarRelationFilter, MobileAuthWhereInput> | null
    emailAuth?: XOR<EmailAuthNullableScalarRelationFilter, EmailAuthWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageRecipientListRelationFilter
    bots?: BotListRelationFilter
    providerKeys?: ProviderKeyListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    operateLogs?: OperateLogListRelationFilter
  }

  export type UserInfoOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    sex?: SortOrder
    locale?: SortOrderInput | SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    wechatOpenid?: SortOrderInput | SortOrder
    wechatUnionId?: SortOrderInput | SortOrder
    googleSub?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatarFile?: FileSourceOrderByWithRelationInput
    wechatAuth?: WechatAuthOrderByWithRelationInput
    googleAuth?: GoogleAuthOrderByWithRelationInput
    discordAuth?: DiscordAuthOrderByWithRelationInput
    mobileAuth?: MobileAuthOrderByWithRelationInput
    emailAuth?: EmailAuthOrderByWithRelationInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageRecipientOrderByRelationAggregateInput
    bots?: BotOrderByRelationAggregateInput
    providerKeys?: ProviderKeyOrderByRelationAggregateInput
    personaTemplates?: PersonaTemplateOrderByRelationAggregateInput
    operateLogs?: OperateLogOrderByRelationAggregateInput
  }

  export type UserInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    deviceId?: string
    wechatOpenid?: string
    wechatUnionId?: string
    googleSub?: string
    discordId?: string
    mobile?: string
    email?: string
    AND?: UserInfoWhereInput | UserInfoWhereInput[]
    OR?: UserInfoWhereInput[]
    NOT?: UserInfoWhereInput | UserInfoWhereInput[]
    nickname?: StringFilter<"UserInfo"> | string
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    wechatAuth?: XOR<WechatAuthNullableScalarRelationFilter, WechatAuthWhereInput> | null
    googleAuth?: XOR<GoogleAuthNullableScalarRelationFilter, GoogleAuthWhereInput> | null
    discordAuth?: XOR<DiscordAuthNullableScalarRelationFilter, DiscordAuthWhereInput> | null
    mobileAuth?: XOR<MobileAuthNullableScalarRelationFilter, MobileAuthWhereInput> | null
    emailAuth?: XOR<EmailAuthNullableScalarRelationFilter, EmailAuthWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageRecipientListRelationFilter
    bots?: BotListRelationFilter
    providerKeys?: ProviderKeyListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    operateLogs?: OperateLogListRelationFilter
  }, "id" | "code" | "deviceId" | "wechatOpenid" | "wechatUnionId" | "googleSub" | "discordId" | "mobile" | "email">

  export type UserInfoOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    sex?: SortOrder
    locale?: SortOrderInput | SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    wechatOpenid?: SortOrderInput | SortOrder
    wechatUnionId?: SortOrderInput | SortOrder
    googleSub?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: UserInfoCountOrderByAggregateInput
    _max?: UserInfoMaxOrderByAggregateInput
    _min?: UserInfoMinOrderByAggregateInput
  }

  export type UserInfoScalarWhereWithAggregatesInput = {
    AND?: UserInfoScalarWhereWithAggregatesInput | UserInfoScalarWhereWithAggregatesInput[]
    OR?: UserInfoScalarWhereWithAggregatesInput[]
    NOT?: UserInfoScalarWhereWithAggregatesInput | UserInfoScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserInfo"> | string
    nickname?: StringWithAggregatesFilter<"UserInfo"> | string
    code?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeWithAggregatesFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    isAnonymity?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    googleSub?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    discordId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    email?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
  }

  export type PersonaTemplateWhereInput = {
    AND?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    OR?: PersonaTemplateWhereInput[]
    NOT?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    id?: UuidFilter<"PersonaTemplate"> | string
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    locale?: StringFilter<"PersonaTemplate"> | string
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
    createdBy?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    bots?: BotListRelationFilter
  }

  export type PersonaTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    locale?: SortOrder
    createdById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    avatarFile?: FileSourceOrderByWithRelationInput
    bots?: BotOrderByRelationAggregateInput
  }

  export type PersonaTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    OR?: PersonaTemplateWhereInput[]
    NOT?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    locale?: StringFilter<"PersonaTemplate"> | string
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
    createdBy?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    bots?: BotListRelationFilter
  }, "id">

  export type PersonaTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    locale?: SortOrder
    createdById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PersonaTemplateCountOrderByAggregateInput
    _max?: PersonaTemplateMaxOrderByAggregateInput
    _min?: PersonaTemplateMinOrderByAggregateInput
  }

  export type PersonaTemplateScalarWhereWithAggregatesInput = {
    AND?: PersonaTemplateScalarWhereWithAggregatesInput | PersonaTemplateScalarWhereWithAggregatesInput[]
    OR?: PersonaTemplateScalarWhereWithAggregatesInput[]
    NOT?: PersonaTemplateScalarWhereWithAggregatesInput | PersonaTemplateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PersonaTemplate"> | string
    name?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    emoji?: StringNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    tagline?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"PersonaTemplate"> | boolean
    locale?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    createdById?: UuidNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PersonaTemplate"> | Date | string | null
  }

  export type WechatAuthWhereInput = {
    AND?: WechatAuthWhereInput | WechatAuthWhereInput[]
    OR?: WechatAuthWhereInput[]
    NOT?: WechatAuthWhereInput | WechatAuthWhereInput[]
    openid?: StringFilter<"WechatAuth"> | string
    sessionKey?: StringNullableFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableFilter<"WechatAuth"> | string | null
    isDeleted?: BoolFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WechatAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type WechatAuthOrderByWithRelationInput = {
    openid?: SortOrder
    sessionKey?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type WechatAuthWhereUniqueInput = Prisma.AtLeast<{
    openid?: string
    AND?: WechatAuthWhereInput | WechatAuthWhereInput[]
    OR?: WechatAuthWhereInput[]
    NOT?: WechatAuthWhereInput | WechatAuthWhereInput[]
    sessionKey?: StringNullableFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableFilter<"WechatAuth"> | string | null
    isDeleted?: BoolFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WechatAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "openid">

  export type WechatAuthOrderByWithAggregationInput = {
    openid?: SortOrder
    sessionKey?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WechatAuthCountOrderByAggregateInput
    _max?: WechatAuthMaxOrderByAggregateInput
    _min?: WechatAuthMinOrderByAggregateInput
  }

  export type WechatAuthScalarWhereWithAggregatesInput = {
    AND?: WechatAuthScalarWhereWithAggregatesInput | WechatAuthScalarWhereWithAggregatesInput[]
    OR?: WechatAuthScalarWhereWithAggregatesInput[]
    NOT?: WechatAuthScalarWhereWithAggregatesInput | WechatAuthScalarWhereWithAggregatesInput[]
    openid?: StringWithAggregatesFilter<"WechatAuth"> | string
    sessionKey?: StringNullableWithAggregatesFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"WechatAuth"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WechatAuth"> | Date | string | null
  }

  export type GoogleAuthWhereInput = {
    AND?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    OR?: GoogleAuthWhereInput[]
    NOT?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    sub?: StringFilter<"GoogleAuth"> | string
    email?: StringFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableFilter<"GoogleAuth"> | string | null
    name?: StringNullableFilter<"GoogleAuth"> | string | null
    picture?: StringNullableFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableFilter<"GoogleAuth"> | string | null
    exp?: IntFilter<"GoogleAuth"> | number
    iat?: IntFilter<"GoogleAuth"> | number
    isDeleted?: BoolFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"GoogleAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type GoogleAuthOrderByWithRelationInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    familyName?: SortOrderInput | SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type GoogleAuthWhereUniqueInput = Prisma.AtLeast<{
    sub?: string
    AND?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    OR?: GoogleAuthWhereInput[]
    NOT?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    email?: StringFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableFilter<"GoogleAuth"> | string | null
    name?: StringNullableFilter<"GoogleAuth"> | string | null
    picture?: StringNullableFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableFilter<"GoogleAuth"> | string | null
    exp?: IntFilter<"GoogleAuth"> | number
    iat?: IntFilter<"GoogleAuth"> | number
    isDeleted?: BoolFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"GoogleAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "sub">

  export type GoogleAuthOrderByWithAggregationInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    familyName?: SortOrderInput | SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GoogleAuthCountOrderByAggregateInput
    _avg?: GoogleAuthAvgOrderByAggregateInput
    _max?: GoogleAuthMaxOrderByAggregateInput
    _min?: GoogleAuthMinOrderByAggregateInput
    _sum?: GoogleAuthSumOrderByAggregateInput
  }

  export type GoogleAuthScalarWhereWithAggregatesInput = {
    AND?: GoogleAuthScalarWhereWithAggregatesInput | GoogleAuthScalarWhereWithAggregatesInput[]
    OR?: GoogleAuthScalarWhereWithAggregatesInput[]
    NOT?: GoogleAuthScalarWhereWithAggregatesInput | GoogleAuthScalarWhereWithAggregatesInput[]
    sub?: StringWithAggregatesFilter<"GoogleAuth"> | string
    email?: StringWithAggregatesFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolWithAggregatesFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    name?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    picture?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    exp?: IntWithAggregatesFilter<"GoogleAuth"> | number
    iat?: IntWithAggregatesFilter<"GoogleAuth"> | number
    isDeleted?: BoolWithAggregatesFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"GoogleAuth"> | Date | string | null
  }

  export type DiscordAuthWhereInput = {
    AND?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    OR?: DiscordAuthWhereInput[]
    NOT?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    discordId?: StringFilter<"DiscordAuth"> | string
    email?: StringFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolFilter<"DiscordAuth"> | boolean
    name?: StringNullableFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DiscordAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type DiscordAuthOrderByWithRelationInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type DiscordAuthWhereUniqueInput = Prisma.AtLeast<{
    discordId?: string
    AND?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    OR?: DiscordAuthWhereInput[]
    NOT?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    email?: StringFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolFilter<"DiscordAuth"> | boolean
    name?: StringNullableFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DiscordAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "discordId">

  export type DiscordAuthOrderByWithAggregationInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DiscordAuthCountOrderByAggregateInput
    _max?: DiscordAuthMaxOrderByAggregateInput
    _min?: DiscordAuthMinOrderByAggregateInput
  }

  export type DiscordAuthScalarWhereWithAggregatesInput = {
    AND?: DiscordAuthScalarWhereWithAggregatesInput | DiscordAuthScalarWhereWithAggregatesInput[]
    OR?: DiscordAuthScalarWhereWithAggregatesInput[]
    NOT?: DiscordAuthScalarWhereWithAggregatesInput | DiscordAuthScalarWhereWithAggregatesInput[]
    discordId?: StringWithAggregatesFilter<"DiscordAuth"> | string
    email?: StringWithAggregatesFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolWithAggregatesFilter<"DiscordAuth"> | boolean
    name?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DiscordAuth"> | Date | string | null
  }

  export type MobileAuthWhereInput = {
    AND?: MobileAuthWhereInput | MobileAuthWhereInput[]
    OR?: MobileAuthWhereInput[]
    NOT?: MobileAuthWhereInput | MobileAuthWhereInput[]
    mobile?: StringFilter<"MobileAuth"> | string
    password?: StringFilter<"MobileAuth"> | string
    verified?: BoolFilter<"MobileAuth"> | boolean
    isDeleted?: BoolFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MobileAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type MobileAuthOrderByWithRelationInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type MobileAuthWhereUniqueInput = Prisma.AtLeast<{
    mobile?: string
    AND?: MobileAuthWhereInput | MobileAuthWhereInput[]
    OR?: MobileAuthWhereInput[]
    NOT?: MobileAuthWhereInput | MobileAuthWhereInput[]
    password?: StringFilter<"MobileAuth"> | string
    verified?: BoolFilter<"MobileAuth"> | boolean
    isDeleted?: BoolFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MobileAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "mobile">

  export type MobileAuthOrderByWithAggregationInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MobileAuthCountOrderByAggregateInput
    _max?: MobileAuthMaxOrderByAggregateInput
    _min?: MobileAuthMinOrderByAggregateInput
  }

  export type MobileAuthScalarWhereWithAggregatesInput = {
    AND?: MobileAuthScalarWhereWithAggregatesInput | MobileAuthScalarWhereWithAggregatesInput[]
    OR?: MobileAuthScalarWhereWithAggregatesInput[]
    NOT?: MobileAuthScalarWhereWithAggregatesInput | MobileAuthScalarWhereWithAggregatesInput[]
    mobile?: StringWithAggregatesFilter<"MobileAuth"> | string
    password?: StringWithAggregatesFilter<"MobileAuth"> | string
    verified?: BoolWithAggregatesFilter<"MobileAuth"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MobileAuth"> | Date | string | null
  }

  export type EmailAuthWhereInput = {
    AND?: EmailAuthWhereInput | EmailAuthWhereInput[]
    OR?: EmailAuthWhereInput[]
    NOT?: EmailAuthWhereInput | EmailAuthWhereInput[]
    email?: StringFilter<"EmailAuth"> | string
    password?: StringFilter<"EmailAuth"> | string
    verified?: BoolFilter<"EmailAuth"> | boolean
    isDeleted?: BoolFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmailAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type EmailAuthOrderByWithRelationInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type EmailAuthWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: EmailAuthWhereInput | EmailAuthWhereInput[]
    OR?: EmailAuthWhereInput[]
    NOT?: EmailAuthWhereInput | EmailAuthWhereInput[]
    password?: StringFilter<"EmailAuth"> | string
    verified?: BoolFilter<"EmailAuth"> | boolean
    isDeleted?: BoolFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmailAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "email">

  export type EmailAuthOrderByWithAggregationInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmailAuthCountOrderByAggregateInput
    _max?: EmailAuthMaxOrderByAggregateInput
    _min?: EmailAuthMinOrderByAggregateInput
  }

  export type EmailAuthScalarWhereWithAggregatesInput = {
    AND?: EmailAuthScalarWhereWithAggregatesInput | EmailAuthScalarWhereWithAggregatesInput[]
    OR?: EmailAuthScalarWhereWithAggregatesInput[]
    NOT?: EmailAuthScalarWhereWithAggregatesInput | EmailAuthScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"EmailAuth"> | string
    password?: StringWithAggregatesFilter<"EmailAuth"> | string
    verified?: BoolWithAggregatesFilter<"EmailAuth"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmailAuth"> | Date | string | null
  }

  export type RiskDetectionRecordWhereInput = {
    AND?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    OR?: RiskDetectionRecordWhereInput[]
    NOT?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    id?: StringFilter<"RiskDetectionRecord"> | string
    action?: StringFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableFilter<"RiskDetectionRecord">
    status?: IntFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RiskDetectionRecord"> | Date | string | null
  }

  export type RiskDetectionRecordOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type RiskDetectionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    OR?: RiskDetectionRecordWhereInput[]
    NOT?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    action?: StringFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableFilter<"RiskDetectionRecord">
    status?: IntFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RiskDetectionRecord"> | Date | string | null
  }, "id">

  export type RiskDetectionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RiskDetectionRecordCountOrderByAggregateInput
    _avg?: RiskDetectionRecordAvgOrderByAggregateInput
    _max?: RiskDetectionRecordMaxOrderByAggregateInput
    _min?: RiskDetectionRecordMinOrderByAggregateInput
    _sum?: RiskDetectionRecordSumOrderByAggregateInput
  }

  export type RiskDetectionRecordScalarWhereWithAggregatesInput = {
    AND?: RiskDetectionRecordScalarWhereWithAggregatesInput | RiskDetectionRecordScalarWhereWithAggregatesInput[]
    OR?: RiskDetectionRecordScalarWhereWithAggregatesInput[]
    NOT?: RiskDetectionRecordScalarWhereWithAggregatesInput | RiskDetectionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskDetectionRecord"> | string
    action?: StringWithAggregatesFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableWithAggregatesFilter<"RiskDetectionRecord">
    status?: IntWithAggregatesFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolWithAggregatesFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RiskDetectionRecord"> | Date | string | null
  }

  export type SystemTaskQueueWhereInput = {
    AND?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    OR?: SystemTaskQueueWhereInput[]
    NOT?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    id?: UuidFilter<"SystemTaskQueue"> | string
    taskType?: EnumTaskTypeFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableFilter<"SystemTaskQueue">
    content?: StringNullableFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableFilter<"SystemTaskQueue">
    createdAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
  }

  export type SystemTaskQueueOrderByWithRelationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateData?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    OR?: SystemTaskQueueWhereInput[]
    NOT?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    taskType?: EnumTaskTypeFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableFilter<"SystemTaskQueue">
    content?: StringNullableFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableFilter<"SystemTaskQueue">
    createdAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
  }, "id">

  export type SystemTaskQueueOrderByWithAggregationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateData?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemTaskQueueCountOrderByAggregateInput
    _avg?: SystemTaskQueueAvgOrderByAggregateInput
    _max?: SystemTaskQueueMaxOrderByAggregateInput
    _min?: SystemTaskQueueMinOrderByAggregateInput
    _sum?: SystemTaskQueueSumOrderByAggregateInput
  }

  export type SystemTaskQueueScalarWhereWithAggregatesInput = {
    AND?: SystemTaskQueueScalarWhereWithAggregatesInput | SystemTaskQueueScalarWhereWithAggregatesInput[]
    OR?: SystemTaskQueueScalarWhereWithAggregatesInput[]
    NOT?: SystemTaskQueueScalarWhereWithAggregatesInput | SystemTaskQueueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemTaskQueue"> | string
    taskType?: EnumTaskTypeWithAggregatesFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusWithAggregatesFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringWithAggregatesFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableWithAggregatesFilter<"SystemTaskQueue">
    content?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntWithAggregatesFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SystemTaskQueue">
    createdAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
  }

  export type FileSourceWhereInput = {
    AND?: FileSourceWhereInput | FileSourceWhereInput[]
    OR?: FileSourceWhereInput[]
    NOT?: FileSourceWhereInput | FileSourceWhereInput[]
    id?: UuidFilter<"FileSource"> | string
    isUploaded?: BoolFilter<"FileSource"> | boolean
    bucket?: StringFilter<"FileSource"> | string
    key?: StringFilter<"FileSource"> | string
    hash?: StringNullableFilter<"FileSource"> | string | null
    thumbImg?: StringNullableFilter<"FileSource"> | string | null
    fsize?: FloatFilter<"FileSource"> | number
    mimeType?: StringFilter<"FileSource"> | string
    type?: IntFilter<"FileSource"> | number
    endUser?: StringNullableFilter<"FileSource"> | string | null
    status?: IntFilter<"FileSource"> | number
    sha256?: StringNullableFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringFilter<"FileSource"> | string
    expireAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringFilter<"FileSource"> | string
    isDeleted?: BoolFilter<"FileSource"> | boolean
    createdAt?: DateTimeFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    userAvatars?: UserInfoListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    botAvatars?: BotListRelationFilter
  }

  export type FileSourceOrderByWithRelationInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrderInput | SortOrder
    thumbImg?: SortOrderInput | SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrderInput | SortOrder
    status?: SortOrder
    sha256?: SortOrderInput | SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrderInput | SortOrder
    transitionToIaAt?: SortOrderInput | SortOrder
    transitionToArchiveAt?: SortOrderInput | SortOrder
    transitionToDeepArchiveAt?: SortOrderInput | SortOrder
    transitionToArchiveIRAt?: SortOrderInput | SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userAvatars?: UserInfoOrderByRelationAggregateInput
    personaTemplates?: PersonaTemplateOrderByRelationAggregateInput
    botAvatars?: BotOrderByRelationAggregateInput
  }

  export type FileSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: FileSourceWhereInput | FileSourceWhereInput[]
    OR?: FileSourceWhereInput[]
    NOT?: FileSourceWhereInput | FileSourceWhereInput[]
    isUploaded?: BoolFilter<"FileSource"> | boolean
    bucket?: StringFilter<"FileSource"> | string
    hash?: StringNullableFilter<"FileSource"> | string | null
    thumbImg?: StringNullableFilter<"FileSource"> | string | null
    fsize?: FloatFilter<"FileSource"> | number
    mimeType?: StringFilter<"FileSource"> | string
    type?: IntFilter<"FileSource"> | number
    endUser?: StringNullableFilter<"FileSource"> | string | null
    status?: IntFilter<"FileSource"> | number
    sha256?: StringNullableFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringFilter<"FileSource"> | string
    expireAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringFilter<"FileSource"> | string
    isDeleted?: BoolFilter<"FileSource"> | boolean
    createdAt?: DateTimeFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    userAvatars?: UserInfoListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    botAvatars?: BotListRelationFilter
  }, "id" | "key">

  export type FileSourceOrderByWithAggregationInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrderInput | SortOrder
    thumbImg?: SortOrderInput | SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrderInput | SortOrder
    status?: SortOrder
    sha256?: SortOrderInput | SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrderInput | SortOrder
    transitionToIaAt?: SortOrderInput | SortOrder
    transitionToArchiveAt?: SortOrderInput | SortOrder
    transitionToDeepArchiveAt?: SortOrderInput | SortOrder
    transitionToArchiveIRAt?: SortOrderInput | SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FileSourceCountOrderByAggregateInput
    _avg?: FileSourceAvgOrderByAggregateInput
    _max?: FileSourceMaxOrderByAggregateInput
    _min?: FileSourceMinOrderByAggregateInput
    _sum?: FileSourceSumOrderByAggregateInput
  }

  export type FileSourceScalarWhereWithAggregatesInput = {
    AND?: FileSourceScalarWhereWithAggregatesInput | FileSourceScalarWhereWithAggregatesInput[]
    OR?: FileSourceScalarWhereWithAggregatesInput[]
    NOT?: FileSourceScalarWhereWithAggregatesInput | FileSourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FileSource"> | string
    isUploaded?: BoolWithAggregatesFilter<"FileSource"> | boolean
    bucket?: StringWithAggregatesFilter<"FileSource"> | string
    key?: StringWithAggregatesFilter<"FileSource"> | string
    hash?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    thumbImg?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    fsize?: FloatWithAggregatesFilter<"FileSource"> | number
    mimeType?: StringWithAggregatesFilter<"FileSource"> | string
    type?: IntWithAggregatesFilter<"FileSource"> | number
    endUser?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    status?: IntWithAggregatesFilter<"FileSource"> | number
    sha256?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringWithAggregatesFilter<"FileSource"> | string
    expireAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeWithAggregatesFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorWithAggregatesFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringWithAggregatesFilter<"FileSource"> | string
    isDeleted?: BoolWithAggregatesFilter<"FileSource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
  }

  export type CountryCodeWhereInput = {
    AND?: CountryCodeWhereInput | CountryCodeWhereInput[]
    OR?: CountryCodeWhereInput[]
    NOT?: CountryCodeWhereInput | CountryCodeWhereInput[]
    id?: UuidFilter<"CountryCode"> | string
    continent?: StringFilter<"CountryCode"> | string
    code?: StringFilter<"CountryCode"> | string
    isDeleted?: BoolFilter<"CountryCode"> | boolean
    createdAt?: DateTimeFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CountryCode"> | Date | string | null
  }

  export type CountryCodeOrderByWithRelationInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type CountryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    continent_code?: CountryCodeContinentCodeCompoundUniqueInput
    AND?: CountryCodeWhereInput | CountryCodeWhereInput[]
    OR?: CountryCodeWhereInput[]
    NOT?: CountryCodeWhereInput | CountryCodeWhereInput[]
    continent?: StringFilter<"CountryCode"> | string
    code?: StringFilter<"CountryCode"> | string
    isDeleted?: BoolFilter<"CountryCode"> | boolean
    createdAt?: DateTimeFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CountryCode"> | Date | string | null
  }, "id" | "continent_code">

  export type CountryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CountryCodeCountOrderByAggregateInput
    _max?: CountryCodeMaxOrderByAggregateInput
    _min?: CountryCodeMinOrderByAggregateInput
  }

  export type CountryCodeScalarWhereWithAggregatesInput = {
    AND?: CountryCodeScalarWhereWithAggregatesInput | CountryCodeScalarWhereWithAggregatesInput[]
    OR?: CountryCodeScalarWhereWithAggregatesInput[]
    NOT?: CountryCodeScalarWhereWithAggregatesInput | CountryCodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CountryCode"> | string
    continent?: StringWithAggregatesFilter<"CountryCode"> | string
    code?: StringWithAggregatesFilter<"CountryCode"> | string
    isDeleted?: BoolWithAggregatesFilter<"CountryCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CountryCode"> | Date | string | null
  }

  export type BotWhereInput = {
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    id?: UuidFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    pendingConfig?: JsonNullableFilter<"Bot">
    healthStatus?: EnumHealthStatusFilter<"Bot"> | $Enums.HealthStatus
    lastHealthCheck?: DateTimeNullableFilter<"Bot"> | Date | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    personaTemplate?: XOR<PersonaTemplateNullableScalarRelationFilter, PersonaTemplateWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    providerKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyToken?: XOR<ProxyTokenNullableScalarRelationFilter, ProxyTokenWhereInput> | null
    plugins?: BotPluginListRelationFilter
    skills?: BotSkillListRelationFilter
    channels?: BotChannelListRelationFilter
    modelRoutings?: BotModelRoutingListRelationFilter
    routingConfig?: XOR<BotRoutingConfigNullableScalarRelationFilter, BotRoutingConfigWhereInput> | null
  }

  export type BotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    containerId?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    gatewayToken?: SortOrderInput | SortOrder
    proxyTokenHash?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    soulMarkdown?: SortOrderInput | SortOrder
    pendingConfig?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    lastHealthCheck?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    personaTemplate?: PersonaTemplateOrderByWithRelationInput
    avatarFile?: FileSourceOrderByWithRelationInput
    providerKeys?: BotProviderKeyOrderByRelationAggregateInput
    usageLogs?: BotUsageLogOrderByRelationAggregateInput
    proxyToken?: ProxyTokenOrderByWithRelationInput
    plugins?: BotPluginOrderByRelationAggregateInput
    skills?: BotSkillOrderByRelationAggregateInput
    channels?: BotChannelOrderByRelationAggregateInput
    modelRoutings?: BotModelRoutingOrderByRelationAggregateInput
    routingConfig?: BotRoutingConfigOrderByWithRelationInput
  }

  export type BotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    pendingConfig?: JsonNullableFilter<"Bot">
    healthStatus?: EnumHealthStatusFilter<"Bot"> | $Enums.HealthStatus
    lastHealthCheck?: DateTimeNullableFilter<"Bot"> | Date | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    personaTemplate?: XOR<PersonaTemplateNullableScalarRelationFilter, PersonaTemplateWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    providerKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyToken?: XOR<ProxyTokenNullableScalarRelationFilter, ProxyTokenWhereInput> | null
    plugins?: BotPluginListRelationFilter
    skills?: BotSkillListRelationFilter
    channels?: BotChannelListRelationFilter
    modelRoutings?: BotModelRoutingListRelationFilter
    routingConfig?: XOR<BotRoutingConfigNullableScalarRelationFilter, BotRoutingConfigWhereInput> | null
  }, "id">

  export type BotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    containerId?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    gatewayToken?: SortOrderInput | SortOrder
    proxyTokenHash?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    soulMarkdown?: SortOrderInput | SortOrder
    pendingConfig?: SortOrderInput | SortOrder
    healthStatus?: SortOrder
    lastHealthCheck?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BotCountOrderByAggregateInput
    _avg?: BotAvgOrderByAggregateInput
    _max?: BotMaxOrderByAggregateInput
    _min?: BotMinOrderByAggregateInput
    _sum?: BotSumOrderByAggregateInput
  }

  export type BotScalarWhereWithAggregatesInput = {
    AND?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    OR?: BotScalarWhereWithAggregatesInput[]
    NOT?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Bot"> | string
    name?: StringWithAggregatesFilter<"Bot"> | string
    hostname?: StringWithAggregatesFilter<"Bot"> | string
    containerId?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    port?: IntNullableWithAggregatesFilter<"Bot"> | number | null
    gatewayToken?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusWithAggregatesFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidWithAggregatesFilter<"Bot"> | string
    personaTemplateId?: UuidNullableWithAggregatesFilter<"Bot"> | string | null
    emoji?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    pendingConfig?: JsonNullableWithAggregatesFilter<"Bot">
    healthStatus?: EnumHealthStatusWithAggregatesFilter<"Bot"> | $Enums.HealthStatus
    lastHealthCheck?: DateTimeNullableWithAggregatesFilter<"Bot"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Bot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Bot"> | Date | string | null
  }

  export type ProviderKeyWhereInput = {
    AND?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    OR?: ProviderKeyWhereInput[]
    NOT?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    id?: UuidFilter<"ProviderKey"> | string
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    botProviderKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyTokens?: ProxyTokenListRelationFilter
  }

  export type ProviderKeyOrderByWithRelationInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrderInput | SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    botProviderKeys?: BotProviderKeyOrderByRelationAggregateInput
    usageLogs?: BotUsageLogOrderByRelationAggregateInput
    proxyTokens?: ProxyTokenOrderByRelationAggregateInput
  }

  export type ProviderKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_key_user_label_unique?: ProviderKeyProvider_key_user_label_uniqueCompoundUniqueInput
    AND?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    OR?: ProviderKeyWhereInput[]
    NOT?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    botProviderKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyTokens?: ProxyTokenListRelationFilter
  }, "id" | "provider_key_user_label_unique">

  export type ProviderKeyOrderByWithAggregationInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrderInput | SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProviderKeyCountOrderByAggregateInput
    _max?: ProviderKeyMaxOrderByAggregateInput
    _min?: ProviderKeyMinOrderByAggregateInput
  }

  export type ProviderKeyScalarWhereWithAggregatesInput = {
    AND?: ProviderKeyScalarWhereWithAggregatesInput | ProviderKeyScalarWhereWithAggregatesInput[]
    OR?: ProviderKeyScalarWhereWithAggregatesInput[]
    NOT?: ProviderKeyScalarWhereWithAggregatesInput | ProviderKeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProviderKey"> | string
    vendor?: StringWithAggregatesFilter<"ProviderKey"> | string
    apiType?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesWithAggregatesFilter<"ProviderKey"> | Bytes
    label?: StringWithAggregatesFilter<"ProviderKey"> | string
    tag?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    createdById?: UuidWithAggregatesFilter<"ProviderKey"> | string
    isDeleted?: BoolWithAggregatesFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProviderKey"> | Date | string | null
  }

  export type BotProviderKeyWhereInput = {
    AND?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    OR?: BotProviderKeyWhereInput[]
    NOT?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    id?: UuidFilter<"BotProviderKey"> | string
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    allowedModels?: StringNullableListFilter<"BotProviderKey">
    primaryModel?: StringNullableFilter<"BotProviderKey"> | string | null
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }

  export type BotProviderKeyOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    allowedModels?: SortOrder
    primaryModel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type BotProviderKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_providerKeyId?: BotProviderKeyBotIdProviderKeyIdCompoundUniqueInput
    AND?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    OR?: BotProviderKeyWhereInput[]
    NOT?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    allowedModels?: StringNullableListFilter<"BotProviderKey">
    primaryModel?: StringNullableFilter<"BotProviderKey"> | string | null
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }, "id" | "botId_providerKeyId">

  export type BotProviderKeyOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    allowedModels?: SortOrder
    primaryModel?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BotProviderKeyCountOrderByAggregateInput
    _max?: BotProviderKeyMaxOrderByAggregateInput
    _min?: BotProviderKeyMinOrderByAggregateInput
  }

  export type BotProviderKeyScalarWhereWithAggregatesInput = {
    AND?: BotProviderKeyScalarWhereWithAggregatesInput | BotProviderKeyScalarWhereWithAggregatesInput[]
    OR?: BotProviderKeyScalarWhereWithAggregatesInput[]
    NOT?: BotProviderKeyScalarWhereWithAggregatesInput | BotProviderKeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    botId?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    providerKeyId?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    isPrimary?: BoolWithAggregatesFilter<"BotProviderKey"> | boolean
    allowedModels?: StringNullableListFilter<"BotProviderKey">
    primaryModel?: StringNullableWithAggregatesFilter<"BotProviderKey"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BotProviderKey"> | Date | string
  }

  export type BotUsageLogWhereInput = {
    AND?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    OR?: BotUsageLogWhereInput[]
    NOT?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    id?: UuidFilter<"BotUsageLog"> | string
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
    model?: StringNullableFilter<"BotUsageLog"> | string | null
    endpoint?: StringNullableFilter<"BotUsageLog"> | string | null
    durationMs?: IntNullableFilter<"BotUsageLog"> | number | null
    errorMessage?: StringNullableFilter<"BotUsageLog"> | string | null
    thinkingTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheReadTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheWriteTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    protocolType?: StringNullableFilter<"BotUsageLog"> | string | null
    inputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    cacheCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: BoolNullableFilter<"BotUsageLog"> | boolean | null
    fallbackLevel?: IntNullableFilter<"BotUsageLog"> | number | null
    originalModel?: StringNullableFilter<"BotUsageLog"> | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyNullableScalarRelationFilter, ProviderKeyWhereInput> | null
  }

  export type BotUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestTokens?: SortOrderInput | SortOrder
    responseTokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    model?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    thinkingTokens?: SortOrderInput | SortOrder
    cacheReadTokens?: SortOrderInput | SortOrder
    cacheWriteTokens?: SortOrderInput | SortOrder
    protocolType?: SortOrderInput | SortOrder
    inputCost?: SortOrderInput | SortOrder
    outputCost?: SortOrderInput | SortOrder
    thinkingCost?: SortOrderInput | SortOrder
    cacheCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    fallbackUsed?: SortOrderInput | SortOrder
    fallbackLevel?: SortOrderInput | SortOrder
    originalModel?: SortOrderInput | SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type BotUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    OR?: BotUsageLogWhereInput[]
    NOT?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
    model?: StringNullableFilter<"BotUsageLog"> | string | null
    endpoint?: StringNullableFilter<"BotUsageLog"> | string | null
    durationMs?: IntNullableFilter<"BotUsageLog"> | number | null
    errorMessage?: StringNullableFilter<"BotUsageLog"> | string | null
    thinkingTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheReadTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheWriteTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    protocolType?: StringNullableFilter<"BotUsageLog"> | string | null
    inputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    cacheCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: BoolNullableFilter<"BotUsageLog"> | boolean | null
    fallbackLevel?: IntNullableFilter<"BotUsageLog"> | number | null
    originalModel?: StringNullableFilter<"BotUsageLog"> | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyNullableScalarRelationFilter, ProviderKeyWhereInput> | null
  }, "id">

  export type BotUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestTokens?: SortOrderInput | SortOrder
    responseTokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    model?: SortOrderInput | SortOrder
    endpoint?: SortOrderInput | SortOrder
    durationMs?: SortOrderInput | SortOrder
    errorMessage?: SortOrderInput | SortOrder
    thinkingTokens?: SortOrderInput | SortOrder
    cacheReadTokens?: SortOrderInput | SortOrder
    cacheWriteTokens?: SortOrderInput | SortOrder
    protocolType?: SortOrderInput | SortOrder
    inputCost?: SortOrderInput | SortOrder
    outputCost?: SortOrderInput | SortOrder
    thinkingCost?: SortOrderInput | SortOrder
    cacheCost?: SortOrderInput | SortOrder
    totalCost?: SortOrderInput | SortOrder
    fallbackUsed?: SortOrderInput | SortOrder
    fallbackLevel?: SortOrderInput | SortOrder
    originalModel?: SortOrderInput | SortOrder
    _count?: BotUsageLogCountOrderByAggregateInput
    _avg?: BotUsageLogAvgOrderByAggregateInput
    _max?: BotUsageLogMaxOrderByAggregateInput
    _min?: BotUsageLogMinOrderByAggregateInput
    _sum?: BotUsageLogSumOrderByAggregateInput
  }

  export type BotUsageLogScalarWhereWithAggregatesInput = {
    AND?: BotUsageLogScalarWhereWithAggregatesInput | BotUsageLogScalarWhereWithAggregatesInput[]
    OR?: BotUsageLogScalarWhereWithAggregatesInput[]
    NOT?: BotUsageLogScalarWhereWithAggregatesInput | BotUsageLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotUsageLog"> | string
    botId?: UuidWithAggregatesFilter<"BotUsageLog"> | string
    vendor?: StringWithAggregatesFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BotUsageLog"> | Date | string
    model?: StringNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    endpoint?: StringNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    durationMs?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    errorMessage?: StringNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    thinkingTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    cacheReadTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    cacheWriteTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    protocolType?: StringNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    inputCost?: DecimalNullableWithAggregatesFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableWithAggregatesFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: DecimalNullableWithAggregatesFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    cacheCost?: DecimalNullableWithAggregatesFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableWithAggregatesFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: BoolNullableWithAggregatesFilter<"BotUsageLog"> | boolean | null
    fallbackLevel?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    originalModel?: StringNullableWithAggregatesFilter<"BotUsageLog"> | string | null
  }

  export type ProxyTokenWhereInput = {
    AND?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    OR?: ProxyTokenWhereInput[]
    NOT?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    id?: UuidFilter<"ProxyToken"> | string
    botId?: UuidFilter<"ProxyToken"> | string
    tokenHash?: StringFilter<"ProxyToken"> | string
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }

  export type ProxyTokenOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type ProxyTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId?: string
    tokenHash?: string
    AND?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    OR?: ProxyTokenWhereInput[]
    NOT?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }, "id" | "botId" | "tokenHash">

  export type ProxyTokenOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProxyTokenCountOrderByAggregateInput
    _avg?: ProxyTokenAvgOrderByAggregateInput
    _max?: ProxyTokenMaxOrderByAggregateInput
    _min?: ProxyTokenMinOrderByAggregateInput
    _sum?: ProxyTokenSumOrderByAggregateInput
  }

  export type ProxyTokenScalarWhereWithAggregatesInput = {
    AND?: ProxyTokenScalarWhereWithAggregatesInput | ProxyTokenScalarWhereWithAggregatesInput[]
    OR?: ProxyTokenScalarWhereWithAggregatesInput[]
    NOT?: ProxyTokenScalarWhereWithAggregatesInput | ProxyTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProxyToken"> | string
    botId?: UuidWithAggregatesFilter<"ProxyToken"> | string
    tokenHash?: StringWithAggregatesFilter<"ProxyToken"> | string
    vendor?: StringWithAggregatesFilter<"ProxyToken"> | string
    keyId?: UuidWithAggregatesFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntWithAggregatesFilter<"ProxyToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProxyToken"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sender?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    recipients?: MessageRecipientListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    senderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sender?: UserInfoOrderByWithRelationInput
    recipients?: MessageRecipientOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sender?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    recipients?: MessageRecipientListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    senderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    title?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: JsonWithAggregatesFilter<"Message">
    senderId?: UuidNullableWithAggregatesFilter<"Message"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type MessageRecipientWhereInput = {
    AND?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    OR?: MessageRecipientWhereInput[]
    NOT?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    id?: UuidFilter<"MessageRecipient"> | string
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type MessageRecipientOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserInfoOrderByWithRelationInput
  }

  export type MessageRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageRecipientMessageIdUserIdCompoundUniqueInput
    AND?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    OR?: MessageRecipientWhereInput[]
    NOT?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "id" | "messageId_userId">

  export type MessageRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageRecipientCountOrderByAggregateInput
    _max?: MessageRecipientMaxOrderByAggregateInput
    _min?: MessageRecipientMinOrderByAggregateInput
  }

  export type MessageRecipientScalarWhereWithAggregatesInput = {
    AND?: MessageRecipientScalarWhereWithAggregatesInput | MessageRecipientScalarWhereWithAggregatesInput[]
    OR?: MessageRecipientScalarWhereWithAggregatesInput[]
    NOT?: MessageRecipientScalarWhereWithAggregatesInput | MessageRecipientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    messageId?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    userId?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    isRead?: BoolWithAggregatesFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MessageRecipient"> | Date | string | null
  }

  export type OperateLogWhereInput = {
    AND?: OperateLogWhereInput | OperateLogWhereInput[]
    OR?: OperateLogWhereInput[]
    NOT?: OperateLogWhereInput | OperateLogWhereInput[]
    id?: UuidFilter<"OperateLog"> | string
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type OperateLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type OperateLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperateLogWhereInput | OperateLogWhereInput[]
    OR?: OperateLogWhereInput[]
    NOT?: OperateLogWhereInput | OperateLogWhereInput[]
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "id">

  export type OperateLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OperateLogCountOrderByAggregateInput
    _max?: OperateLogMaxOrderByAggregateInput
    _min?: OperateLogMinOrderByAggregateInput
  }

  export type OperateLogScalarWhereWithAggregatesInput = {
    AND?: OperateLogScalarWhereWithAggregatesInput | OperateLogScalarWhereWithAggregatesInput[]
    OR?: OperateLogScalarWhereWithAggregatesInput[]
    NOT?: OperateLogScalarWhereWithAggregatesInput | OperateLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OperateLog"> | string
    userId?: UuidWithAggregatesFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeWithAggregatesFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetWithAggregatesFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableWithAggregatesFilter<"OperateLog"> | string | null
    targetName?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    detail?: JsonNullableWithAggregatesFilter<"OperateLog">
    ipAddress?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OperateLog"> | Date | string
  }

  export type ChannelDefinitionWhereInput = {
    AND?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    OR?: ChannelDefinitionWhereInput[]
    NOT?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    id?: StringFilter<"ChannelDefinition"> | string
    label?: StringFilter<"ChannelDefinition"> | string
    icon?: StringFilter<"ChannelDefinition"> | string
    popular?: BoolFilter<"ChannelDefinition"> | boolean
    popularLocales?: StringNullableListFilter<"ChannelDefinition">
    tokenHint?: StringFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntFilter<"ChannelDefinition"> | number
    isDeleted?: BoolFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelDefinition"> | Date | string | null
    credentialFields?: ChannelCredentialFieldListRelationFilter
  }

  export type ChannelDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    popularLocales?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    credentialFields?: ChannelCredentialFieldOrderByRelationAggregateInput
  }

  export type ChannelDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    OR?: ChannelDefinitionWhereInput[]
    NOT?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    label?: StringFilter<"ChannelDefinition"> | string
    icon?: StringFilter<"ChannelDefinition"> | string
    popular?: BoolFilter<"ChannelDefinition"> | boolean
    popularLocales?: StringNullableListFilter<"ChannelDefinition">
    tokenHint?: StringFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntFilter<"ChannelDefinition"> | number
    isDeleted?: BoolFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelDefinition"> | Date | string | null
    credentialFields?: ChannelCredentialFieldListRelationFilter
  }, "id">

  export type ChannelDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    popularLocales?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChannelDefinitionCountOrderByAggregateInput
    _avg?: ChannelDefinitionAvgOrderByAggregateInput
    _max?: ChannelDefinitionMaxOrderByAggregateInput
    _min?: ChannelDefinitionMinOrderByAggregateInput
    _sum?: ChannelDefinitionSumOrderByAggregateInput
  }

  export type ChannelDefinitionScalarWhereWithAggregatesInput = {
    AND?: ChannelDefinitionScalarWhereWithAggregatesInput | ChannelDefinitionScalarWhereWithAggregatesInput[]
    OR?: ChannelDefinitionScalarWhereWithAggregatesInput[]
    NOT?: ChannelDefinitionScalarWhereWithAggregatesInput | ChannelDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    label?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    icon?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    popular?: BoolWithAggregatesFilter<"ChannelDefinition"> | boolean
    popularLocales?: StringNullableListFilter<"ChannelDefinition">
    tokenHint?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableWithAggregatesFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableWithAggregatesFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ChannelDefinition"> | number
    isDeleted?: BoolWithAggregatesFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChannelDefinition"> | Date | string | null
  }

  export type ChannelCredentialFieldWhereInput = {
    AND?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    OR?: ChannelCredentialFieldWhereInput[]
    NOT?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    id?: UuidFilter<"ChannelCredentialField"> | string
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
    channel?: XOR<ChannelDefinitionScalarRelationFilter, ChannelDefinitionWhereInput>
  }

  export type ChannelCredentialFieldOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    channel?: ChannelDefinitionOrderByWithRelationInput
  }

  export type ChannelCredentialFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_key?: ChannelCredentialFieldChannelIdKeyCompoundUniqueInput
    AND?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    OR?: ChannelCredentialFieldWhereInput[]
    NOT?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
    channel?: XOR<ChannelDefinitionScalarRelationFilter, ChannelDefinitionWhereInput>
  }, "id" | "channelId_key">

  export type ChannelCredentialFieldOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChannelCredentialFieldCountOrderByAggregateInput
    _avg?: ChannelCredentialFieldAvgOrderByAggregateInput
    _max?: ChannelCredentialFieldMaxOrderByAggregateInput
    _min?: ChannelCredentialFieldMinOrderByAggregateInput
    _sum?: ChannelCredentialFieldSumOrderByAggregateInput
  }

  export type ChannelCredentialFieldScalarWhereWithAggregatesInput = {
    AND?: ChannelCredentialFieldScalarWhereWithAggregatesInput | ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    OR?: ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    NOT?: ChannelCredentialFieldScalarWhereWithAggregatesInput | ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChannelCredentialField"> | string
    channelId?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    key?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    label?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    placeholder?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    fieldType?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    required?: BoolWithAggregatesFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolWithAggregatesFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChannelCredentialField"> | Date | string | null
  }

  export type PluginWhereInput = {
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    id?: UuidFilter<"Plugin"> | string
    name?: StringFilter<"Plugin"> | string
    slug?: StringFilter<"Plugin"> | string
    description?: StringNullableFilter<"Plugin"> | string | null
    version?: StringFilter<"Plugin"> | string
    author?: StringNullableFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    region?: StringFilter<"Plugin"> | string
    configSchema?: JsonNullableFilter<"Plugin">
    defaultConfig?: JsonNullableFilter<"Plugin">
    mcpConfig?: JsonNullableFilter<"Plugin">
    isOfficial?: BoolFilter<"Plugin"> | boolean
    isEnabled?: BoolFilter<"Plugin"> | boolean
    downloadUrl?: StringNullableFilter<"Plugin"> | string | null
    iconEmoji?: StringNullableFilter<"Plugin"> | string | null
    iconUrl?: StringNullableFilter<"Plugin"> | string | null
    isDeleted?: BoolFilter<"Plugin"> | boolean
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Plugin"> | Date | string | null
    installations?: BotPluginListRelationFilter
  }

  export type PluginOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrder
    region?: SortOrder
    configSchema?: SortOrderInput | SortOrder
    defaultConfig?: SortOrderInput | SortOrder
    mcpConfig?: SortOrderInput | SortOrder
    isOfficial?: SortOrder
    isEnabled?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    iconEmoji?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    installations?: BotPluginOrderByRelationAggregateInput
  }

  export type PluginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: PluginWhereInput | PluginWhereInput[]
    OR?: PluginWhereInput[]
    NOT?: PluginWhereInput | PluginWhereInput[]
    name?: StringFilter<"Plugin"> | string
    description?: StringNullableFilter<"Plugin"> | string | null
    version?: StringFilter<"Plugin"> | string
    author?: StringNullableFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryFilter<"Plugin"> | $Enums.PluginCategory
    region?: StringFilter<"Plugin"> | string
    configSchema?: JsonNullableFilter<"Plugin">
    defaultConfig?: JsonNullableFilter<"Plugin">
    mcpConfig?: JsonNullableFilter<"Plugin">
    isOfficial?: BoolFilter<"Plugin"> | boolean
    isEnabled?: BoolFilter<"Plugin"> | boolean
    downloadUrl?: StringNullableFilter<"Plugin"> | string | null
    iconEmoji?: StringNullableFilter<"Plugin"> | string | null
    iconUrl?: StringNullableFilter<"Plugin"> | string | null
    isDeleted?: BoolFilter<"Plugin"> | boolean
    createdAt?: DateTimeFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeFilter<"Plugin"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Plugin"> | Date | string | null
    installations?: BotPluginListRelationFilter
  }, "id" | "slug">

  export type PluginOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    version?: SortOrder
    author?: SortOrderInput | SortOrder
    category?: SortOrder
    region?: SortOrder
    configSchema?: SortOrderInput | SortOrder
    defaultConfig?: SortOrderInput | SortOrder
    mcpConfig?: SortOrderInput | SortOrder
    isOfficial?: SortOrder
    isEnabled?: SortOrder
    downloadUrl?: SortOrderInput | SortOrder
    iconEmoji?: SortOrderInput | SortOrder
    iconUrl?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PluginCountOrderByAggregateInput
    _max?: PluginMaxOrderByAggregateInput
    _min?: PluginMinOrderByAggregateInput
  }

  export type PluginScalarWhereWithAggregatesInput = {
    AND?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    OR?: PluginScalarWhereWithAggregatesInput[]
    NOT?: PluginScalarWhereWithAggregatesInput | PluginScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Plugin"> | string
    name?: StringWithAggregatesFilter<"Plugin"> | string
    slug?: StringWithAggregatesFilter<"Plugin"> | string
    description?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    version?: StringWithAggregatesFilter<"Plugin"> | string
    author?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    category?: EnumPluginCategoryWithAggregatesFilter<"Plugin"> | $Enums.PluginCategory
    region?: StringWithAggregatesFilter<"Plugin"> | string
    configSchema?: JsonNullableWithAggregatesFilter<"Plugin">
    defaultConfig?: JsonNullableWithAggregatesFilter<"Plugin">
    mcpConfig?: JsonNullableWithAggregatesFilter<"Plugin">
    isOfficial?: BoolWithAggregatesFilter<"Plugin"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"Plugin"> | boolean
    downloadUrl?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    iconEmoji?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    iconUrl?: StringNullableWithAggregatesFilter<"Plugin"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Plugin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Plugin"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Plugin"> | Date | string | null
  }

  export type BotPluginWhereInput = {
    AND?: BotPluginWhereInput | BotPluginWhereInput[]
    OR?: BotPluginWhereInput[]
    NOT?: BotPluginWhereInput | BotPluginWhereInput[]
    id?: UuidFilter<"BotPlugin"> | string
    botId?: UuidFilter<"BotPlugin"> | string
    pluginId?: UuidFilter<"BotPlugin"> | string
    config?: JsonNullableFilter<"BotPlugin">
    isEnabled?: BoolFilter<"BotPlugin"> | boolean
    createdAt?: DateTimeFilter<"BotPlugin"> | Date | string
    updatedAt?: DateTimeFilter<"BotPlugin"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
  }

  export type BotPluginOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    pluginId?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    plugin?: PluginOrderByWithRelationInput
  }

  export type BotPluginWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_pluginId?: BotPluginBotIdPluginIdCompoundUniqueInput
    AND?: BotPluginWhereInput | BotPluginWhereInput[]
    OR?: BotPluginWhereInput[]
    NOT?: BotPluginWhereInput | BotPluginWhereInput[]
    botId?: UuidFilter<"BotPlugin"> | string
    pluginId?: UuidFilter<"BotPlugin"> | string
    config?: JsonNullableFilter<"BotPlugin">
    isEnabled?: BoolFilter<"BotPlugin"> | boolean
    createdAt?: DateTimeFilter<"BotPlugin"> | Date | string
    updatedAt?: DateTimeFilter<"BotPlugin"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    plugin?: XOR<PluginScalarRelationFilter, PluginWhereInput>
  }, "id" | "botId_pluginId">

  export type BotPluginOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    pluginId?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotPluginCountOrderByAggregateInput
    _max?: BotPluginMaxOrderByAggregateInput
    _min?: BotPluginMinOrderByAggregateInput
  }

  export type BotPluginScalarWhereWithAggregatesInput = {
    AND?: BotPluginScalarWhereWithAggregatesInput | BotPluginScalarWhereWithAggregatesInput[]
    OR?: BotPluginScalarWhereWithAggregatesInput[]
    NOT?: BotPluginScalarWhereWithAggregatesInput | BotPluginScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotPlugin"> | string
    botId?: UuidWithAggregatesFilter<"BotPlugin"> | string
    pluginId?: UuidWithAggregatesFilter<"BotPlugin"> | string
    config?: JsonNullableWithAggregatesFilter<"BotPlugin">
    isEnabled?: BoolWithAggregatesFilter<"BotPlugin"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotPlugin"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotPlugin"> | Date | string
  }

  export type SkillTypeWhereInput = {
    AND?: SkillTypeWhereInput | SkillTypeWhereInput[]
    OR?: SkillTypeWhereInput[]
    NOT?: SkillTypeWhereInput | SkillTypeWhereInput[]
    id?: UuidFilter<"SkillType"> | string
    slug?: StringFilter<"SkillType"> | string
    name?: StringFilter<"SkillType"> | string
    nameZh?: StringNullableFilter<"SkillType"> | string | null
    description?: StringNullableFilter<"SkillType"> | string | null
    descriptionZh?: StringNullableFilter<"SkillType"> | string | null
    icon?: StringNullableFilter<"SkillType"> | string | null
    sortOrder?: IntFilter<"SkillType"> | number
    isDeleted?: BoolFilter<"SkillType"> | boolean
    createdAt?: DateTimeFilter<"SkillType"> | Date | string
    updatedAt?: DateTimeFilter<"SkillType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SkillType"> | Date | string | null
    skills?: SkillListRelationFilter
  }

  export type SkillTypeOrderByWithRelationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionZh?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    skills?: SkillOrderByRelationAggregateInput
  }

  export type SkillTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: SkillTypeWhereInput | SkillTypeWhereInput[]
    OR?: SkillTypeWhereInput[]
    NOT?: SkillTypeWhereInput | SkillTypeWhereInput[]
    name?: StringFilter<"SkillType"> | string
    nameZh?: StringNullableFilter<"SkillType"> | string | null
    description?: StringNullableFilter<"SkillType"> | string | null
    descriptionZh?: StringNullableFilter<"SkillType"> | string | null
    icon?: StringNullableFilter<"SkillType"> | string | null
    sortOrder?: IntFilter<"SkillType"> | number
    isDeleted?: BoolFilter<"SkillType"> | boolean
    createdAt?: DateTimeFilter<"SkillType"> | Date | string
    updatedAt?: DateTimeFilter<"SkillType"> | Date | string
    deletedAt?: DateTimeNullableFilter<"SkillType"> | Date | string | null
    skills?: SkillListRelationFilter
  }, "id" | "slug">

  export type SkillTypeOrderByWithAggregationInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameZh?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    descriptionZh?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SkillTypeCountOrderByAggregateInput
    _avg?: SkillTypeAvgOrderByAggregateInput
    _max?: SkillTypeMaxOrderByAggregateInput
    _min?: SkillTypeMinOrderByAggregateInput
    _sum?: SkillTypeSumOrderByAggregateInput
  }

  export type SkillTypeScalarWhereWithAggregatesInput = {
    AND?: SkillTypeScalarWhereWithAggregatesInput | SkillTypeScalarWhereWithAggregatesInput[]
    OR?: SkillTypeScalarWhereWithAggregatesInput[]
    NOT?: SkillTypeScalarWhereWithAggregatesInput | SkillTypeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SkillType"> | string
    slug?: StringWithAggregatesFilter<"SkillType"> | string
    name?: StringWithAggregatesFilter<"SkillType"> | string
    nameZh?: StringNullableWithAggregatesFilter<"SkillType"> | string | null
    description?: StringNullableWithAggregatesFilter<"SkillType"> | string | null
    descriptionZh?: StringNullableWithAggregatesFilter<"SkillType"> | string | null
    icon?: StringNullableWithAggregatesFilter<"SkillType"> | string | null
    sortOrder?: IntWithAggregatesFilter<"SkillType"> | number
    isDeleted?: BoolWithAggregatesFilter<"SkillType"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"SkillType"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SkillType"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"SkillType"> | Date | string | null
  }

  export type SkillWhereInput = {
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    id?: UuidFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    nameZh?: StringNullableFilter<"Skill"> | string | null
    slug?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    descriptionZh?: StringNullableFilter<"Skill"> | string | null
    version?: StringFilter<"Skill"> | string
    skillTypeId?: UuidNullableFilter<"Skill"> | string | null
    definition?: JsonFilter<"Skill">
    examples?: JsonNullableFilter<"Skill">
    isSystem?: BoolFilter<"Skill"> | boolean
    isEnabled?: BoolFilter<"Skill"> | boolean
    createdById?: UuidNullableFilter<"Skill"> | string | null
    source?: StringNullableFilter<"Skill"> | string | null
    sourceUrl?: StringNullableFilter<"Skill"> | string | null
    author?: StringNullableFilter<"Skill"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
    isDeleted?: BoolFilter<"Skill"> | boolean
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
    skillType?: XOR<SkillTypeNullableScalarRelationFilter, SkillTypeWhereInput> | null
    installations?: BotSkillListRelationFilter
  }

  export type SkillOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    nameZh?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionZh?: SortOrderInput | SortOrder
    version?: SortOrder
    skillTypeId?: SortOrderInput | SortOrder
    definition?: SortOrder
    examples?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isEnabled?: SortOrder
    createdById?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    skillType?: SkillTypeOrderByWithRelationInput
    installations?: BotSkillOrderByRelationAggregateInput
  }

  export type SkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug_createdById?: SkillSlugCreatedByIdCompoundUniqueInput
    b_skill_source_slug_key?: SkillB_skill_source_slug_keyCompoundUniqueInput
    AND?: SkillWhereInput | SkillWhereInput[]
    OR?: SkillWhereInput[]
    NOT?: SkillWhereInput | SkillWhereInput[]
    name?: StringFilter<"Skill"> | string
    nameZh?: StringNullableFilter<"Skill"> | string | null
    slug?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    descriptionZh?: StringNullableFilter<"Skill"> | string | null
    version?: StringFilter<"Skill"> | string
    skillTypeId?: UuidNullableFilter<"Skill"> | string | null
    definition?: JsonFilter<"Skill">
    examples?: JsonNullableFilter<"Skill">
    isSystem?: BoolFilter<"Skill"> | boolean
    isEnabled?: BoolFilter<"Skill"> | boolean
    createdById?: UuidNullableFilter<"Skill"> | string | null
    source?: StringNullableFilter<"Skill"> | string | null
    sourceUrl?: StringNullableFilter<"Skill"> | string | null
    author?: StringNullableFilter<"Skill"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
    isDeleted?: BoolFilter<"Skill"> | boolean
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
    skillType?: XOR<SkillTypeNullableScalarRelationFilter, SkillTypeWhereInput> | null
    installations?: BotSkillListRelationFilter
  }, "id" | "slug_createdById" | "b_skill_source_slug_key">

  export type SkillOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    nameZh?: SortOrderInput | SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    descriptionZh?: SortOrderInput | SortOrder
    version?: SortOrder
    skillTypeId?: SortOrderInput | SortOrder
    definition?: SortOrder
    examples?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    isEnabled?: SortOrder
    createdById?: SortOrderInput | SortOrder
    source?: SortOrderInput | SortOrder
    sourceUrl?: SortOrderInput | SortOrder
    author?: SortOrderInput | SortOrder
    lastSyncedAt?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: SkillCountOrderByAggregateInput
    _max?: SkillMaxOrderByAggregateInput
    _min?: SkillMinOrderByAggregateInput
  }

  export type SkillScalarWhereWithAggregatesInput = {
    AND?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    OR?: SkillScalarWhereWithAggregatesInput[]
    NOT?: SkillScalarWhereWithAggregatesInput | SkillScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Skill"> | string
    name?: StringWithAggregatesFilter<"Skill"> | string
    nameZh?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    slug?: StringWithAggregatesFilter<"Skill"> | string
    description?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    descriptionZh?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    version?: StringWithAggregatesFilter<"Skill"> | string
    skillTypeId?: UuidNullableWithAggregatesFilter<"Skill"> | string | null
    definition?: JsonWithAggregatesFilter<"Skill">
    examples?: JsonNullableWithAggregatesFilter<"Skill">
    isSystem?: BoolWithAggregatesFilter<"Skill"> | boolean
    isEnabled?: BoolWithAggregatesFilter<"Skill"> | boolean
    createdById?: UuidNullableWithAggregatesFilter<"Skill"> | string | null
    source?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    sourceUrl?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    author?: StringNullableWithAggregatesFilter<"Skill"> | string | null
    lastSyncedAt?: DateTimeNullableWithAggregatesFilter<"Skill"> | Date | string | null
    isDeleted?: BoolWithAggregatesFilter<"Skill"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Skill"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Skill"> | Date | string | null
  }

  export type BotSkillWhereInput = {
    AND?: BotSkillWhereInput | BotSkillWhereInput[]
    OR?: BotSkillWhereInput[]
    NOT?: BotSkillWhereInput | BotSkillWhereInput[]
    id?: UuidFilter<"BotSkill"> | string
    botId?: UuidFilter<"BotSkill"> | string
    skillId?: UuidFilter<"BotSkill"> | string
    config?: JsonNullableFilter<"BotSkill">
    isEnabled?: BoolFilter<"BotSkill"> | boolean
    createdAt?: DateTimeFilter<"BotSkill"> | Date | string
    updatedAt?: DateTimeFilter<"BotSkill"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }

  export type BotSkillOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    skillId?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    skill?: SkillOrderByWithRelationInput
  }

  export type BotSkillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_skillId?: BotSkillBotIdSkillIdCompoundUniqueInput
    AND?: BotSkillWhereInput | BotSkillWhereInput[]
    OR?: BotSkillWhereInput[]
    NOT?: BotSkillWhereInput | BotSkillWhereInput[]
    botId?: UuidFilter<"BotSkill"> | string
    skillId?: UuidFilter<"BotSkill"> | string
    config?: JsonNullableFilter<"BotSkill">
    isEnabled?: BoolFilter<"BotSkill"> | boolean
    createdAt?: DateTimeFilter<"BotSkill"> | Date | string
    updatedAt?: DateTimeFilter<"BotSkill"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    skill?: XOR<SkillScalarRelationFilter, SkillWhereInput>
  }, "id" | "botId_skillId">

  export type BotSkillOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    skillId?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotSkillCountOrderByAggregateInput
    _max?: BotSkillMaxOrderByAggregateInput
    _min?: BotSkillMinOrderByAggregateInput
  }

  export type BotSkillScalarWhereWithAggregatesInput = {
    AND?: BotSkillScalarWhereWithAggregatesInput | BotSkillScalarWhereWithAggregatesInput[]
    OR?: BotSkillScalarWhereWithAggregatesInput[]
    NOT?: BotSkillScalarWhereWithAggregatesInput | BotSkillScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotSkill"> | string
    botId?: UuidWithAggregatesFilter<"BotSkill"> | string
    skillId?: UuidWithAggregatesFilter<"BotSkill"> | string
    config?: JsonNullableWithAggregatesFilter<"BotSkill">
    isEnabled?: BoolWithAggregatesFilter<"BotSkill"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotSkill"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotSkill"> | Date | string
  }

  export type ModelPricingWhereInput = {
    AND?: ModelPricingWhereInput | ModelPricingWhereInput[]
    OR?: ModelPricingWhereInput[]
    NOT?: ModelPricingWhereInput | ModelPricingWhereInput[]
    id?: UuidFilter<"ModelPricing"> | string
    model?: StringFilter<"ModelPricing"> | string
    vendor?: StringFilter<"ModelPricing"> | string
    displayName?: StringNullableFilter<"ModelPricing"> | string | null
    description?: StringNullableFilter<"ModelPricing"> | string | null
    inputPrice?: DecimalFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFilter<"ModelPricing"> | number
    codingScore?: IntFilter<"ModelPricing"> | number
    creativityScore?: IntFilter<"ModelPricing"> | number
    speedScore?: IntFilter<"ModelPricing"> | number
    contextLength?: IntFilter<"ModelPricing"> | number
    supportsExtendedThinking?: BoolFilter<"ModelPricing"> | boolean
    supportsCacheControl?: BoolFilter<"ModelPricing"> | boolean
    supportsVision?: BoolFilter<"ModelPricing"> | boolean
    supportsFunctionCalling?: BoolFilter<"ModelPricing"> | boolean
    supportsStreaming?: BoolFilter<"ModelPricing"> | boolean
    recommendedScenarios?: JsonNullableFilter<"ModelPricing">
    isEnabled?: BoolFilter<"ModelPricing"> | boolean
    isDeprecated?: BoolFilter<"ModelPricing"> | boolean
    deprecationDate?: DateTimeNullableFilter<"ModelPricing"> | Date | string | null
    priceUpdatedAt?: DateTimeFilter<"ModelPricing"> | Date | string
    notes?: StringNullableFilter<"ModelPricing"> | string | null
    metadata?: JsonNullableFilter<"ModelPricing">
    isDeleted?: BoolFilter<"ModelPricing"> | boolean
    createdAt?: DateTimeFilter<"ModelPricing"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricing"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ModelPricing"> | Date | string | null
  }

  export type ModelPricingOrderByWithRelationInput = {
    id?: SortOrder
    model?: SortOrder
    vendor?: SortOrder
    displayName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrderInput | SortOrder
    cacheWritePrice?: SortOrderInput | SortOrder
    thinkingPrice?: SortOrderInput | SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
    supportsExtendedThinking?: SortOrder
    supportsCacheControl?: SortOrder
    supportsVision?: SortOrder
    supportsFunctionCalling?: SortOrder
    supportsStreaming?: SortOrder
    recommendedScenarios?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    isDeprecated?: SortOrder
    deprecationDate?: SortOrderInput | SortOrder
    priceUpdatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type ModelPricingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    model?: string
    AND?: ModelPricingWhereInput | ModelPricingWhereInput[]
    OR?: ModelPricingWhereInput[]
    NOT?: ModelPricingWhereInput | ModelPricingWhereInput[]
    vendor?: StringFilter<"ModelPricing"> | string
    displayName?: StringNullableFilter<"ModelPricing"> | string | null
    description?: StringNullableFilter<"ModelPricing"> | string | null
    inputPrice?: DecimalFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: DecimalNullableFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFilter<"ModelPricing"> | number
    codingScore?: IntFilter<"ModelPricing"> | number
    creativityScore?: IntFilter<"ModelPricing"> | number
    speedScore?: IntFilter<"ModelPricing"> | number
    contextLength?: IntFilter<"ModelPricing"> | number
    supportsExtendedThinking?: BoolFilter<"ModelPricing"> | boolean
    supportsCacheControl?: BoolFilter<"ModelPricing"> | boolean
    supportsVision?: BoolFilter<"ModelPricing"> | boolean
    supportsFunctionCalling?: BoolFilter<"ModelPricing"> | boolean
    supportsStreaming?: BoolFilter<"ModelPricing"> | boolean
    recommendedScenarios?: JsonNullableFilter<"ModelPricing">
    isEnabled?: BoolFilter<"ModelPricing"> | boolean
    isDeprecated?: BoolFilter<"ModelPricing"> | boolean
    deprecationDate?: DateTimeNullableFilter<"ModelPricing"> | Date | string | null
    priceUpdatedAt?: DateTimeFilter<"ModelPricing"> | Date | string
    notes?: StringNullableFilter<"ModelPricing"> | string | null
    metadata?: JsonNullableFilter<"ModelPricing">
    isDeleted?: BoolFilter<"ModelPricing"> | boolean
    createdAt?: DateTimeFilter<"ModelPricing"> | Date | string
    updatedAt?: DateTimeFilter<"ModelPricing"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ModelPricing"> | Date | string | null
  }, "id" | "model">

  export type ModelPricingOrderByWithAggregationInput = {
    id?: SortOrder
    model?: SortOrder
    vendor?: SortOrder
    displayName?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrderInput | SortOrder
    cacheWritePrice?: SortOrderInput | SortOrder
    thinkingPrice?: SortOrderInput | SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
    supportsExtendedThinking?: SortOrder
    supportsCacheControl?: SortOrder
    supportsVision?: SortOrder
    supportsFunctionCalling?: SortOrder
    supportsStreaming?: SortOrder
    recommendedScenarios?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    isDeprecated?: SortOrder
    deprecationDate?: SortOrderInput | SortOrder
    priceUpdatedAt?: SortOrder
    notes?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ModelPricingCountOrderByAggregateInput
    _avg?: ModelPricingAvgOrderByAggregateInput
    _max?: ModelPricingMaxOrderByAggregateInput
    _min?: ModelPricingMinOrderByAggregateInput
    _sum?: ModelPricingSumOrderByAggregateInput
  }

  export type ModelPricingScalarWhereWithAggregatesInput = {
    AND?: ModelPricingScalarWhereWithAggregatesInput | ModelPricingScalarWhereWithAggregatesInput[]
    OR?: ModelPricingScalarWhereWithAggregatesInput[]
    NOT?: ModelPricingScalarWhereWithAggregatesInput | ModelPricingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ModelPricing"> | string
    model?: StringWithAggregatesFilter<"ModelPricing"> | string
    vendor?: StringWithAggregatesFilter<"ModelPricing"> | string
    displayName?: StringNullableWithAggregatesFilter<"ModelPricing"> | string | null
    description?: StringNullableWithAggregatesFilter<"ModelPricing"> | string | null
    inputPrice?: DecimalWithAggregatesFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalWithAggregatesFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: DecimalNullableWithAggregatesFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: DecimalNullableWithAggregatesFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: DecimalNullableWithAggregatesFilter<"ModelPricing"> | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntWithAggregatesFilter<"ModelPricing"> | number
    codingScore?: IntWithAggregatesFilter<"ModelPricing"> | number
    creativityScore?: IntWithAggregatesFilter<"ModelPricing"> | number
    speedScore?: IntWithAggregatesFilter<"ModelPricing"> | number
    contextLength?: IntWithAggregatesFilter<"ModelPricing"> | number
    supportsExtendedThinking?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    supportsCacheControl?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    supportsVision?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    supportsFunctionCalling?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    supportsStreaming?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    recommendedScenarios?: JsonNullableWithAggregatesFilter<"ModelPricing">
    isEnabled?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    isDeprecated?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    deprecationDate?: DateTimeNullableWithAggregatesFilter<"ModelPricing"> | Date | string | null
    priceUpdatedAt?: DateTimeWithAggregatesFilter<"ModelPricing"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"ModelPricing"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"ModelPricing">
    isDeleted?: BoolWithAggregatesFilter<"ModelPricing"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ModelPricing"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ModelPricing"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ModelPricing"> | Date | string | null
  }

  export type BotModelRoutingWhereInput = {
    AND?: BotModelRoutingWhereInput | BotModelRoutingWhereInput[]
    OR?: BotModelRoutingWhereInput[]
    NOT?: BotModelRoutingWhereInput | BotModelRoutingWhereInput[]
    id?: UuidFilter<"BotModelRouting"> | string
    botId?: UuidFilter<"BotModelRouting"> | string
    routingType?: EnumModelRoutingTypeFilter<"BotModelRouting"> | $Enums.ModelRoutingType
    name?: StringFilter<"BotModelRouting"> | string
    config?: JsonFilter<"BotModelRouting">
    priority?: IntFilter<"BotModelRouting"> | number
    isEnabled?: BoolFilter<"BotModelRouting"> | boolean
    isDeleted?: BoolFilter<"BotModelRouting"> | boolean
    createdAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    updatedAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotModelRouting"> | Date | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }

  export type BotModelRoutingOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    routingType?: SortOrder
    name?: SortOrder
    config?: SortOrder
    priority?: SortOrder
    isEnabled?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    bot?: BotOrderByWithRelationInput
  }

  export type BotModelRoutingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotModelRoutingWhereInput | BotModelRoutingWhereInput[]
    OR?: BotModelRoutingWhereInput[]
    NOT?: BotModelRoutingWhereInput | BotModelRoutingWhereInput[]
    botId?: UuidFilter<"BotModelRouting"> | string
    routingType?: EnumModelRoutingTypeFilter<"BotModelRouting"> | $Enums.ModelRoutingType
    name?: StringFilter<"BotModelRouting"> | string
    config?: JsonFilter<"BotModelRouting">
    priority?: IntFilter<"BotModelRouting"> | number
    isEnabled?: BoolFilter<"BotModelRouting"> | boolean
    isDeleted?: BoolFilter<"BotModelRouting"> | boolean
    createdAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    updatedAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotModelRouting"> | Date | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }, "id">

  export type BotModelRoutingOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    routingType?: SortOrder
    name?: SortOrder
    config?: SortOrder
    priority?: SortOrder
    isEnabled?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BotModelRoutingCountOrderByAggregateInput
    _avg?: BotModelRoutingAvgOrderByAggregateInput
    _max?: BotModelRoutingMaxOrderByAggregateInput
    _min?: BotModelRoutingMinOrderByAggregateInput
    _sum?: BotModelRoutingSumOrderByAggregateInput
  }

  export type BotModelRoutingScalarWhereWithAggregatesInput = {
    AND?: BotModelRoutingScalarWhereWithAggregatesInput | BotModelRoutingScalarWhereWithAggregatesInput[]
    OR?: BotModelRoutingScalarWhereWithAggregatesInput[]
    NOT?: BotModelRoutingScalarWhereWithAggregatesInput | BotModelRoutingScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotModelRouting"> | string
    botId?: UuidWithAggregatesFilter<"BotModelRouting"> | string
    routingType?: EnumModelRoutingTypeWithAggregatesFilter<"BotModelRouting"> | $Enums.ModelRoutingType
    name?: StringWithAggregatesFilter<"BotModelRouting"> | string
    config?: JsonWithAggregatesFilter<"BotModelRouting">
    priority?: IntWithAggregatesFilter<"BotModelRouting"> | number
    isEnabled?: BoolWithAggregatesFilter<"BotModelRouting"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"BotModelRouting"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotModelRouting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotModelRouting"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BotModelRouting"> | Date | string | null
  }

  export type BotChannelWhereInput = {
    AND?: BotChannelWhereInput | BotChannelWhereInput[]
    OR?: BotChannelWhereInput[]
    NOT?: BotChannelWhereInput | BotChannelWhereInput[]
    id?: UuidFilter<"BotChannel"> | string
    botId?: UuidFilter<"BotChannel"> | string
    channelType?: StringFilter<"BotChannel"> | string
    name?: StringFilter<"BotChannel"> | string
    credentialsEncrypted?: BytesFilter<"BotChannel"> | Bytes
    config?: JsonNullableFilter<"BotChannel">
    isEnabled?: BoolFilter<"BotChannel"> | boolean
    connectionStatus?: EnumChannelConnectionStatusFilter<"BotChannel"> | $Enums.ChannelConnectionStatus
    lastConnectedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
    lastError?: StringNullableFilter<"BotChannel"> | string | null
    isDeleted?: BoolFilter<"BotChannel"> | boolean
    createdAt?: DateTimeFilter<"BotChannel"> | Date | string
    updatedAt?: DateTimeFilter<"BotChannel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }

  export type BotChannelOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    channelType?: SortOrder
    name?: SortOrder
    credentialsEncrypted?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    connectionStatus?: SortOrder
    lastConnectedAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    bot?: BotOrderByWithRelationInput
  }

  export type BotChannelWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_channelType_name?: BotChannelBotIdChannelTypeNameCompoundUniqueInput
    AND?: BotChannelWhereInput | BotChannelWhereInput[]
    OR?: BotChannelWhereInput[]
    NOT?: BotChannelWhereInput | BotChannelWhereInput[]
    botId?: UuidFilter<"BotChannel"> | string
    channelType?: StringFilter<"BotChannel"> | string
    name?: StringFilter<"BotChannel"> | string
    credentialsEncrypted?: BytesFilter<"BotChannel"> | Bytes
    config?: JsonNullableFilter<"BotChannel">
    isEnabled?: BoolFilter<"BotChannel"> | boolean
    connectionStatus?: EnumChannelConnectionStatusFilter<"BotChannel"> | $Enums.ChannelConnectionStatus
    lastConnectedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
    lastError?: StringNullableFilter<"BotChannel"> | string | null
    isDeleted?: BoolFilter<"BotChannel"> | boolean
    createdAt?: DateTimeFilter<"BotChannel"> | Date | string
    updatedAt?: DateTimeFilter<"BotChannel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }, "id" | "botId_channelType_name">

  export type BotChannelOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    channelType?: SortOrder
    name?: SortOrder
    credentialsEncrypted?: SortOrder
    config?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    connectionStatus?: SortOrder
    lastConnectedAt?: SortOrderInput | SortOrder
    lastError?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BotChannelCountOrderByAggregateInput
    _max?: BotChannelMaxOrderByAggregateInput
    _min?: BotChannelMinOrderByAggregateInput
  }

  export type BotChannelScalarWhereWithAggregatesInput = {
    AND?: BotChannelScalarWhereWithAggregatesInput | BotChannelScalarWhereWithAggregatesInput[]
    OR?: BotChannelScalarWhereWithAggregatesInput[]
    NOT?: BotChannelScalarWhereWithAggregatesInput | BotChannelScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotChannel"> | string
    botId?: UuidWithAggregatesFilter<"BotChannel"> | string
    channelType?: StringWithAggregatesFilter<"BotChannel"> | string
    name?: StringWithAggregatesFilter<"BotChannel"> | string
    credentialsEncrypted?: BytesWithAggregatesFilter<"BotChannel"> | Bytes
    config?: JsonNullableWithAggregatesFilter<"BotChannel">
    isEnabled?: BoolWithAggregatesFilter<"BotChannel"> | boolean
    connectionStatus?: EnumChannelConnectionStatusWithAggregatesFilter<"BotChannel"> | $Enums.ChannelConnectionStatus
    lastConnectedAt?: DateTimeNullableWithAggregatesFilter<"BotChannel"> | Date | string | null
    lastError?: StringNullableWithAggregatesFilter<"BotChannel"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"BotChannel"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotChannel"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotChannel"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"BotChannel"> | Date | string | null
  }

  export type CapabilityTagWhereInput = {
    AND?: CapabilityTagWhereInput | CapabilityTagWhereInput[]
    OR?: CapabilityTagWhereInput[]
    NOT?: CapabilityTagWhereInput | CapabilityTagWhereInput[]
    id?: UuidFilter<"CapabilityTag"> | string
    tagId?: StringFilter<"CapabilityTag"> | string
    name?: StringFilter<"CapabilityTag"> | string
    description?: StringNullableFilter<"CapabilityTag"> | string | null
    category?: StringFilter<"CapabilityTag"> | string
    priority?: IntFilter<"CapabilityTag"> | number
    requiredProtocol?: StringNullableFilter<"CapabilityTag"> | string | null
    requiredSkills?: JsonNullableFilter<"CapabilityTag">
    requiredModels?: JsonNullableFilter<"CapabilityTag">
    requiresExtendedThinking?: BoolFilter<"CapabilityTag"> | boolean
    requiresCacheControl?: BoolFilter<"CapabilityTag"> | boolean
    requiresVision?: BoolFilter<"CapabilityTag"> | boolean
    maxCostPerMToken?: DecimalNullableFilter<"CapabilityTag"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"CapabilityTag"> | boolean
    isBuiltin?: BoolFilter<"CapabilityTag"> | boolean
    isDeleted?: BoolFilter<"CapabilityTag"> | boolean
    createdAt?: DateTimeFilter<"CapabilityTag"> | Date | string
    updatedAt?: DateTimeFilter<"CapabilityTag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CapabilityTag"> | Date | string | null
  }

  export type CapabilityTagOrderByWithRelationInput = {
    id?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    requiredProtocol?: SortOrderInput | SortOrder
    requiredSkills?: SortOrderInput | SortOrder
    requiredModels?: SortOrderInput | SortOrder
    requiresExtendedThinking?: SortOrder
    requiresCacheControl?: SortOrder
    requiresVision?: SortOrder
    maxCostPerMToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type CapabilityTagWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tagId?: string
    AND?: CapabilityTagWhereInput | CapabilityTagWhereInput[]
    OR?: CapabilityTagWhereInput[]
    NOT?: CapabilityTagWhereInput | CapabilityTagWhereInput[]
    name?: StringFilter<"CapabilityTag"> | string
    description?: StringNullableFilter<"CapabilityTag"> | string | null
    category?: StringFilter<"CapabilityTag"> | string
    priority?: IntFilter<"CapabilityTag"> | number
    requiredProtocol?: StringNullableFilter<"CapabilityTag"> | string | null
    requiredSkills?: JsonNullableFilter<"CapabilityTag">
    requiredModels?: JsonNullableFilter<"CapabilityTag">
    requiresExtendedThinking?: BoolFilter<"CapabilityTag"> | boolean
    requiresCacheControl?: BoolFilter<"CapabilityTag"> | boolean
    requiresVision?: BoolFilter<"CapabilityTag"> | boolean
    maxCostPerMToken?: DecimalNullableFilter<"CapabilityTag"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFilter<"CapabilityTag"> | boolean
    isBuiltin?: BoolFilter<"CapabilityTag"> | boolean
    isDeleted?: BoolFilter<"CapabilityTag"> | boolean
    createdAt?: DateTimeFilter<"CapabilityTag"> | Date | string
    updatedAt?: DateTimeFilter<"CapabilityTag"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CapabilityTag"> | Date | string | null
  }, "id" | "tagId">

  export type CapabilityTagOrderByWithAggregationInput = {
    id?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    priority?: SortOrder
    requiredProtocol?: SortOrderInput | SortOrder
    requiredSkills?: SortOrderInput | SortOrder
    requiredModels?: SortOrderInput | SortOrder
    requiresExtendedThinking?: SortOrder
    requiresCacheControl?: SortOrder
    requiresVision?: SortOrder
    maxCostPerMToken?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CapabilityTagCountOrderByAggregateInput
    _avg?: CapabilityTagAvgOrderByAggregateInput
    _max?: CapabilityTagMaxOrderByAggregateInput
    _min?: CapabilityTagMinOrderByAggregateInput
    _sum?: CapabilityTagSumOrderByAggregateInput
  }

  export type CapabilityTagScalarWhereWithAggregatesInput = {
    AND?: CapabilityTagScalarWhereWithAggregatesInput | CapabilityTagScalarWhereWithAggregatesInput[]
    OR?: CapabilityTagScalarWhereWithAggregatesInput[]
    NOT?: CapabilityTagScalarWhereWithAggregatesInput | CapabilityTagScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CapabilityTag"> | string
    tagId?: StringWithAggregatesFilter<"CapabilityTag"> | string
    name?: StringWithAggregatesFilter<"CapabilityTag"> | string
    description?: StringNullableWithAggregatesFilter<"CapabilityTag"> | string | null
    category?: StringWithAggregatesFilter<"CapabilityTag"> | string
    priority?: IntWithAggregatesFilter<"CapabilityTag"> | number
    requiredProtocol?: StringNullableWithAggregatesFilter<"CapabilityTag"> | string | null
    requiredSkills?: JsonNullableWithAggregatesFilter<"CapabilityTag">
    requiredModels?: JsonNullableWithAggregatesFilter<"CapabilityTag">
    requiresExtendedThinking?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    requiresCacheControl?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    requiresVision?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    maxCostPerMToken?: DecimalNullableWithAggregatesFilter<"CapabilityTag"> | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    isBuiltin?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"CapabilityTag"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CapabilityTag"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CapabilityTag"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CapabilityTag"> | Date | string | null
  }

  export type FallbackChainWhereInput = {
    AND?: FallbackChainWhereInput | FallbackChainWhereInput[]
    OR?: FallbackChainWhereInput[]
    NOT?: FallbackChainWhereInput | FallbackChainWhereInput[]
    id?: UuidFilter<"FallbackChain"> | string
    chainId?: StringFilter<"FallbackChain"> | string
    name?: StringFilter<"FallbackChain"> | string
    description?: StringNullableFilter<"FallbackChain"> | string | null
    models?: JsonFilter<"FallbackChain">
    triggerStatusCodes?: JsonFilter<"FallbackChain">
    triggerErrorTypes?: JsonFilter<"FallbackChain">
    triggerTimeoutMs?: IntFilter<"FallbackChain"> | number
    maxRetries?: IntFilter<"FallbackChain"> | number
    retryDelayMs?: IntFilter<"FallbackChain"> | number
    preserveProtocol?: BoolFilter<"FallbackChain"> | boolean
    isActive?: BoolFilter<"FallbackChain"> | boolean
    isBuiltin?: BoolFilter<"FallbackChain"> | boolean
    isDeleted?: BoolFilter<"FallbackChain"> | boolean
    createdAt?: DateTimeFilter<"FallbackChain"> | Date | string
    updatedAt?: DateTimeFilter<"FallbackChain"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FallbackChain"> | Date | string | null
  }

  export type FallbackChainOrderByWithRelationInput = {
    id?: SortOrder
    chainId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    models?: SortOrder
    triggerStatusCodes?: SortOrder
    triggerErrorTypes?: SortOrder
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
    preserveProtocol?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type FallbackChainWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    chainId?: string
    AND?: FallbackChainWhereInput | FallbackChainWhereInput[]
    OR?: FallbackChainWhereInput[]
    NOT?: FallbackChainWhereInput | FallbackChainWhereInput[]
    name?: StringFilter<"FallbackChain"> | string
    description?: StringNullableFilter<"FallbackChain"> | string | null
    models?: JsonFilter<"FallbackChain">
    triggerStatusCodes?: JsonFilter<"FallbackChain">
    triggerErrorTypes?: JsonFilter<"FallbackChain">
    triggerTimeoutMs?: IntFilter<"FallbackChain"> | number
    maxRetries?: IntFilter<"FallbackChain"> | number
    retryDelayMs?: IntFilter<"FallbackChain"> | number
    preserveProtocol?: BoolFilter<"FallbackChain"> | boolean
    isActive?: BoolFilter<"FallbackChain"> | boolean
    isBuiltin?: BoolFilter<"FallbackChain"> | boolean
    isDeleted?: BoolFilter<"FallbackChain"> | boolean
    createdAt?: DateTimeFilter<"FallbackChain"> | Date | string
    updatedAt?: DateTimeFilter<"FallbackChain"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FallbackChain"> | Date | string | null
  }, "id" | "chainId">

  export type FallbackChainOrderByWithAggregationInput = {
    id?: SortOrder
    chainId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    models?: SortOrder
    triggerStatusCodes?: SortOrder
    triggerErrorTypes?: SortOrder
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
    preserveProtocol?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FallbackChainCountOrderByAggregateInput
    _avg?: FallbackChainAvgOrderByAggregateInput
    _max?: FallbackChainMaxOrderByAggregateInput
    _min?: FallbackChainMinOrderByAggregateInput
    _sum?: FallbackChainSumOrderByAggregateInput
  }

  export type FallbackChainScalarWhereWithAggregatesInput = {
    AND?: FallbackChainScalarWhereWithAggregatesInput | FallbackChainScalarWhereWithAggregatesInput[]
    OR?: FallbackChainScalarWhereWithAggregatesInput[]
    NOT?: FallbackChainScalarWhereWithAggregatesInput | FallbackChainScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FallbackChain"> | string
    chainId?: StringWithAggregatesFilter<"FallbackChain"> | string
    name?: StringWithAggregatesFilter<"FallbackChain"> | string
    description?: StringNullableWithAggregatesFilter<"FallbackChain"> | string | null
    models?: JsonWithAggregatesFilter<"FallbackChain">
    triggerStatusCodes?: JsonWithAggregatesFilter<"FallbackChain">
    triggerErrorTypes?: JsonWithAggregatesFilter<"FallbackChain">
    triggerTimeoutMs?: IntWithAggregatesFilter<"FallbackChain"> | number
    maxRetries?: IntWithAggregatesFilter<"FallbackChain"> | number
    retryDelayMs?: IntWithAggregatesFilter<"FallbackChain"> | number
    preserveProtocol?: BoolWithAggregatesFilter<"FallbackChain"> | boolean
    isActive?: BoolWithAggregatesFilter<"FallbackChain"> | boolean
    isBuiltin?: BoolWithAggregatesFilter<"FallbackChain"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"FallbackChain"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FallbackChain"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FallbackChain"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FallbackChain"> | Date | string | null
  }

  export type CostStrategyWhereInput = {
    AND?: CostStrategyWhereInput | CostStrategyWhereInput[]
    OR?: CostStrategyWhereInput[]
    NOT?: CostStrategyWhereInput | CostStrategyWhereInput[]
    id?: UuidFilter<"CostStrategy"> | string
    strategyId?: StringFilter<"CostStrategy"> | string
    name?: StringFilter<"CostStrategy"> | string
    description?: StringNullableFilter<"CostStrategy"> | string | null
    costWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: DecimalNullableFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: IntNullableFilter<"CostStrategy"> | number | null
    minCapabilityScore?: IntNullableFilter<"CostStrategy"> | number | null
    scenarioWeights?: JsonNullableFilter<"CostStrategy">
    isActive?: BoolFilter<"CostStrategy"> | boolean
    isBuiltin?: BoolFilter<"CostStrategy"> | boolean
    isDeleted?: BoolFilter<"CostStrategy"> | boolean
    createdAt?: DateTimeFilter<"CostStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"CostStrategy"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CostStrategy"> | Date | string | null
  }

  export type CostStrategyOrderByWithRelationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrderInput | SortOrder
    maxLatencyMs?: SortOrderInput | SortOrder
    minCapabilityScore?: SortOrderInput | SortOrder
    scenarioWeights?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type CostStrategyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    strategyId?: string
    AND?: CostStrategyWhereInput | CostStrategyWhereInput[]
    OR?: CostStrategyWhereInput[]
    NOT?: CostStrategyWhereInput | CostStrategyWhereInput[]
    name?: StringFilter<"CostStrategy"> | string
    description?: StringNullableFilter<"CostStrategy"> | string | null
    costWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: DecimalNullableFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: IntNullableFilter<"CostStrategy"> | number | null
    minCapabilityScore?: IntNullableFilter<"CostStrategy"> | number | null
    scenarioWeights?: JsonNullableFilter<"CostStrategy">
    isActive?: BoolFilter<"CostStrategy"> | boolean
    isBuiltin?: BoolFilter<"CostStrategy"> | boolean
    isDeleted?: BoolFilter<"CostStrategy"> | boolean
    createdAt?: DateTimeFilter<"CostStrategy"> | Date | string
    updatedAt?: DateTimeFilter<"CostStrategy"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CostStrategy"> | Date | string | null
  }, "id" | "strategyId">

  export type CostStrategyOrderByWithAggregationInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrderInput | SortOrder
    maxLatencyMs?: SortOrderInput | SortOrder
    minCapabilityScore?: SortOrderInput | SortOrder
    scenarioWeights?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CostStrategyCountOrderByAggregateInput
    _avg?: CostStrategyAvgOrderByAggregateInput
    _max?: CostStrategyMaxOrderByAggregateInput
    _min?: CostStrategyMinOrderByAggregateInput
    _sum?: CostStrategySumOrderByAggregateInput
  }

  export type CostStrategyScalarWhereWithAggregatesInput = {
    AND?: CostStrategyScalarWhereWithAggregatesInput | CostStrategyScalarWhereWithAggregatesInput[]
    OR?: CostStrategyScalarWhereWithAggregatesInput[]
    NOT?: CostStrategyScalarWhereWithAggregatesInput | CostStrategyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CostStrategy"> | string
    strategyId?: StringWithAggregatesFilter<"CostStrategy"> | string
    name?: StringWithAggregatesFilter<"CostStrategy"> | string
    description?: StringNullableWithAggregatesFilter<"CostStrategy"> | string | null
    costWeight?: DecimalWithAggregatesFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalWithAggregatesFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalWithAggregatesFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: DecimalNullableWithAggregatesFilter<"CostStrategy"> | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: IntNullableWithAggregatesFilter<"CostStrategy"> | number | null
    minCapabilityScore?: IntNullableWithAggregatesFilter<"CostStrategy"> | number | null
    scenarioWeights?: JsonNullableWithAggregatesFilter<"CostStrategy">
    isActive?: BoolWithAggregatesFilter<"CostStrategy"> | boolean
    isBuiltin?: BoolWithAggregatesFilter<"CostStrategy"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"CostStrategy"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CostStrategy"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CostStrategy"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CostStrategy"> | Date | string | null
  }

  export type BotRoutingConfigWhereInput = {
    AND?: BotRoutingConfigWhereInput | BotRoutingConfigWhereInput[]
    OR?: BotRoutingConfigWhereInput[]
    NOT?: BotRoutingConfigWhereInput | BotRoutingConfigWhereInput[]
    id?: UuidFilter<"BotRoutingConfig"> | string
    botId?: UuidFilter<"BotRoutingConfig"> | string
    routingEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    routingMode?: StringFilter<"BotRoutingConfig"> | string
    fallbackEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    fallbackChainId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    costControlEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    costStrategyId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    dailyBudget?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFilter<"BotRoutingConfig"> | boolean
    downgradeModel?: StringNullableFilter<"BotRoutingConfig"> | string | null
    complexityRoutingEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    complexityRoutingConfigId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    createdAt?: DateTimeFilter<"BotRoutingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BotRoutingConfig"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }

  export type BotRoutingConfigOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    routingEnabled?: SortOrder
    routingMode?: SortOrder
    fallbackEnabled?: SortOrder
    fallbackChainId?: SortOrderInput | SortOrder
    costControlEnabled?: SortOrder
    costStrategyId?: SortOrderInput | SortOrder
    dailyBudget?: SortOrderInput | SortOrder
    monthlyBudget?: SortOrderInput | SortOrder
    alertThreshold?: SortOrderInput | SortOrder
    autoDowngrade?: SortOrder
    downgradeModel?: SortOrderInput | SortOrder
    complexityRoutingEnabled?: SortOrder
    complexityRoutingConfigId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: BotOrderByWithRelationInput
  }

  export type BotRoutingConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId?: string
    AND?: BotRoutingConfigWhereInput | BotRoutingConfigWhereInput[]
    OR?: BotRoutingConfigWhereInput[]
    NOT?: BotRoutingConfigWhereInput | BotRoutingConfigWhereInput[]
    routingEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    routingMode?: StringFilter<"BotRoutingConfig"> | string
    fallbackEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    fallbackChainId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    costControlEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    costStrategyId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    dailyBudget?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: DecimalNullableFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFilter<"BotRoutingConfig"> | boolean
    downgradeModel?: StringNullableFilter<"BotRoutingConfig"> | string | null
    complexityRoutingEnabled?: BoolFilter<"BotRoutingConfig"> | boolean
    complexityRoutingConfigId?: StringNullableFilter<"BotRoutingConfig"> | string | null
    createdAt?: DateTimeFilter<"BotRoutingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"BotRoutingConfig"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
  }, "id" | "botId">

  export type BotRoutingConfigOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    routingEnabled?: SortOrder
    routingMode?: SortOrder
    fallbackEnabled?: SortOrder
    fallbackChainId?: SortOrderInput | SortOrder
    costControlEnabled?: SortOrder
    costStrategyId?: SortOrderInput | SortOrder
    dailyBudget?: SortOrderInput | SortOrder
    monthlyBudget?: SortOrderInput | SortOrder
    alertThreshold?: SortOrderInput | SortOrder
    autoDowngrade?: SortOrder
    downgradeModel?: SortOrderInput | SortOrder
    complexityRoutingEnabled?: SortOrder
    complexityRoutingConfigId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: BotRoutingConfigCountOrderByAggregateInput
    _avg?: BotRoutingConfigAvgOrderByAggregateInput
    _max?: BotRoutingConfigMaxOrderByAggregateInput
    _min?: BotRoutingConfigMinOrderByAggregateInput
    _sum?: BotRoutingConfigSumOrderByAggregateInput
  }

  export type BotRoutingConfigScalarWhereWithAggregatesInput = {
    AND?: BotRoutingConfigScalarWhereWithAggregatesInput | BotRoutingConfigScalarWhereWithAggregatesInput[]
    OR?: BotRoutingConfigScalarWhereWithAggregatesInput[]
    NOT?: BotRoutingConfigScalarWhereWithAggregatesInput | BotRoutingConfigScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotRoutingConfig"> | string
    botId?: UuidWithAggregatesFilter<"BotRoutingConfig"> | string
    routingEnabled?: BoolWithAggregatesFilter<"BotRoutingConfig"> | boolean
    routingMode?: StringWithAggregatesFilter<"BotRoutingConfig"> | string
    fallbackEnabled?: BoolWithAggregatesFilter<"BotRoutingConfig"> | boolean
    fallbackChainId?: StringNullableWithAggregatesFilter<"BotRoutingConfig"> | string | null
    costControlEnabled?: BoolWithAggregatesFilter<"BotRoutingConfig"> | boolean
    costStrategyId?: StringNullableWithAggregatesFilter<"BotRoutingConfig"> | string | null
    dailyBudget?: DecimalNullableWithAggregatesFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: DecimalNullableWithAggregatesFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: DecimalNullableWithAggregatesFilter<"BotRoutingConfig"> | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolWithAggregatesFilter<"BotRoutingConfig"> | boolean
    downgradeModel?: StringNullableWithAggregatesFilter<"BotRoutingConfig"> | string | null
    complexityRoutingEnabled?: BoolWithAggregatesFilter<"BotRoutingConfig"> | boolean
    complexityRoutingConfigId?: StringNullableWithAggregatesFilter<"BotRoutingConfig"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"BotRoutingConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"BotRoutingConfig"> | Date | string
  }

  export type ComplexityRoutingConfigWhereInput = {
    AND?: ComplexityRoutingConfigWhereInput | ComplexityRoutingConfigWhereInput[]
    OR?: ComplexityRoutingConfigWhereInput[]
    NOT?: ComplexityRoutingConfigWhereInput | ComplexityRoutingConfigWhereInput[]
    id?: UuidFilter<"ComplexityRoutingConfig"> | string
    configId?: StringFilter<"ComplexityRoutingConfig"> | string
    name?: StringFilter<"ComplexityRoutingConfig"> | string
    description?: StringNullableFilter<"ComplexityRoutingConfig"> | string | null
    models?: JsonFilter<"ComplexityRoutingConfig">
    classifierModel?: StringFilter<"ComplexityRoutingConfig"> | string
    classifierVendor?: StringFilter<"ComplexityRoutingConfig"> | string
    toolMinComplexity?: StringNullableFilter<"ComplexityRoutingConfig"> | string | null
    isEnabled?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    isBuiltin?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    isDeleted?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    createdAt?: DateTimeFilter<"ComplexityRoutingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ComplexityRoutingConfig"> | Date | string
  }

  export type ComplexityRoutingConfigOrderByWithRelationInput = {
    id?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    models?: SortOrder
    classifierModel?: SortOrder
    classifierVendor?: SortOrder
    toolMinComplexity?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplexityRoutingConfigWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    configId?: string
    AND?: ComplexityRoutingConfigWhereInput | ComplexityRoutingConfigWhereInput[]
    OR?: ComplexityRoutingConfigWhereInput[]
    NOT?: ComplexityRoutingConfigWhereInput | ComplexityRoutingConfigWhereInput[]
    name?: StringFilter<"ComplexityRoutingConfig"> | string
    description?: StringNullableFilter<"ComplexityRoutingConfig"> | string | null
    models?: JsonFilter<"ComplexityRoutingConfig">
    classifierModel?: StringFilter<"ComplexityRoutingConfig"> | string
    classifierVendor?: StringFilter<"ComplexityRoutingConfig"> | string
    toolMinComplexity?: StringNullableFilter<"ComplexityRoutingConfig"> | string | null
    isEnabled?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    isBuiltin?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    isDeleted?: BoolFilter<"ComplexityRoutingConfig"> | boolean
    createdAt?: DateTimeFilter<"ComplexityRoutingConfig"> | Date | string
    updatedAt?: DateTimeFilter<"ComplexityRoutingConfig"> | Date | string
  }, "id" | "configId">

  export type ComplexityRoutingConfigOrderByWithAggregationInput = {
    id?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    models?: SortOrder
    classifierModel?: SortOrder
    classifierVendor?: SortOrder
    toolMinComplexity?: SortOrderInput | SortOrder
    isEnabled?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ComplexityRoutingConfigCountOrderByAggregateInput
    _max?: ComplexityRoutingConfigMaxOrderByAggregateInput
    _min?: ComplexityRoutingConfigMinOrderByAggregateInput
  }

  export type ComplexityRoutingConfigScalarWhereWithAggregatesInput = {
    AND?: ComplexityRoutingConfigScalarWhereWithAggregatesInput | ComplexityRoutingConfigScalarWhereWithAggregatesInput[]
    OR?: ComplexityRoutingConfigScalarWhereWithAggregatesInput[]
    NOT?: ComplexityRoutingConfigScalarWhereWithAggregatesInput | ComplexityRoutingConfigScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ComplexityRoutingConfig"> | string
    configId?: StringWithAggregatesFilter<"ComplexityRoutingConfig"> | string
    name?: StringWithAggregatesFilter<"ComplexityRoutingConfig"> | string
    description?: StringNullableWithAggregatesFilter<"ComplexityRoutingConfig"> | string | null
    models?: JsonWithAggregatesFilter<"ComplexityRoutingConfig">
    classifierModel?: StringWithAggregatesFilter<"ComplexityRoutingConfig"> | string
    classifierVendor?: StringWithAggregatesFilter<"ComplexityRoutingConfig"> | string
    toolMinComplexity?: StringNullableWithAggregatesFilter<"ComplexityRoutingConfig"> | string | null
    isEnabled?: BoolWithAggregatesFilter<"ComplexityRoutingConfig"> | boolean
    isBuiltin?: BoolWithAggregatesFilter<"ComplexityRoutingConfig"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"ComplexityRoutingConfig"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ComplexityRoutingConfig"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ComplexityRoutingConfig"> | Date | string
  }

  export type UserInfoCreateInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateManyInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
  }

  export type UserInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaTemplateCreateInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateCreateManyInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonaTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthCreateInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutWechatAuthInput
  }

  export type WechatAuthUncheckedCreateInput = {
    openid: string
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUpdateInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutWechatAuthNestedInput
  }

  export type WechatAuthUncheckedUpdateInput = {
    openid?: StringFieldUpdateOperationsInput | string
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthCreateManyInput = {
    openid: string
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUpdateManyMutationInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthUncheckedUpdateManyInput = {
    openid?: StringFieldUpdateOperationsInput | string
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthCreateInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutGoogleAuthInput
  }

  export type GoogleAuthUncheckedCreateInput = {
    sub: string
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutGoogleAuthNestedInput
  }

  export type GoogleAuthUncheckedUpdateInput = {
    sub?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthCreateManyInput = {
    sub: string
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUncheckedUpdateManyInput = {
    sub?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthCreateInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutDiscordAuthInput
  }

  export type DiscordAuthUncheckedCreateInput = {
    discordId: string
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutDiscordAuthNestedInput
  }

  export type DiscordAuthUncheckedUpdateInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthCreateManyInput = {
    discordId: string
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUncheckedUpdateManyInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthCreateInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutMobileAuthInput
  }

  export type MobileAuthUncheckedCreateInput = {
    mobile: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutMobileAuthNestedInput
  }

  export type MobileAuthUncheckedUpdateInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthCreateManyInput = {
    mobile: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUncheckedUpdateManyInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthCreateInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutEmailAuthInput
  }

  export type EmailAuthUncheckedCreateInput = {
    email: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutEmailAuthNestedInput
  }

  export type EmailAuthUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthCreateManyInput = {
    email: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordCreateInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUncheckedCreateInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordCreateManyInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemTaskQueueCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUncheckedCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueCreateManyInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileSourceCreateInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceCreateManyInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeCreateInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUncheckedCreateInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeCreateManyInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotCreateInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotCreateManyInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyCreateInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyCreateManyInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProviderKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotProviderKeyCreateInput = {
    id?: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutProviderKeysInput
    providerKey: ProviderKeyCreateNestedOneWithoutBotProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateInput = {
    id?: string
    botId: string
    providerKeyId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotProviderKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProviderKeysNestedInput
    providerKey?: ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyCreateManyInput = {
    id?: string
    botId: string
    providerKeyId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotProviderKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogCreateInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
    bot: BotCreateNestedOneWithoutUsageLogsInput
    providerKey?: ProviderKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateInput = {
    id?: string
    botId: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type BotUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
    bot?: BotUpdateOneRequiredWithoutUsageLogsNestedInput
    providerKey?: ProviderKeyUpdateOneWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BotUsageLogCreateManyInput = {
    id?: string
    botId: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type BotUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BotUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxyTokenCreateInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutProxyTokenInput
    providerKey: ProviderKeyCreateNestedOneWithoutProxyTokensInput
  }

  export type ProxyTokenUncheckedCreateInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProxyTokenNestedInput
    providerKey?: ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput
  }

  export type ProxyTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenCreateManyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    sender?: UserInfoCreateNestedOneWithoutSentMessagesInput
    recipients?: MessageRecipientCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserInfoUpdateOneWithoutSentMessagesNestedInput
    recipients?: MessageRecipientUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientCreateInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutRecipientsInput
    user: UserInfoCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageRecipientUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutRecipientsNestedInput
    user?: UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperateLogCreateInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserInfoCreateNestedOneWithoutOperateLogsInput
  }

  export type OperateLogUncheckedCreateInput = {
    id?: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserInfoUpdateOneRequiredWithoutOperateLogsNestedInput
  }

  export type OperateLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogCreateManyInput = {
    id?: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelDefinitionCreateInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    popularLocales?: ChannelDefinitionCreatepopularLocalesInput | string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    credentialFields?: ChannelCredentialFieldCreateNestedManyWithoutChannelInput
  }

  export type ChannelDefinitionUncheckedCreateInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    popularLocales?: ChannelDefinitionCreatepopularLocalesInput | string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    credentialFields?: ChannelCredentialFieldUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialFields?: ChannelCredentialFieldUpdateManyWithoutChannelNestedInput
  }

  export type ChannelDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialFields?: ChannelCredentialFieldUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelDefinitionCreateManyInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    popularLocales?: ChannelDefinitionCreatepopularLocalesInput | string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: ChannelDefinitionCreateNestedOneWithoutCredentialFieldsInput
  }

  export type ChannelCredentialFieldUncheckedCreateInput = {
    id?: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: ChannelDefinitionUpdateOneRequiredWithoutCredentialFieldsNestedInput
  }

  export type ChannelCredentialFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateManyInput = {
    id?: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version: string
    author?: string | null
    category: $Enums.PluginCategory
    region?: string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: string | null
    iconEmoji?: string | null
    iconUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installations?: BotPluginCreateNestedManyWithoutPluginInput
  }

  export type PluginUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version: string
    author?: string | null
    category: $Enums.PluginCategory
    region?: string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: string | null
    iconEmoji?: string | null
    iconUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installations?: BotPluginUncheckedCreateNestedManyWithoutPluginInput
  }

  export type PluginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installations?: BotPluginUpdateManyWithoutPluginNestedInput
  }

  export type PluginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installations?: BotPluginUncheckedUpdateManyWithoutPluginNestedInput
  }

  export type PluginCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version: string
    author?: string | null
    category: $Enums.PluginCategory
    region?: string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: string | null
    iconEmoji?: string | null
    iconUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PluginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotPluginCreateInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutPluginsInput
    plugin: PluginCreateNestedOneWithoutInstallationsInput
  }

  export type BotPluginUncheckedCreateInput = {
    id?: string
    botId: string
    pluginId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotPluginUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutPluginsNestedInput
    plugin?: PluginUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type BotPluginUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotPluginCreateManyInput = {
    id?: string
    botId: string
    pluginId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotPluginUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotPluginUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillTypeCreateInput = {
    id?: string
    slug: string
    name: string
    nameZh?: string | null
    description?: string | null
    descriptionZh?: string | null
    icon?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    skills?: SkillCreateNestedManyWithoutSkillTypeInput
  }

  export type SkillTypeUncheckedCreateInput = {
    id?: string
    slug: string
    name: string
    nameZh?: string | null
    description?: string | null
    descriptionZh?: string | null
    icon?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    skills?: SkillUncheckedCreateNestedManyWithoutSkillTypeInput
  }

  export type SkillTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skills?: SkillUpdateManyWithoutSkillTypeNestedInput
  }

  export type SkillTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skills?: SkillUncheckedUpdateManyWithoutSkillTypeNestedInput
  }

  export type SkillTypeCreateManyInput = {
    id?: string
    slug: string
    name: string
    nameZh?: string | null
    description?: string | null
    descriptionZh?: string | null
    icon?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillCreateInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    skillType?: SkillTypeCreateNestedOneWithoutSkillsInput
    installations?: BotSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    skillTypeId?: string | null
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installations?: BotSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skillType?: SkillTypeUpdateOneWithoutSkillsNestedInput
    installations?: BotSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    skillTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installations?: BotSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillCreateManyInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    skillTypeId?: string | null
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    skillTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotSkillCreateInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutSkillsInput
    skill: SkillCreateNestedOneWithoutInstallationsInput
  }

  export type BotSkillUncheckedCreateInput = {
    id?: string
    botId: string
    skillId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutSkillsNestedInput
    skill?: SkillUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type BotSkillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotSkillCreateManyInput = {
    id?: string
    botId: string
    skillId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotSkillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ModelPricingCreateInput = {
    id?: string
    model: string
    vendor: string
    displayName?: string | null
    description?: string | null
    inputPrice: Decimal | DecimalJsLike | number | string
    outputPrice: Decimal | DecimalJsLike | number | string
    cacheReadPrice?: Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: Decimal | DecimalJsLike | number | string | null
    reasoningScore?: number
    codingScore?: number
    creativityScore?: number
    speedScore?: number
    contextLength?: number
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: Date | string | null
    priceUpdatedAt?: Date | string
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ModelPricingUncheckedCreateInput = {
    id?: string
    model: string
    vendor: string
    displayName?: string | null
    description?: string | null
    inputPrice: Decimal | DecimalJsLike | number | string
    outputPrice: Decimal | DecimalJsLike | number | string
    cacheReadPrice?: Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: Decimal | DecimalJsLike | number | string | null
    reasoningScore?: number
    codingScore?: number
    creativityScore?: number
    speedScore?: number
    contextLength?: number
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: Date | string | null
    priceUpdatedAt?: Date | string
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ModelPricingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFieldUpdateOperationsInput | number
    codingScore?: IntFieldUpdateOperationsInput | number
    creativityScore?: IntFieldUpdateOperationsInput | number
    speedScore?: IntFieldUpdateOperationsInput | number
    contextLength?: IntFieldUpdateOperationsInput | number
    supportsExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    supportsCacheControl?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctionCalling?: BoolFieldUpdateOperationsInput | boolean
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelPricingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFieldUpdateOperationsInput | number
    codingScore?: IntFieldUpdateOperationsInput | number
    creativityScore?: IntFieldUpdateOperationsInput | number
    speedScore?: IntFieldUpdateOperationsInput | number
    contextLength?: IntFieldUpdateOperationsInput | number
    supportsExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    supportsCacheControl?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctionCalling?: BoolFieldUpdateOperationsInput | boolean
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelPricingCreateManyInput = {
    id?: string
    model: string
    vendor: string
    displayName?: string | null
    description?: string | null
    inputPrice: Decimal | DecimalJsLike | number | string
    outputPrice: Decimal | DecimalJsLike | number | string
    cacheReadPrice?: Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: Decimal | DecimalJsLike | number | string | null
    reasoningScore?: number
    codingScore?: number
    creativityScore?: number
    speedScore?: number
    contextLength?: number
    supportsExtendedThinking?: boolean
    supportsCacheControl?: boolean
    supportsVision?: boolean
    supportsFunctionCalling?: boolean
    supportsStreaming?: boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    isDeprecated?: boolean
    deprecationDate?: Date | string | null
    priceUpdatedAt?: Date | string
    notes?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ModelPricingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFieldUpdateOperationsInput | number
    codingScore?: IntFieldUpdateOperationsInput | number
    creativityScore?: IntFieldUpdateOperationsInput | number
    speedScore?: IntFieldUpdateOperationsInput | number
    contextLength?: IntFieldUpdateOperationsInput | number
    supportsExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    supportsCacheControl?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctionCalling?: BoolFieldUpdateOperationsInput | boolean
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ModelPricingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    displayName?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    inputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    outputPrice?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    cacheReadPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheWritePrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingPrice?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    reasoningScore?: IntFieldUpdateOperationsInput | number
    codingScore?: IntFieldUpdateOperationsInput | number
    creativityScore?: IntFieldUpdateOperationsInput | number
    speedScore?: IntFieldUpdateOperationsInput | number
    contextLength?: IntFieldUpdateOperationsInput | number
    supportsExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    supportsCacheControl?: BoolFieldUpdateOperationsInput | boolean
    supportsVision?: BoolFieldUpdateOperationsInput | boolean
    supportsFunctionCalling?: BoolFieldUpdateOperationsInput | boolean
    supportsStreaming?: BoolFieldUpdateOperationsInput | boolean
    recommendedScenarios?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeprecated?: BoolFieldUpdateOperationsInput | boolean
    deprecationDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priceUpdatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingCreateInput = {
    id?: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bot: BotCreateNestedOneWithoutModelRoutingsInput
  }

  export type BotModelRoutingUncheckedCreateInput = {
    id?: string
    botId: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotModelRoutingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bot?: BotUpdateOneRequiredWithoutModelRoutingsNestedInput
  }

  export type BotModelRoutingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingCreateManyInput = {
    id?: string
    botId: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotModelRoutingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotChannelCreateInput = {
    id?: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bot: BotCreateNestedOneWithoutChannelsInput
  }

  export type BotChannelUncheckedCreateInput = {
    id?: string
    botId: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotChannelUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bot?: BotUpdateOneRequiredWithoutChannelsNestedInput
  }

  export type BotChannelUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotChannelCreateManyInput = {
    id?: string
    botId: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotChannelUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotChannelUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CapabilityTagCreateInput = {
    id?: string
    tagId: string
    name: string
    description?: string | null
    category: string
    priority?: number
    requiredProtocol?: string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CapabilityTagUncheckedCreateInput = {
    id?: string
    tagId: string
    name: string
    description?: string | null
    category: string
    priority?: number
    requiredProtocol?: string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CapabilityTagUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    requiredProtocol?: NullableStringFieldUpdateOperationsInput | string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    requiresCacheControl?: BoolFieldUpdateOperationsInput | boolean
    requiresVision?: BoolFieldUpdateOperationsInput | boolean
    maxCostPerMToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CapabilityTagUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    requiredProtocol?: NullableStringFieldUpdateOperationsInput | string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    requiresCacheControl?: BoolFieldUpdateOperationsInput | boolean
    requiresVision?: BoolFieldUpdateOperationsInput | boolean
    maxCostPerMToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CapabilityTagCreateManyInput = {
    id?: string
    tagId: string
    name: string
    description?: string | null
    category: string
    priority?: number
    requiredProtocol?: string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: boolean
    requiresCacheControl?: boolean
    requiresVision?: boolean
    maxCostPerMToken?: Decimal | DecimalJsLike | number | string | null
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CapabilityTagUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    requiredProtocol?: NullableStringFieldUpdateOperationsInput | string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    requiresCacheControl?: BoolFieldUpdateOperationsInput | boolean
    requiresVision?: BoolFieldUpdateOperationsInput | boolean
    maxCostPerMToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CapabilityTagUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tagId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    priority?: IntFieldUpdateOperationsInput | number
    requiredProtocol?: NullableStringFieldUpdateOperationsInput | string | null
    requiredSkills?: NullableJsonNullValueInput | InputJsonValue
    requiredModels?: NullableJsonNullValueInput | InputJsonValue
    requiresExtendedThinking?: BoolFieldUpdateOperationsInput | boolean
    requiresCacheControl?: BoolFieldUpdateOperationsInput | boolean
    requiresVision?: BoolFieldUpdateOperationsInput | boolean
    maxCostPerMToken?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FallbackChainCreateInput = {
    id?: string
    chainId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: number
    maxRetries?: number
    retryDelayMs?: number
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FallbackChainUncheckedCreateInput = {
    id?: string
    chainId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: number
    maxRetries?: number
    retryDelayMs?: number
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FallbackChainUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelayMs?: IntFieldUpdateOperationsInput | number
    preserveProtocol?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FallbackChainUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelayMs?: IntFieldUpdateOperationsInput | number
    preserveProtocol?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FallbackChainCreateManyInput = {
    id?: string
    chainId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: number
    maxRetries?: number
    retryDelayMs?: number
    preserveProtocol?: boolean
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FallbackChainUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelayMs?: IntFieldUpdateOperationsInput | number
    preserveProtocol?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FallbackChainUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    chainId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    triggerStatusCodes?: JsonNullValueInput | InputJsonValue
    triggerErrorTypes?: JsonNullValueInput | InputJsonValue
    triggerTimeoutMs?: IntFieldUpdateOperationsInput | number
    maxRetries?: IntFieldUpdateOperationsInput | number
    retryDelayMs?: IntFieldUpdateOperationsInput | number
    preserveProtocol?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CostStrategyCreateInput = {
    id?: string
    strategyId: string
    name: string
    description?: string | null
    costWeight?: Decimal | DecimalJsLike | number | string
    performanceWeight?: Decimal | DecimalJsLike | number | string
    capabilityWeight?: Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: number | null
    minCapabilityScore?: number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CostStrategyUncheckedCreateInput = {
    id?: string
    strategyId: string
    name: string
    description?: string | null
    costWeight?: Decimal | DecimalJsLike | number | string
    performanceWeight?: Decimal | DecimalJsLike | number | string
    capabilityWeight?: Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: number | null
    minCapabilityScore?: number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CostStrategyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    minCapabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CostStrategyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    minCapabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CostStrategyCreateManyInput = {
    id?: string
    strategyId: string
    name: string
    description?: string | null
    costWeight?: Decimal | DecimalJsLike | number | string
    performanceWeight?: Decimal | DecimalJsLike | number | string
    capabilityWeight?: Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: number | null
    minCapabilityScore?: number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CostStrategyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    minCapabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CostStrategyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    strategyId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    costWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    performanceWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    capabilityWeight?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    maxCostPerRequest?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    maxLatencyMs?: NullableIntFieldUpdateOperationsInput | number | null
    minCapabilityScore?: NullableIntFieldUpdateOperationsInput | number | null
    scenarioWeights?: NullableJsonNullValueInput | InputJsonValue
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotRoutingConfigCreateInput = {
    id?: string
    routingEnabled?: boolean
    routingMode?: string
    fallbackEnabled?: boolean
    fallbackChainId?: string | null
    costControlEnabled?: boolean
    costStrategyId?: string | null
    dailyBudget?: Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: Decimal | DecimalJsLike | number | string | null
    alertThreshold?: Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: boolean
    downgradeModel?: string | null
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutRoutingConfigInput
  }

  export type BotRoutingConfigUncheckedCreateInput = {
    id?: string
    botId: string
    routingEnabled?: boolean
    routingMode?: string
    fallbackEnabled?: boolean
    fallbackChainId?: string | null
    costControlEnabled?: boolean
    costStrategyId?: string | null
    dailyBudget?: Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: Decimal | DecimalJsLike | number | string | null
    alertThreshold?: Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: boolean
    downgradeModel?: string | null
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotRoutingConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutRoutingConfigNestedInput
  }

  export type BotRoutingConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotRoutingConfigCreateManyInput = {
    id?: string
    botId: string
    routingEnabled?: boolean
    routingMode?: string
    fallbackEnabled?: boolean
    fallbackChainId?: string | null
    costControlEnabled?: boolean
    costStrategyId?: string | null
    dailyBudget?: Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: Decimal | DecimalJsLike | number | string | null
    alertThreshold?: Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: boolean
    downgradeModel?: string | null
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotRoutingConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotRoutingConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplexityRoutingConfigCreateInput = {
    id?: string
    configId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    classifierModel?: string
    classifierVendor?: string
    toolMinComplexity?: string | null
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplexityRoutingConfigUncheckedCreateInput = {
    id?: string
    configId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    classifierModel?: string
    classifierVendor?: string
    toolMinComplexity?: string | null
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplexityRoutingConfigUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    classifierModel?: StringFieldUpdateOperationsInput | string
    classifierVendor?: StringFieldUpdateOperationsInput | string
    toolMinComplexity?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplexityRoutingConfigUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    classifierModel?: StringFieldUpdateOperationsInput | string
    classifierVendor?: StringFieldUpdateOperationsInput | string
    toolMinComplexity?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplexityRoutingConfigCreateManyInput = {
    id?: string
    configId: string
    name: string
    description?: string | null
    models: JsonNullValueInput | InputJsonValue
    classifierModel?: string
    classifierVendor?: string
    toolMinComplexity?: string | null
    isEnabled?: boolean
    isBuiltin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ComplexityRoutingConfigUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    classifierModel?: StringFieldUpdateOperationsInput | string
    classifierVendor?: StringFieldUpdateOperationsInput | string
    toolMinComplexity?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ComplexityRoutingConfigUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    configId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    models?: JsonNullValueInput | InputJsonValue
    classifierModel?: StringFieldUpdateOperationsInput | string
    classifierVendor?: StringFieldUpdateOperationsInput | string
    toolMinComplexity?: NullableStringFieldUpdateOperationsInput | string | null
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isBuiltin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeFilter<$PrismaModel> | $Enums.SexType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FileSourceNullableScalarRelationFilter = {
    is?: FileSourceWhereInput | null
    isNot?: FileSourceWhereInput | null
  }

  export type WechatAuthNullableScalarRelationFilter = {
    is?: WechatAuthWhereInput | null
    isNot?: WechatAuthWhereInput | null
  }

  export type GoogleAuthNullableScalarRelationFilter = {
    is?: GoogleAuthWhereInput | null
    isNot?: GoogleAuthWhereInput | null
  }

  export type DiscordAuthNullableScalarRelationFilter = {
    is?: DiscordAuthWhereInput | null
    isNot?: DiscordAuthWhereInput | null
  }

  export type MobileAuthNullableScalarRelationFilter = {
    is?: MobileAuthWhereInput | null
    isNot?: MobileAuthWhereInput | null
  }

  export type EmailAuthNullableScalarRelationFilter = {
    is?: EmailAuthWhereInput | null
    isNot?: EmailAuthWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageRecipientListRelationFilter = {
    every?: MessageRecipientWhereInput
    some?: MessageRecipientWhereInput
    none?: MessageRecipientWhereInput
  }

  export type BotListRelationFilter = {
    every?: BotWhereInput
    some?: BotWhereInput
    none?: BotWhereInput
  }

  export type ProviderKeyListRelationFilter = {
    every?: ProviderKeyWhereInput
    some?: ProviderKeyWhereInput
    none?: ProviderKeyWhereInput
  }

  export type PersonaTemplateListRelationFilter = {
    every?: PersonaTemplateWhereInput
    some?: PersonaTemplateWhereInput
    none?: PersonaTemplateWhereInput
  }

  export type OperateLogListRelationFilter = {
    every?: OperateLogWhereInput
    some?: OperateLogWhereInput
    none?: OperateLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonaTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperateLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInfoCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UserInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UserInfoMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeWithAggregatesFilter<$PrismaModel> | $Enums.SexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexTypeFilter<$PrismaModel>
    _max?: NestedEnumSexTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserInfoNullableScalarRelationFilter = {
    is?: UserInfoWhereInput | null
    isNot?: UserInfoWhereInput | null
  }

  export type PersonaTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    locale?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonaTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    locale?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonaTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    locale?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserInfoScalarRelationFilter = {
    is?: UserInfoWhereInput
    isNot?: UserInfoWhereInput
  }

  export type WechatAuthCountOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WechatAuthMaxOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WechatAuthMinOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GoogleAuthCountOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthAvgOrderByAggregateInput = {
    exp?: SortOrder
    iat?: SortOrder
  }

  export type GoogleAuthMaxOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthMinOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthSumOrderByAggregateInput = {
    exp?: SortOrder
    iat?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DiscordAuthCountOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DiscordAuthMaxOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DiscordAuthMinOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthCountOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthMaxOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthMinOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthCountOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthMaxOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthMinOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RiskDetectionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type RiskDetectionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordSumOrderByAggregateInput = {
    status?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type SystemTaskQueueCountOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    templateData?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type SystemTaskQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueMinOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFileEnvTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeFilter<$PrismaModel> | $Enums.FileEnvType
  }

  export type EnumFileBucketVendorFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorFilter<$PrismaModel> | $Enums.FileBucketVendor
  }

  export type UserInfoListRelationFilter = {
    every?: UserInfoWhereInput
    some?: UserInfoWhereInput
    none?: UserInfoWhereInput
  }

  export type UserInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileSourceCountOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceAvgOrderByAggregateInput = {
    fsize?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parts?: SortOrder
  }

  export type FileSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceMinOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceSumOrderByAggregateInput = {
    fsize?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parts?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumFileEnvTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileEnvType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileEnvTypeFilter<$PrismaModel>
    _max?: NestedEnumFileEnvTypeFilter<$PrismaModel>
  }

  export type EnumFileBucketVendorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel> | $Enums.FileBucketVendor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileBucketVendorFilter<$PrismaModel>
    _max?: NestedEnumFileBucketVendorFilter<$PrismaModel>
  }

  export type CountryCodeContinentCodeCompoundUniqueInput = {
    continent: string
    code: string
  }

  export type CountryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumBotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusFilter<$PrismaModel> | $Enums.BotStatus
  }

  export type EnumHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthStatusFilter<$PrismaModel> | $Enums.HealthStatus
  }

  export type PersonaTemplateNullableScalarRelationFilter = {
    is?: PersonaTemplateWhereInput | null
    isNot?: PersonaTemplateWhereInput | null
  }

  export type BotProviderKeyListRelationFilter = {
    every?: BotProviderKeyWhereInput
    some?: BotProviderKeyWhereInput
    none?: BotProviderKeyWhereInput
  }

  export type BotUsageLogListRelationFilter = {
    every?: BotUsageLogWhereInput
    some?: BotUsageLogWhereInput
    none?: BotUsageLogWhereInput
  }

  export type ProxyTokenNullableScalarRelationFilter = {
    is?: ProxyTokenWhereInput | null
    isNot?: ProxyTokenWhereInput | null
  }

  export type BotPluginListRelationFilter = {
    every?: BotPluginWhereInput
    some?: BotPluginWhereInput
    none?: BotPluginWhereInput
  }

  export type BotSkillListRelationFilter = {
    every?: BotSkillWhereInput
    some?: BotSkillWhereInput
    none?: BotSkillWhereInput
  }

  export type BotChannelListRelationFilter = {
    every?: BotChannelWhereInput
    some?: BotChannelWhereInput
    none?: BotChannelWhereInput
  }

  export type BotModelRoutingListRelationFilter = {
    every?: BotModelRoutingWhereInput
    some?: BotModelRoutingWhereInput
    none?: BotModelRoutingWhereInput
  }

  export type BotRoutingConfigNullableScalarRelationFilter = {
    is?: BotRoutingConfigWhereInput | null
    isNot?: BotRoutingConfigWhereInput | null
  }

  export type BotProviderKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotPluginOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotSkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotChannelOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotModelRoutingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    pendingConfig?: SortOrder
    healthStatus?: SortOrder
    lastHealthCheck?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type BotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    healthStatus?: SortOrder
    lastHealthCheck?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    healthStatus?: SortOrder
    lastHealthCheck?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusWithAggregatesFilter<$PrismaModel> | $Enums.BotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotStatusFilter<$PrismaModel>
    _max?: NestedEnumBotStatusFilter<$PrismaModel>
  }

  export type EnumHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.HealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumHealthStatusFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type ProxyTokenListRelationFilter = {
    every?: ProxyTokenWhereInput
    some?: ProxyTokenWhereInput
    none?: ProxyTokenWhereInput
  }

  export type ProxyTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderKeyProvider_key_user_label_uniqueCompoundUniqueInput = {
    createdById: string
    label: string
  }

  export type ProviderKeyCountOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProviderKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProviderKeyMinOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type BotScalarRelationFilter = {
    is?: BotWhereInput
    isNot?: BotWhereInput
  }

  export type ProviderKeyScalarRelationFilter = {
    is?: ProviderKeyWhereInput
    isNot?: ProviderKeyWhereInput
  }

  export type BotProviderKeyBotIdProviderKeyIdCompoundUniqueInput = {
    botId: string
    providerKeyId: string
  }

  export type BotProviderKeyCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    allowedModels?: SortOrder
    primaryModel?: SortOrder
    createdAt?: SortOrder
  }

  export type BotProviderKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    primaryModel?: SortOrder
    createdAt?: SortOrder
  }

  export type BotProviderKeyMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    primaryModel?: SortOrder
    createdAt?: SortOrder
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type ProviderKeyNullableScalarRelationFilter = {
    is?: ProviderKeyWhereInput | null
    isNot?: ProviderKeyWhereInput | null
  }

  export type BotUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    thinkingTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    protocolType?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    thinkingCost?: SortOrder
    cacheCost?: SortOrder
    totalCost?: SortOrder
    fallbackUsed?: SortOrder
    fallbackLevel?: SortOrder
    originalModel?: SortOrder
  }

  export type BotUsageLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    durationMs?: SortOrder
    thinkingTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    thinkingCost?: SortOrder
    cacheCost?: SortOrder
    totalCost?: SortOrder
    fallbackLevel?: SortOrder
  }

  export type BotUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    thinkingTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    protocolType?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    thinkingCost?: SortOrder
    cacheCost?: SortOrder
    totalCost?: SortOrder
    fallbackUsed?: SortOrder
    fallbackLevel?: SortOrder
    originalModel?: SortOrder
  }

  export type BotUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
    model?: SortOrder
    endpoint?: SortOrder
    durationMs?: SortOrder
    errorMessage?: SortOrder
    thinkingTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    protocolType?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    thinkingCost?: SortOrder
    cacheCost?: SortOrder
    totalCost?: SortOrder
    fallbackUsed?: SortOrder
    fallbackLevel?: SortOrder
    originalModel?: SortOrder
  }

  export type BotUsageLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    durationMs?: SortOrder
    thinkingTokens?: SortOrder
    cacheReadTokens?: SortOrder
    cacheWriteTokens?: SortOrder
    inputCost?: SortOrder
    outputCost?: SortOrder
    thinkingCost?: SortOrder
    cacheCost?: SortOrder
    totalCost?: SortOrder
    fallbackLevel?: SortOrder
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type ProxyTokenCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenAvgOrderByAggregateInput = {
    requestCount?: SortOrder
  }

  export type ProxyTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenSumOrderByAggregateInput = {
    requestCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageRecipientMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumOperateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeFilter<$PrismaModel> | $Enums.OperateType
  }

  export type EnumOperateTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetFilter<$PrismaModel> | $Enums.OperateTarget
  }

  export type OperateLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    detail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperateLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperateLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOperateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTypeFilter<$PrismaModel>
    _max?: NestedEnumOperateTypeFilter<$PrismaModel>
  }

  export type EnumOperateTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel> | $Enums.OperateTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTargetFilter<$PrismaModel>
    _max?: NestedEnumOperateTargetFilter<$PrismaModel>
  }

  export type ChannelCredentialFieldListRelationFilter = {
    every?: ChannelCredentialFieldWhereInput
    some?: ChannelCredentialFieldWhereInput
    none?: ChannelCredentialFieldWhereInput
  }

  export type ChannelCredentialFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    popularLocales?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelDefinitionScalarRelationFilter = {
    is?: ChannelDefinitionWhereInput
    isNot?: ChannelDefinitionWhereInput
  }

  export type ChannelCredentialFieldChannelIdKeyCompoundUniqueInput = {
    channelId: string
    key: string
  }

  export type ChannelCredentialFieldCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelCredentialFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type EnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }

  export type PluginCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    region?: SortOrder
    configSchema?: SortOrder
    defaultConfig?: SortOrder
    mcpConfig?: SortOrder
    isOfficial?: SortOrder
    isEnabled?: SortOrder
    downloadUrl?: SortOrder
    iconEmoji?: SortOrder
    iconUrl?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PluginMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    region?: SortOrder
    isOfficial?: SortOrder
    isEnabled?: SortOrder
    downloadUrl?: SortOrder
    iconEmoji?: SortOrder
    iconUrl?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PluginMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    version?: SortOrder
    author?: SortOrder
    category?: SortOrder
    region?: SortOrder
    isOfficial?: SortOrder
    isEnabled?: SortOrder
    downloadUrl?: SortOrder
    iconEmoji?: SortOrder
    iconUrl?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }

  export type PluginScalarRelationFilter = {
    is?: PluginWhereInput
    isNot?: PluginWhereInput
  }

  export type BotPluginBotIdPluginIdCompoundUniqueInput = {
    botId: string
    pluginId: string
  }

  export type BotPluginCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    pluginId?: SortOrder
    config?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotPluginMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotPluginMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    pluginId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SkillListRelationFilter = {
    every?: SkillWhereInput
    some?: SkillWhereInput
    none?: SkillWhereInput
  }

  export type SkillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SkillTypeCountOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillTypeAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SkillTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillTypeMinOrderByAggregateInput = {
    id?: SortOrder
    slug?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    icon?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillTypeSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type SkillTypeNullableScalarRelationFilter = {
    is?: SkillTypeWhereInput | null
    isNot?: SkillTypeWhereInput | null
  }

  export type SkillSlugCreatedByIdCompoundUniqueInput = {
    slug: string
    createdById: string
  }

  export type SkillB_skill_source_slug_keyCompoundUniqueInput = {
    source: string
    slug: string
  }

  export type SkillCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    version?: SortOrder
    skillTypeId?: SortOrder
    definition?: SortOrder
    examples?: SortOrder
    isSystem?: SortOrder
    isEnabled?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    sourceUrl?: SortOrder
    author?: SortOrder
    lastSyncedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    version?: SortOrder
    skillTypeId?: SortOrder
    isSystem?: SortOrder
    isEnabled?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    sourceUrl?: SortOrder
    author?: SortOrder
    lastSyncedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    nameZh?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    descriptionZh?: SortOrder
    version?: SortOrder
    skillTypeId?: SortOrder
    isSystem?: SortOrder
    isEnabled?: SortOrder
    createdById?: SortOrder
    source?: SortOrder
    sourceUrl?: SortOrder
    author?: SortOrder
    lastSyncedAt?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type SkillScalarRelationFilter = {
    is?: SkillWhereInput
    isNot?: SkillWhereInput
  }

  export type BotSkillBotIdSkillIdCompoundUniqueInput = {
    botId: string
    skillId: string
  }

  export type BotSkillCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    skillId?: SortOrder
    config?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotSkillMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    skillId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotSkillMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    skillId?: SortOrder
    isEnabled?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type ModelPricingCountOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    vendor?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrder
    cacheWritePrice?: SortOrder
    thinkingPrice?: SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
    supportsExtendedThinking?: SortOrder
    supportsCacheControl?: SortOrder
    supportsVision?: SortOrder
    supportsFunctionCalling?: SortOrder
    supportsStreaming?: SortOrder
    recommendedScenarios?: SortOrder
    isEnabled?: SortOrder
    isDeprecated?: SortOrder
    deprecationDate?: SortOrder
    priceUpdatedAt?: SortOrder
    notes?: SortOrder
    metadata?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelPricingAvgOrderByAggregateInput = {
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrder
    cacheWritePrice?: SortOrder
    thinkingPrice?: SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
  }

  export type ModelPricingMaxOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    vendor?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrder
    cacheWritePrice?: SortOrder
    thinkingPrice?: SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
    supportsExtendedThinking?: SortOrder
    supportsCacheControl?: SortOrder
    supportsVision?: SortOrder
    supportsFunctionCalling?: SortOrder
    supportsStreaming?: SortOrder
    isEnabled?: SortOrder
    isDeprecated?: SortOrder
    deprecationDate?: SortOrder
    priceUpdatedAt?: SortOrder
    notes?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelPricingMinOrderByAggregateInput = {
    id?: SortOrder
    model?: SortOrder
    vendor?: SortOrder
    displayName?: SortOrder
    description?: SortOrder
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrder
    cacheWritePrice?: SortOrder
    thinkingPrice?: SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
    supportsExtendedThinking?: SortOrder
    supportsCacheControl?: SortOrder
    supportsVision?: SortOrder
    supportsFunctionCalling?: SortOrder
    supportsStreaming?: SortOrder
    isEnabled?: SortOrder
    isDeprecated?: SortOrder
    deprecationDate?: SortOrder
    priceUpdatedAt?: SortOrder
    notes?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ModelPricingSumOrderByAggregateInput = {
    inputPrice?: SortOrder
    outputPrice?: SortOrder
    cacheReadPrice?: SortOrder
    cacheWritePrice?: SortOrder
    thinkingPrice?: SortOrder
    reasoningScore?: SortOrder
    codingScore?: SortOrder
    creativityScore?: SortOrder
    speedScore?: SortOrder
    contextLength?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumModelRoutingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelRoutingType | EnumModelRoutingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModelRoutingTypeFilter<$PrismaModel> | $Enums.ModelRoutingType
  }

  export type BotModelRoutingCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingType?: SortOrder
    name?: SortOrder
    config?: SortOrder
    priority?: SortOrder
    isEnabled?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotModelRoutingAvgOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type BotModelRoutingMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingType?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isEnabled?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotModelRoutingMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingType?: SortOrder
    name?: SortOrder
    priority?: SortOrder
    isEnabled?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotModelRoutingSumOrderByAggregateInput = {
    priority?: SortOrder
  }

  export type EnumModelRoutingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelRoutingType | EnumModelRoutingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModelRoutingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModelRoutingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelRoutingTypeFilter<$PrismaModel>
    _max?: NestedEnumModelRoutingTypeFilter<$PrismaModel>
  }

  export type EnumChannelConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelConnectionStatus | EnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelConnectionStatusFilter<$PrismaModel> | $Enums.ChannelConnectionStatus
  }

  export type BotChannelBotIdChannelTypeNameCompoundUniqueInput = {
    botId: string
    channelType: string
    name: string
  }

  export type BotChannelCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    channelType?: SortOrder
    name?: SortOrder
    credentialsEncrypted?: SortOrder
    config?: SortOrder
    isEnabled?: SortOrder
    connectionStatus?: SortOrder
    lastConnectedAt?: SortOrder
    lastError?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotChannelMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    channelType?: SortOrder
    name?: SortOrder
    credentialsEncrypted?: SortOrder
    isEnabled?: SortOrder
    connectionStatus?: SortOrder
    lastConnectedAt?: SortOrder
    lastError?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotChannelMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    channelType?: SortOrder
    name?: SortOrder
    credentialsEncrypted?: SortOrder
    isEnabled?: SortOrder
    connectionStatus?: SortOrder
    lastConnectedAt?: SortOrder
    lastError?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumChannelConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelConnectionStatus | EnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChannelConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumChannelConnectionStatusFilter<$PrismaModel>
  }

  export type CapabilityTagCountOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    requiredProtocol?: SortOrder
    requiredSkills?: SortOrder
    requiredModels?: SortOrder
    requiresExtendedThinking?: SortOrder
    requiresCacheControl?: SortOrder
    requiresVision?: SortOrder
    maxCostPerMToken?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CapabilityTagAvgOrderByAggregateInput = {
    priority?: SortOrder
    maxCostPerMToken?: SortOrder
  }

  export type CapabilityTagMaxOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    requiredProtocol?: SortOrder
    requiresExtendedThinking?: SortOrder
    requiresCacheControl?: SortOrder
    requiresVision?: SortOrder
    maxCostPerMToken?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CapabilityTagMinOrderByAggregateInput = {
    id?: SortOrder
    tagId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    category?: SortOrder
    priority?: SortOrder
    requiredProtocol?: SortOrder
    requiresExtendedThinking?: SortOrder
    requiresCacheControl?: SortOrder
    requiresVision?: SortOrder
    maxCostPerMToken?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CapabilityTagSumOrderByAggregateInput = {
    priority?: SortOrder
    maxCostPerMToken?: SortOrder
  }

  export type FallbackChainCountOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    models?: SortOrder
    triggerStatusCodes?: SortOrder
    triggerErrorTypes?: SortOrder
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
    preserveProtocol?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FallbackChainAvgOrderByAggregateInput = {
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
  }

  export type FallbackChainMaxOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
    preserveProtocol?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FallbackChainMinOrderByAggregateInput = {
    id?: SortOrder
    chainId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
    preserveProtocol?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FallbackChainSumOrderByAggregateInput = {
    triggerTimeoutMs?: SortOrder
    maxRetries?: SortOrder
    retryDelayMs?: SortOrder
  }

  export type CostStrategyCountOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrder
    maxLatencyMs?: SortOrder
    minCapabilityScore?: SortOrder
    scenarioWeights?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CostStrategyAvgOrderByAggregateInput = {
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrder
    maxLatencyMs?: SortOrder
    minCapabilityScore?: SortOrder
  }

  export type CostStrategyMaxOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrder
    maxLatencyMs?: SortOrder
    minCapabilityScore?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CostStrategyMinOrderByAggregateInput = {
    id?: SortOrder
    strategyId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrder
    maxLatencyMs?: SortOrder
    minCapabilityScore?: SortOrder
    isActive?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CostStrategySumOrderByAggregateInput = {
    costWeight?: SortOrder
    performanceWeight?: SortOrder
    capabilityWeight?: SortOrder
    maxCostPerRequest?: SortOrder
    maxLatencyMs?: SortOrder
    minCapabilityScore?: SortOrder
  }

  export type BotRoutingConfigCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingEnabled?: SortOrder
    routingMode?: SortOrder
    fallbackEnabled?: SortOrder
    fallbackChainId?: SortOrder
    costControlEnabled?: SortOrder
    costStrategyId?: SortOrder
    dailyBudget?: SortOrder
    monthlyBudget?: SortOrder
    alertThreshold?: SortOrder
    autoDowngrade?: SortOrder
    downgradeModel?: SortOrder
    complexityRoutingEnabled?: SortOrder
    complexityRoutingConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotRoutingConfigAvgOrderByAggregateInput = {
    dailyBudget?: SortOrder
    monthlyBudget?: SortOrder
    alertThreshold?: SortOrder
  }

  export type BotRoutingConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingEnabled?: SortOrder
    routingMode?: SortOrder
    fallbackEnabled?: SortOrder
    fallbackChainId?: SortOrder
    costControlEnabled?: SortOrder
    costStrategyId?: SortOrder
    dailyBudget?: SortOrder
    monthlyBudget?: SortOrder
    alertThreshold?: SortOrder
    autoDowngrade?: SortOrder
    downgradeModel?: SortOrder
    complexityRoutingEnabled?: SortOrder
    complexityRoutingConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotRoutingConfigMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    routingEnabled?: SortOrder
    routingMode?: SortOrder
    fallbackEnabled?: SortOrder
    fallbackChainId?: SortOrder
    costControlEnabled?: SortOrder
    costStrategyId?: SortOrder
    dailyBudget?: SortOrder
    monthlyBudget?: SortOrder
    alertThreshold?: SortOrder
    autoDowngrade?: SortOrder
    downgradeModel?: SortOrder
    complexityRoutingEnabled?: SortOrder
    complexityRoutingConfigId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BotRoutingConfigSumOrderByAggregateInput = {
    dailyBudget?: SortOrder
    monthlyBudget?: SortOrder
    alertThreshold?: SortOrder
  }

  export type ComplexityRoutingConfigCountOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    models?: SortOrder
    classifierModel?: SortOrder
    classifierVendor?: SortOrder
    toolMinComplexity?: SortOrder
    isEnabled?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplexityRoutingConfigMaxOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    classifierModel?: SortOrder
    classifierVendor?: SortOrder
    toolMinComplexity?: SortOrder
    isEnabled?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ComplexityRoutingConfigMinOrderByAggregateInput = {
    id?: SortOrder
    configId?: SortOrder
    name?: SortOrder
    description?: SortOrder
    classifierModel?: SortOrder
    classifierVendor?: SortOrder
    toolMinComplexity?: SortOrder
    isEnabled?: SortOrder
    isBuiltin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileSourceCreateNestedOneWithoutUserAvatarsInput = {
    create?: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutUserAvatarsInput
    connect?: FileSourceWhereUniqueInput
  }

  export type WechatAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    connect?: WechatAuthWhereUniqueInput
  }

  export type GoogleAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    connect?: GoogleAuthWhereUniqueInput
  }

  export type DiscordAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    connect?: DiscordAuthWhereUniqueInput
  }

  export type MobileAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    connect?: MobileAuthWhereUniqueInput
  }

  export type EmailAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    connect?: EmailAuthWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageRecipientCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type BotCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type ProviderKeyCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
  }

  export type PersonaTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type OperateLogCreateNestedManyWithoutUserInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
  }

  export type WechatAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    connect?: WechatAuthWhereUniqueInput
  }

  export type GoogleAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    connect?: GoogleAuthWhereUniqueInput
  }

  export type DiscordAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    connect?: DiscordAuthWhereUniqueInput
  }

  export type MobileAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    connect?: MobileAuthWhereUniqueInput
  }

  export type EmailAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    connect?: EmailAuthWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageRecipientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
  }

  export type PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type OperateLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSexTypeFieldUpdateOperationsInput = {
    set?: $Enums.SexType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FileSourceUpdateOneWithoutUserAvatarsNestedInput = {
    create?: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutUserAvatarsInput
    upsert?: FileSourceUpsertWithoutUserAvatarsInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutUserAvatarsInput, FileSourceUpdateWithoutUserAvatarsInput>, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type WechatAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    upsert?: WechatAuthUpsertWithoutUserInput
    disconnect?: WechatAuthWhereInput | boolean
    delete?: WechatAuthWhereInput | boolean
    connect?: WechatAuthWhereUniqueInput
    update?: XOR<XOR<WechatAuthUpdateToOneWithWhereWithoutUserInput, WechatAuthUpdateWithoutUserInput>, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    upsert?: GoogleAuthUpsertWithoutUserInput
    disconnect?: GoogleAuthWhereInput | boolean
    delete?: GoogleAuthWhereInput | boolean
    connect?: GoogleAuthWhereUniqueInput
    update?: XOR<XOR<GoogleAuthUpdateToOneWithWhereWithoutUserInput, GoogleAuthUpdateWithoutUserInput>, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    upsert?: DiscordAuthUpsertWithoutUserInput
    disconnect?: DiscordAuthWhereInput | boolean
    delete?: DiscordAuthWhereInput | boolean
    connect?: DiscordAuthWhereUniqueInput
    update?: XOR<XOR<DiscordAuthUpdateToOneWithWhereWithoutUserInput, DiscordAuthUpdateWithoutUserInput>, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    upsert?: MobileAuthUpsertWithoutUserInput
    disconnect?: MobileAuthWhereInput | boolean
    delete?: MobileAuthWhereInput | boolean
    connect?: MobileAuthWhereUniqueInput
    update?: XOR<XOR<MobileAuthUpdateToOneWithWhereWithoutUserInput, MobileAuthUpdateWithoutUserInput>, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    upsert?: EmailAuthUpsertWithoutUserInput
    disconnect?: EmailAuthWhereInput | boolean
    delete?: EmailAuthWhereInput | boolean
    connect?: EmailAuthWhereUniqueInput
    update?: XOR<XOR<EmailAuthUpdateToOneWithWhereWithoutUserInput, EmailAuthUpdateWithoutUserInput>, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageRecipientUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutUserInput | MessageRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutUserInput | MessageRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutUserInput | MessageRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type BotUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutCreatedByInput | BotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutCreatedByInput | BotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BotUpdateManyWithWhereWithoutCreatedByInput | BotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type ProviderKeyUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    set?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    disconnect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    delete?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    update?: ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProviderKeyUpdateManyWithWhereWithoutCreatedByInput | ProviderKeyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
  }

  export type PersonaTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type OperateLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    upsert?: OperateLogUpsertWithWhereUniqueWithoutUserInput | OperateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    set?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    disconnect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    delete?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    update?: OperateLogUpdateWithWhereUniqueWithoutUserInput | OperateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperateLogUpdateManyWithWhereWithoutUserInput | OperateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
  }

  export type WechatAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    upsert?: WechatAuthUpsertWithoutUserInput
    disconnect?: WechatAuthWhereInput | boolean
    delete?: WechatAuthWhereInput | boolean
    connect?: WechatAuthWhereUniqueInput
    update?: XOR<XOR<WechatAuthUpdateToOneWithWhereWithoutUserInput, WechatAuthUpdateWithoutUserInput>, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    upsert?: GoogleAuthUpsertWithoutUserInput
    disconnect?: GoogleAuthWhereInput | boolean
    delete?: GoogleAuthWhereInput | boolean
    connect?: GoogleAuthWhereUniqueInput
    update?: XOR<XOR<GoogleAuthUpdateToOneWithWhereWithoutUserInput, GoogleAuthUpdateWithoutUserInput>, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    upsert?: DiscordAuthUpsertWithoutUserInput
    disconnect?: DiscordAuthWhereInput | boolean
    delete?: DiscordAuthWhereInput | boolean
    connect?: DiscordAuthWhereUniqueInput
    update?: XOR<XOR<DiscordAuthUpdateToOneWithWhereWithoutUserInput, DiscordAuthUpdateWithoutUserInput>, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    upsert?: MobileAuthUpsertWithoutUserInput
    disconnect?: MobileAuthWhereInput | boolean
    delete?: MobileAuthWhereInput | boolean
    connect?: MobileAuthWhereUniqueInput
    update?: XOR<XOR<MobileAuthUpdateToOneWithWhereWithoutUserInput, MobileAuthUpdateWithoutUserInput>, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    upsert?: EmailAuthUpsertWithoutUserInput
    disconnect?: EmailAuthWhereInput | boolean
    delete?: EmailAuthWhereInput | boolean
    connect?: EmailAuthWhereUniqueInput
    update?: XOR<XOR<EmailAuthUpdateToOneWithWhereWithoutUserInput, EmailAuthUpdateWithoutUserInput>, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageRecipientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutUserInput | MessageRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutUserInput | MessageRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutUserInput | MessageRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutCreatedByInput | BotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutCreatedByInput | BotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BotUpdateManyWithWhereWithoutCreatedByInput | BotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    set?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    disconnect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    delete?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    update?: ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProviderKeyUpdateManyWithWhereWithoutCreatedByInput | ProviderKeyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type OperateLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    upsert?: OperateLogUpsertWithWhereUniqueWithoutUserInput | OperateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    set?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    disconnect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    delete?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    update?: OperateLogUpdateWithWhereUniqueWithoutUserInput | OperateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperateLogUpdateManyWithWhereWithoutUserInput | OperateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
  }

  export type UserInfoCreateNestedOneWithoutPersonaTemplatesInput = {
    create?: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutPersonaTemplatesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type FileSourceCreateNestedOneWithoutPersonaTemplatesInput = {
    create?: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutPersonaTemplatesInput
    connect?: FileSourceWhereUniqueInput
  }

  export type BotCreateNestedManyWithoutPersonaTemplateInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutPersonaTemplateInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type UserInfoUpdateOneWithoutPersonaTemplatesNestedInput = {
    create?: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutPersonaTemplatesInput
    upsert?: UserInfoUpsertWithoutPersonaTemplatesInput
    disconnect?: UserInfoWhereInput | boolean
    delete?: UserInfoWhereInput | boolean
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutPersonaTemplatesInput, UserInfoUpdateWithoutPersonaTemplatesInput>, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type FileSourceUpdateOneWithoutPersonaTemplatesNestedInput = {
    create?: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutPersonaTemplatesInput
    upsert?: FileSourceUpsertWithoutPersonaTemplatesInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutPersonaTemplatesInput, FileSourceUpdateWithoutPersonaTemplatesInput>, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type BotUpdateManyWithoutPersonaTemplateNestedInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutPersonaTemplateInput | BotUpsertWithWhereUniqueWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutPersonaTemplateInput | BotUpdateWithWhereUniqueWithoutPersonaTemplateInput[]
    updateMany?: BotUpdateManyWithWhereWithoutPersonaTemplateInput | BotUpdateManyWithWhereWithoutPersonaTemplateInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutPersonaTemplateInput | BotUpsertWithWhereUniqueWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutPersonaTemplateInput | BotUpdateWithWhereUniqueWithoutPersonaTemplateInput[]
    updateMany?: BotUpdateManyWithWhereWithoutPersonaTemplateInput | BotUpdateManyWithWhereWithoutPersonaTemplateInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type UserInfoCreateNestedOneWithoutWechatAuthInput = {
    create?: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutWechatAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutWechatAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutWechatAuthInput
    upsert?: UserInfoUpsertWithoutWechatAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutWechatAuthInput, UserInfoUpdateWithoutWechatAuthInput>, UserInfoUncheckedUpdateWithoutWechatAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutGoogleAuthInput = {
    create?: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutGoogleAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserInfoUpdateOneRequiredWithoutGoogleAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutGoogleAuthInput
    upsert?: UserInfoUpsertWithoutGoogleAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutGoogleAuthInput, UserInfoUpdateWithoutGoogleAuthInput>, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutDiscordAuthInput = {
    create?: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutDiscordAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutDiscordAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutDiscordAuthInput
    upsert?: UserInfoUpsertWithoutDiscordAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutDiscordAuthInput, UserInfoUpdateWithoutDiscordAuthInput>, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutMobileAuthInput = {
    create?: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutMobileAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutMobileAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutMobileAuthInput
    upsert?: UserInfoUpsertWithoutMobileAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutMobileAuthInput, UserInfoUpdateWithoutMobileAuthInput>, UserInfoUncheckedUpdateWithoutMobileAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutEmailAuthInput = {
    create?: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutEmailAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutEmailAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutEmailAuthInput
    upsert?: UserInfoUpsertWithoutEmailAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutEmailAuthInput, UserInfoUpdateWithoutEmailAuthInput>, UserInfoUncheckedUpdateWithoutEmailAuthInput>
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type FileSourceCreatepartsInput = {
    set: number[]
  }

  export type UserInfoCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
  }

  export type PersonaTemplateCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type BotCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
  }

  export type PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FileSourceUpdatepartsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type EnumFileEnvTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileEnvType
  }

  export type EnumFileBucketVendorFieldUpdateOperationsInput = {
    set?: $Enums.FileBucketVendor
  }

  export type UserInfoUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    upsert?: UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput | UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    set?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    disconnect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    delete?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    update?: UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput | UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: UserInfoUpdateManyWithWhereWithoutAvatarFileInput | UserInfoUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
  }

  export type PersonaTemplateUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput | PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type BotUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutAvatarFileInput | BotUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutAvatarFileInput | BotUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: BotUpdateManyWithWhereWithoutAvatarFileInput | BotUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    upsert?: UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput | UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    set?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    disconnect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    delete?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    update?: UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput | UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: UserInfoUpdateManyWithWhereWithoutAvatarFileInput | UserInfoUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput | PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutAvatarFileInput | BotUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutAvatarFileInput | BotUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: BotUpdateManyWithWhereWithoutAvatarFileInput | BotUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type BotCreatetagsInput = {
    set: string[]
  }

  export type UserInfoCreateNestedOneWithoutBotsInput = {
    create?: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutBotsInput
    connect?: UserInfoWhereUniqueInput
  }

  export type PersonaTemplateCreateNestedOneWithoutBotsInput = {
    create?: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutBotsInput
    connect?: PersonaTemplateWhereUniqueInput
  }

  export type FileSourceCreateNestedOneWithoutBotAvatarsInput = {
    create?: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutBotAvatarsInput
    connect?: FileSourceWhereUniqueInput
  }

  export type BotProviderKeyCreateNestedManyWithoutBotInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogCreateNestedManyWithoutBotInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenCreateNestedOneWithoutBotInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    connect?: ProxyTokenWhereUniqueInput
  }

  export type BotPluginCreateNestedManyWithoutBotInput = {
    create?: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput> | BotPluginCreateWithoutBotInput[] | BotPluginUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutBotInput | BotPluginCreateOrConnectWithoutBotInput[]
    createMany?: BotPluginCreateManyBotInputEnvelope
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
  }

  export type BotSkillCreateNestedManyWithoutBotInput = {
    create?: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput> | BotSkillCreateWithoutBotInput[] | BotSkillUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutBotInput | BotSkillCreateOrConnectWithoutBotInput[]
    createMany?: BotSkillCreateManyBotInputEnvelope
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
  }

  export type BotChannelCreateNestedManyWithoutBotInput = {
    create?: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput> | BotChannelCreateWithoutBotInput[] | BotChannelUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotChannelCreateOrConnectWithoutBotInput | BotChannelCreateOrConnectWithoutBotInput[]
    createMany?: BotChannelCreateManyBotInputEnvelope
    connect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
  }

  export type BotModelRoutingCreateNestedManyWithoutBotInput = {
    create?: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput> | BotModelRoutingCreateWithoutBotInput[] | BotModelRoutingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotModelRoutingCreateOrConnectWithoutBotInput | BotModelRoutingCreateOrConnectWithoutBotInput[]
    createMany?: BotModelRoutingCreateManyBotInputEnvelope
    connect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
  }

  export type BotRoutingConfigCreateNestedOneWithoutBotInput = {
    create?: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
    connectOrCreate?: BotRoutingConfigCreateOrConnectWithoutBotInput
    connect?: BotRoutingConfigWhereUniqueInput
  }

  export type BotProviderKeyUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenUncheckedCreateNestedOneWithoutBotInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    connect?: ProxyTokenWhereUniqueInput
  }

  export type BotPluginUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput> | BotPluginCreateWithoutBotInput[] | BotPluginUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutBotInput | BotPluginCreateOrConnectWithoutBotInput[]
    createMany?: BotPluginCreateManyBotInputEnvelope
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
  }

  export type BotSkillUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput> | BotSkillCreateWithoutBotInput[] | BotSkillUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutBotInput | BotSkillCreateOrConnectWithoutBotInput[]
    createMany?: BotSkillCreateManyBotInputEnvelope
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
  }

  export type BotChannelUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput> | BotChannelCreateWithoutBotInput[] | BotChannelUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotChannelCreateOrConnectWithoutBotInput | BotChannelCreateOrConnectWithoutBotInput[]
    createMany?: BotChannelCreateManyBotInputEnvelope
    connect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
  }

  export type BotModelRoutingUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput> | BotModelRoutingCreateWithoutBotInput[] | BotModelRoutingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotModelRoutingCreateOrConnectWithoutBotInput | BotModelRoutingCreateOrConnectWithoutBotInput[]
    createMany?: BotModelRoutingCreateManyBotInputEnvelope
    connect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
  }

  export type BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput = {
    create?: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
    connectOrCreate?: BotRoutingConfigCreateOrConnectWithoutBotInput
    connect?: BotRoutingConfigWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BotUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumBotStatusFieldUpdateOperationsInput = {
    set?: $Enums.BotStatus
  }

  export type EnumHealthStatusFieldUpdateOperationsInput = {
    set?: $Enums.HealthStatus
  }

  export type UserInfoUpdateOneRequiredWithoutBotsNestedInput = {
    create?: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutBotsInput
    upsert?: UserInfoUpsertWithoutBotsInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutBotsInput, UserInfoUpdateWithoutBotsInput>, UserInfoUncheckedUpdateWithoutBotsInput>
  }

  export type PersonaTemplateUpdateOneWithoutBotsNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutBotsInput
    upsert?: PersonaTemplateUpsertWithoutBotsInput
    disconnect?: PersonaTemplateWhereInput | boolean
    delete?: PersonaTemplateWhereInput | boolean
    connect?: PersonaTemplateWhereUniqueInput
    update?: XOR<XOR<PersonaTemplateUpdateToOneWithWhereWithoutBotsInput, PersonaTemplateUpdateWithoutBotsInput>, PersonaTemplateUncheckedUpdateWithoutBotsInput>
  }

  export type FileSourceUpdateOneWithoutBotAvatarsNestedInput = {
    create?: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutBotAvatarsInput
    upsert?: FileSourceUpsertWithoutBotAvatarsInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutBotAvatarsInput, FileSourceUpdateWithoutBotAvatarsInput>, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
  }

  export type BotProviderKeyUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutBotInput | BotProviderKeyUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutBotInput | BotProviderKeyUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutBotInput | BotProviderKeyUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutBotInput | BotUsageLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutBotInput | BotUsageLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutBotInput | BotUsageLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUpdateOneWithoutBotNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    upsert?: ProxyTokenUpsertWithoutBotInput
    disconnect?: ProxyTokenWhereInput | boolean
    delete?: ProxyTokenWhereInput | boolean
    connect?: ProxyTokenWhereUniqueInput
    update?: XOR<XOR<ProxyTokenUpdateToOneWithWhereWithoutBotInput, ProxyTokenUpdateWithoutBotInput>, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type BotPluginUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput> | BotPluginCreateWithoutBotInput[] | BotPluginUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutBotInput | BotPluginCreateOrConnectWithoutBotInput[]
    upsert?: BotPluginUpsertWithWhereUniqueWithoutBotInput | BotPluginUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotPluginCreateManyBotInputEnvelope
    set?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    disconnect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    delete?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    update?: BotPluginUpdateWithWhereUniqueWithoutBotInput | BotPluginUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotPluginUpdateManyWithWhereWithoutBotInput | BotPluginUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
  }

  export type BotSkillUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput> | BotSkillCreateWithoutBotInput[] | BotSkillUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutBotInput | BotSkillCreateOrConnectWithoutBotInput[]
    upsert?: BotSkillUpsertWithWhereUniqueWithoutBotInput | BotSkillUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotSkillCreateManyBotInputEnvelope
    set?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    disconnect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    delete?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    update?: BotSkillUpdateWithWhereUniqueWithoutBotInput | BotSkillUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotSkillUpdateManyWithWhereWithoutBotInput | BotSkillUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
  }

  export type BotChannelUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput> | BotChannelCreateWithoutBotInput[] | BotChannelUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotChannelCreateOrConnectWithoutBotInput | BotChannelCreateOrConnectWithoutBotInput[]
    upsert?: BotChannelUpsertWithWhereUniqueWithoutBotInput | BotChannelUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotChannelCreateManyBotInputEnvelope
    set?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    disconnect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    delete?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    connect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    update?: BotChannelUpdateWithWhereUniqueWithoutBotInput | BotChannelUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotChannelUpdateManyWithWhereWithoutBotInput | BotChannelUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotChannelScalarWhereInput | BotChannelScalarWhereInput[]
  }

  export type BotModelRoutingUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput> | BotModelRoutingCreateWithoutBotInput[] | BotModelRoutingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotModelRoutingCreateOrConnectWithoutBotInput | BotModelRoutingCreateOrConnectWithoutBotInput[]
    upsert?: BotModelRoutingUpsertWithWhereUniqueWithoutBotInput | BotModelRoutingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotModelRoutingCreateManyBotInputEnvelope
    set?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    disconnect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    delete?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    connect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    update?: BotModelRoutingUpdateWithWhereUniqueWithoutBotInput | BotModelRoutingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotModelRoutingUpdateManyWithWhereWithoutBotInput | BotModelRoutingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotModelRoutingScalarWhereInput | BotModelRoutingScalarWhereInput[]
  }

  export type BotRoutingConfigUpdateOneWithoutBotNestedInput = {
    create?: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
    connectOrCreate?: BotRoutingConfigCreateOrConnectWithoutBotInput
    upsert?: BotRoutingConfigUpsertWithoutBotInput
    disconnect?: BotRoutingConfigWhereInput | boolean
    delete?: BotRoutingConfigWhereInput | boolean
    connect?: BotRoutingConfigWhereUniqueInput
    update?: XOR<XOR<BotRoutingConfigUpdateToOneWithWhereWithoutBotInput, BotRoutingConfigUpdateWithoutBotInput>, BotRoutingConfigUncheckedUpdateWithoutBotInput>
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutBotInput | BotProviderKeyUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutBotInput | BotProviderKeyUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutBotInput | BotProviderKeyUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutBotInput | BotUsageLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutBotInput | BotUsageLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutBotInput | BotUsageLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUncheckedUpdateOneWithoutBotNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    upsert?: ProxyTokenUpsertWithoutBotInput
    disconnect?: ProxyTokenWhereInput | boolean
    delete?: ProxyTokenWhereInput | boolean
    connect?: ProxyTokenWhereUniqueInput
    update?: XOR<XOR<ProxyTokenUpdateToOneWithWhereWithoutBotInput, ProxyTokenUpdateWithoutBotInput>, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type BotPluginUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput> | BotPluginCreateWithoutBotInput[] | BotPluginUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutBotInput | BotPluginCreateOrConnectWithoutBotInput[]
    upsert?: BotPluginUpsertWithWhereUniqueWithoutBotInput | BotPluginUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotPluginCreateManyBotInputEnvelope
    set?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    disconnect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    delete?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    update?: BotPluginUpdateWithWhereUniqueWithoutBotInput | BotPluginUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotPluginUpdateManyWithWhereWithoutBotInput | BotPluginUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
  }

  export type BotSkillUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput> | BotSkillCreateWithoutBotInput[] | BotSkillUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutBotInput | BotSkillCreateOrConnectWithoutBotInput[]
    upsert?: BotSkillUpsertWithWhereUniqueWithoutBotInput | BotSkillUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotSkillCreateManyBotInputEnvelope
    set?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    disconnect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    delete?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    update?: BotSkillUpdateWithWhereUniqueWithoutBotInput | BotSkillUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotSkillUpdateManyWithWhereWithoutBotInput | BotSkillUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
  }

  export type BotChannelUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput> | BotChannelCreateWithoutBotInput[] | BotChannelUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotChannelCreateOrConnectWithoutBotInput | BotChannelCreateOrConnectWithoutBotInput[]
    upsert?: BotChannelUpsertWithWhereUniqueWithoutBotInput | BotChannelUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotChannelCreateManyBotInputEnvelope
    set?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    disconnect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    delete?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    connect?: BotChannelWhereUniqueInput | BotChannelWhereUniqueInput[]
    update?: BotChannelUpdateWithWhereUniqueWithoutBotInput | BotChannelUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotChannelUpdateManyWithWhereWithoutBotInput | BotChannelUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotChannelScalarWhereInput | BotChannelScalarWhereInput[]
  }

  export type BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput> | BotModelRoutingCreateWithoutBotInput[] | BotModelRoutingUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotModelRoutingCreateOrConnectWithoutBotInput | BotModelRoutingCreateOrConnectWithoutBotInput[]
    upsert?: BotModelRoutingUpsertWithWhereUniqueWithoutBotInput | BotModelRoutingUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotModelRoutingCreateManyBotInputEnvelope
    set?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    disconnect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    delete?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    connect?: BotModelRoutingWhereUniqueInput | BotModelRoutingWhereUniqueInput[]
    update?: BotModelRoutingUpdateWithWhereUniqueWithoutBotInput | BotModelRoutingUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotModelRoutingUpdateManyWithWhereWithoutBotInput | BotModelRoutingUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotModelRoutingScalarWhereInput | BotModelRoutingScalarWhereInput[]
  }

  export type BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput = {
    create?: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
    connectOrCreate?: BotRoutingConfigCreateOrConnectWithoutBotInput
    upsert?: BotRoutingConfigUpsertWithoutBotInput
    disconnect?: BotRoutingConfigWhereInput | boolean
    delete?: BotRoutingConfigWhereInput | boolean
    connect?: BotRoutingConfigWhereUniqueInput
    update?: XOR<XOR<BotRoutingConfigUpdateToOneWithWhereWithoutBotInput, BotRoutingConfigUpdateWithoutBotInput>, BotRoutingConfigUncheckedUpdateWithoutBotInput>
  }

  export type UserInfoCreateNestedOneWithoutProviderKeysInput = {
    create?: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutProviderKeysInput
    connect?: UserInfoWhereUniqueInput
  }

  export type BotProviderKeyCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
  }

  export type BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput = {
    create?: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutProviderKeysInput
    upsert?: UserInfoUpsertWithoutProviderKeysInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutProviderKeysInput, UserInfoUpdateWithoutProviderKeysInput>, UserInfoUncheckedUpdateWithoutProviderKeysInput>
  }

  export type BotProviderKeyUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput | BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput | BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    upsert?: ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    set?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    disconnect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    delete?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    update?: ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput | ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput | BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput | BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    upsert?: ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    set?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    disconnect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    delete?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    update?: ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput | ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
  }

  export type BotProviderKeyCreateallowedModelsInput = {
    set: string[]
  }

  export type BotCreateNestedOneWithoutProviderKeysInput = {
    create?: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: BotCreateOrConnectWithoutProviderKeysInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutBotProviderKeysInput = {
    create?: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutBotProviderKeysInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type BotProviderKeyUpdateallowedModelsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BotUpdateOneRequiredWithoutProviderKeysNestedInput = {
    create?: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: BotCreateOrConnectWithoutProviderKeysInput
    upsert?: BotUpsertWithoutProviderKeysInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutProviderKeysInput, BotUpdateWithoutProviderKeysInput>, BotUncheckedUpdateWithoutProviderKeysInput>
  }

  export type ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutBotProviderKeysInput
    upsert?: ProviderKeyUpsertWithoutBotProviderKeysInput
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutBotProviderKeysInput, ProviderKeyUpdateWithoutBotProviderKeysInput>, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
  }

  export type BotCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUsageLogsInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutUsageLogsInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type BotUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUsageLogsInput
    upsert?: BotUpsertWithoutUsageLogsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutUsageLogsInput, BotUpdateWithoutUsageLogsInput>, BotUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProviderKeyUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutUsageLogsInput
    upsert?: ProviderKeyUpsertWithoutUsageLogsInput
    disconnect?: ProviderKeyWhereInput | boolean
    delete?: ProviderKeyWhereInput | boolean
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutUsageLogsInput, ProviderKeyUpdateWithoutUsageLogsInput>, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProxyTokenCreatetagsInput = {
    set: string[]
  }

  export type BotCreateNestedOneWithoutProxyTokenInput = {
    create?: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    connectOrCreate?: BotCreateOrConnectWithoutProxyTokenInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutProxyTokensInput = {
    create?: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutProxyTokensInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type ProxyTokenUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BotUpdateOneRequiredWithoutProxyTokenNestedInput = {
    create?: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    connectOrCreate?: BotCreateOrConnectWithoutProxyTokenInput
    upsert?: BotUpsertWithoutProxyTokenInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutProxyTokenInput, BotUpdateWithoutProxyTokenInput>, BotUncheckedUpdateWithoutProxyTokenInput>
  }

  export type ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutProxyTokensInput
    upsert?: ProviderKeyUpsertWithoutProxyTokensInput
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutProxyTokensInput, ProviderKeyUpdateWithoutProxyTokensInput>, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
  }

  export type UserInfoCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutSentMessagesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type MessageRecipientCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type MessageRecipientUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type UserInfoUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutSentMessagesInput
    upsert?: UserInfoUpsertWithoutSentMessagesInput
    disconnect?: UserInfoWhereInput | boolean
    delete?: UserInfoWhereInput | boolean
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutSentMessagesInput, UserInfoUpdateWithoutSentMessagesInput>, UserInfoUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MessageRecipientUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutMessageInput | MessageRecipientUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutMessageInput | MessageRecipientUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutMessageInput | MessageRecipientUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutMessageInput | MessageRecipientUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutMessageInput | MessageRecipientUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutMessageInput | MessageRecipientUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserInfoCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    upsert?: MessageUpsertWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRecipientsInput, MessageUpdateWithoutRecipientsInput>, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserInfoUpsertWithoutReceivedMessagesInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutReceivedMessagesInput, UserInfoUpdateWithoutReceivedMessagesInput>, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserInfoCreateNestedOneWithoutOperateLogsInput = {
    create?: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutOperateLogsInput
    connect?: UserInfoWhereUniqueInput
  }

  export type EnumOperateTypeFieldUpdateOperationsInput = {
    set?: $Enums.OperateType
  }

  export type EnumOperateTargetFieldUpdateOperationsInput = {
    set?: $Enums.OperateTarget
  }

  export type UserInfoUpdateOneRequiredWithoutOperateLogsNestedInput = {
    create?: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutOperateLogsInput
    upsert?: UserInfoUpsertWithoutOperateLogsInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutOperateLogsInput, UserInfoUpdateWithoutOperateLogsInput>, UserInfoUncheckedUpdateWithoutOperateLogsInput>
  }

  export type ChannelDefinitionCreatepopularLocalesInput = {
    set: string[]
  }

  export type ChannelCredentialFieldCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
  }

  export type ChannelCredentialFieldUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
  }

  export type ChannelDefinitionUpdatepopularLocalesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type ChannelCredentialFieldUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    set?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    disconnect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    delete?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    update?: ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput | ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
  }

  export type ChannelCredentialFieldUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    set?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    disconnect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    delete?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    update?: ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput | ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
  }

  export type ChannelDefinitionCreateNestedOneWithoutCredentialFieldsInput = {
    create?: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    connectOrCreate?: ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput
    connect?: ChannelDefinitionWhereUniqueInput
  }

  export type ChannelDefinitionUpdateOneRequiredWithoutCredentialFieldsNestedInput = {
    create?: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    connectOrCreate?: ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput
    upsert?: ChannelDefinitionUpsertWithoutCredentialFieldsInput
    connect?: ChannelDefinitionWhereUniqueInput
    update?: XOR<XOR<ChannelDefinitionUpdateToOneWithWhereWithoutCredentialFieldsInput, ChannelDefinitionUpdateWithoutCredentialFieldsInput>, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
  }

  export type BotPluginCreateNestedManyWithoutPluginInput = {
    create?: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput> | BotPluginCreateWithoutPluginInput[] | BotPluginUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutPluginInput | BotPluginCreateOrConnectWithoutPluginInput[]
    createMany?: BotPluginCreateManyPluginInputEnvelope
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
  }

  export type BotPluginUncheckedCreateNestedManyWithoutPluginInput = {
    create?: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput> | BotPluginCreateWithoutPluginInput[] | BotPluginUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutPluginInput | BotPluginCreateOrConnectWithoutPluginInput[]
    createMany?: BotPluginCreateManyPluginInputEnvelope
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
  }

  export type EnumPluginCategoryFieldUpdateOperationsInput = {
    set?: $Enums.PluginCategory
  }

  export type BotPluginUpdateManyWithoutPluginNestedInput = {
    create?: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput> | BotPluginCreateWithoutPluginInput[] | BotPluginUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutPluginInput | BotPluginCreateOrConnectWithoutPluginInput[]
    upsert?: BotPluginUpsertWithWhereUniqueWithoutPluginInput | BotPluginUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: BotPluginCreateManyPluginInputEnvelope
    set?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    disconnect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    delete?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    update?: BotPluginUpdateWithWhereUniqueWithoutPluginInput | BotPluginUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: BotPluginUpdateManyWithWhereWithoutPluginInput | BotPluginUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
  }

  export type BotPluginUncheckedUpdateManyWithoutPluginNestedInput = {
    create?: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput> | BotPluginCreateWithoutPluginInput[] | BotPluginUncheckedCreateWithoutPluginInput[]
    connectOrCreate?: BotPluginCreateOrConnectWithoutPluginInput | BotPluginCreateOrConnectWithoutPluginInput[]
    upsert?: BotPluginUpsertWithWhereUniqueWithoutPluginInput | BotPluginUpsertWithWhereUniqueWithoutPluginInput[]
    createMany?: BotPluginCreateManyPluginInputEnvelope
    set?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    disconnect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    delete?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    connect?: BotPluginWhereUniqueInput | BotPluginWhereUniqueInput[]
    update?: BotPluginUpdateWithWhereUniqueWithoutPluginInput | BotPluginUpdateWithWhereUniqueWithoutPluginInput[]
    updateMany?: BotPluginUpdateManyWithWhereWithoutPluginInput | BotPluginUpdateManyWithWhereWithoutPluginInput[]
    deleteMany?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
  }

  export type BotCreateNestedOneWithoutPluginsInput = {
    create?: XOR<BotCreateWithoutPluginsInput, BotUncheckedCreateWithoutPluginsInput>
    connectOrCreate?: BotCreateOrConnectWithoutPluginsInput
    connect?: BotWhereUniqueInput
  }

  export type PluginCreateNestedOneWithoutInstallationsInput = {
    create?: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutInstallationsInput
    connect?: PluginWhereUniqueInput
  }

  export type BotUpdateOneRequiredWithoutPluginsNestedInput = {
    create?: XOR<BotCreateWithoutPluginsInput, BotUncheckedCreateWithoutPluginsInput>
    connectOrCreate?: BotCreateOrConnectWithoutPluginsInput
    upsert?: BotUpsertWithoutPluginsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutPluginsInput, BotUpdateWithoutPluginsInput>, BotUncheckedUpdateWithoutPluginsInput>
  }

  export type PluginUpdateOneRequiredWithoutInstallationsNestedInput = {
    create?: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: PluginCreateOrConnectWithoutInstallationsInput
    upsert?: PluginUpsertWithoutInstallationsInput
    connect?: PluginWhereUniqueInput
    update?: XOR<XOR<PluginUpdateToOneWithWhereWithoutInstallationsInput, PluginUpdateWithoutInstallationsInput>, PluginUncheckedUpdateWithoutInstallationsInput>
  }

  export type SkillCreateNestedManyWithoutSkillTypeInput = {
    create?: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput> | SkillCreateWithoutSkillTypeInput[] | SkillUncheckedCreateWithoutSkillTypeInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSkillTypeInput | SkillCreateOrConnectWithoutSkillTypeInput[]
    createMany?: SkillCreateManySkillTypeInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SkillUncheckedCreateNestedManyWithoutSkillTypeInput = {
    create?: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput> | SkillCreateWithoutSkillTypeInput[] | SkillUncheckedCreateWithoutSkillTypeInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSkillTypeInput | SkillCreateOrConnectWithoutSkillTypeInput[]
    createMany?: SkillCreateManySkillTypeInputEnvelope
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
  }

  export type SkillUpdateManyWithoutSkillTypeNestedInput = {
    create?: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput> | SkillCreateWithoutSkillTypeInput[] | SkillUncheckedCreateWithoutSkillTypeInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSkillTypeInput | SkillCreateOrConnectWithoutSkillTypeInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutSkillTypeInput | SkillUpsertWithWhereUniqueWithoutSkillTypeInput[]
    createMany?: SkillCreateManySkillTypeInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutSkillTypeInput | SkillUpdateWithWhereUniqueWithoutSkillTypeInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutSkillTypeInput | SkillUpdateManyWithWhereWithoutSkillTypeInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SkillUncheckedUpdateManyWithoutSkillTypeNestedInput = {
    create?: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput> | SkillCreateWithoutSkillTypeInput[] | SkillUncheckedCreateWithoutSkillTypeInput[]
    connectOrCreate?: SkillCreateOrConnectWithoutSkillTypeInput | SkillCreateOrConnectWithoutSkillTypeInput[]
    upsert?: SkillUpsertWithWhereUniqueWithoutSkillTypeInput | SkillUpsertWithWhereUniqueWithoutSkillTypeInput[]
    createMany?: SkillCreateManySkillTypeInputEnvelope
    set?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    disconnect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    delete?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    connect?: SkillWhereUniqueInput | SkillWhereUniqueInput[]
    update?: SkillUpdateWithWhereUniqueWithoutSkillTypeInput | SkillUpdateWithWhereUniqueWithoutSkillTypeInput[]
    updateMany?: SkillUpdateManyWithWhereWithoutSkillTypeInput | SkillUpdateManyWithWhereWithoutSkillTypeInput[]
    deleteMany?: SkillScalarWhereInput | SkillScalarWhereInput[]
  }

  export type SkillTypeCreateNestedOneWithoutSkillsInput = {
    create?: XOR<SkillTypeCreateWithoutSkillsInput, SkillTypeUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: SkillTypeCreateOrConnectWithoutSkillsInput
    connect?: SkillTypeWhereUniqueInput
  }

  export type BotSkillCreateNestedManyWithoutSkillInput = {
    create?: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput> | BotSkillCreateWithoutSkillInput[] | BotSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutSkillInput | BotSkillCreateOrConnectWithoutSkillInput[]
    createMany?: BotSkillCreateManySkillInputEnvelope
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
  }

  export type BotSkillUncheckedCreateNestedManyWithoutSkillInput = {
    create?: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput> | BotSkillCreateWithoutSkillInput[] | BotSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutSkillInput | BotSkillCreateOrConnectWithoutSkillInput[]
    createMany?: BotSkillCreateManySkillInputEnvelope
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
  }

  export type SkillTypeUpdateOneWithoutSkillsNestedInput = {
    create?: XOR<SkillTypeCreateWithoutSkillsInput, SkillTypeUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: SkillTypeCreateOrConnectWithoutSkillsInput
    upsert?: SkillTypeUpsertWithoutSkillsInput
    disconnect?: SkillTypeWhereInput | boolean
    delete?: SkillTypeWhereInput | boolean
    connect?: SkillTypeWhereUniqueInput
    update?: XOR<XOR<SkillTypeUpdateToOneWithWhereWithoutSkillsInput, SkillTypeUpdateWithoutSkillsInput>, SkillTypeUncheckedUpdateWithoutSkillsInput>
  }

  export type BotSkillUpdateManyWithoutSkillNestedInput = {
    create?: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput> | BotSkillCreateWithoutSkillInput[] | BotSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutSkillInput | BotSkillCreateOrConnectWithoutSkillInput[]
    upsert?: BotSkillUpsertWithWhereUniqueWithoutSkillInput | BotSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: BotSkillCreateManySkillInputEnvelope
    set?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    disconnect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    delete?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    update?: BotSkillUpdateWithWhereUniqueWithoutSkillInput | BotSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: BotSkillUpdateManyWithWhereWithoutSkillInput | BotSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
  }

  export type BotSkillUncheckedUpdateManyWithoutSkillNestedInput = {
    create?: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput> | BotSkillCreateWithoutSkillInput[] | BotSkillUncheckedCreateWithoutSkillInput[]
    connectOrCreate?: BotSkillCreateOrConnectWithoutSkillInput | BotSkillCreateOrConnectWithoutSkillInput[]
    upsert?: BotSkillUpsertWithWhereUniqueWithoutSkillInput | BotSkillUpsertWithWhereUniqueWithoutSkillInput[]
    createMany?: BotSkillCreateManySkillInputEnvelope
    set?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    disconnect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    delete?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    connect?: BotSkillWhereUniqueInput | BotSkillWhereUniqueInput[]
    update?: BotSkillUpdateWithWhereUniqueWithoutSkillInput | BotSkillUpdateWithWhereUniqueWithoutSkillInput[]
    updateMany?: BotSkillUpdateManyWithWhereWithoutSkillInput | BotSkillUpdateManyWithWhereWithoutSkillInput[]
    deleteMany?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
  }

  export type BotCreateNestedOneWithoutSkillsInput = {
    create?: XOR<BotCreateWithoutSkillsInput, BotUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: BotCreateOrConnectWithoutSkillsInput
    connect?: BotWhereUniqueInput
  }

  export type SkillCreateNestedOneWithoutInstallationsInput = {
    create?: XOR<SkillCreateWithoutInstallationsInput, SkillUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutInstallationsInput
    connect?: SkillWhereUniqueInput
  }

  export type BotUpdateOneRequiredWithoutSkillsNestedInput = {
    create?: XOR<BotCreateWithoutSkillsInput, BotUncheckedCreateWithoutSkillsInput>
    connectOrCreate?: BotCreateOrConnectWithoutSkillsInput
    upsert?: BotUpsertWithoutSkillsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutSkillsInput, BotUpdateWithoutSkillsInput>, BotUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillUpdateOneRequiredWithoutInstallationsNestedInput = {
    create?: XOR<SkillCreateWithoutInstallationsInput, SkillUncheckedCreateWithoutInstallationsInput>
    connectOrCreate?: SkillCreateOrConnectWithoutInstallationsInput
    upsert?: SkillUpsertWithoutInstallationsInput
    connect?: SkillWhereUniqueInput
    update?: XOR<XOR<SkillUpdateToOneWithWhereWithoutInstallationsInput, SkillUpdateWithoutInstallationsInput>, SkillUncheckedUpdateWithoutInstallationsInput>
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type BotCreateNestedOneWithoutModelRoutingsInput = {
    create?: XOR<BotCreateWithoutModelRoutingsInput, BotUncheckedCreateWithoutModelRoutingsInput>
    connectOrCreate?: BotCreateOrConnectWithoutModelRoutingsInput
    connect?: BotWhereUniqueInput
  }

  export type EnumModelRoutingTypeFieldUpdateOperationsInput = {
    set?: $Enums.ModelRoutingType
  }

  export type BotUpdateOneRequiredWithoutModelRoutingsNestedInput = {
    create?: XOR<BotCreateWithoutModelRoutingsInput, BotUncheckedCreateWithoutModelRoutingsInput>
    connectOrCreate?: BotCreateOrConnectWithoutModelRoutingsInput
    upsert?: BotUpsertWithoutModelRoutingsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutModelRoutingsInput, BotUpdateWithoutModelRoutingsInput>, BotUncheckedUpdateWithoutModelRoutingsInput>
  }

  export type BotCreateNestedOneWithoutChannelsInput = {
    create?: XOR<BotCreateWithoutChannelsInput, BotUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: BotCreateOrConnectWithoutChannelsInput
    connect?: BotWhereUniqueInput
  }

  export type EnumChannelConnectionStatusFieldUpdateOperationsInput = {
    set?: $Enums.ChannelConnectionStatus
  }

  export type BotUpdateOneRequiredWithoutChannelsNestedInput = {
    create?: XOR<BotCreateWithoutChannelsInput, BotUncheckedCreateWithoutChannelsInput>
    connectOrCreate?: BotCreateOrConnectWithoutChannelsInput
    upsert?: BotUpsertWithoutChannelsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutChannelsInput, BotUpdateWithoutChannelsInput>, BotUncheckedUpdateWithoutChannelsInput>
  }

  export type BotCreateNestedOneWithoutRoutingConfigInput = {
    create?: XOR<BotCreateWithoutRoutingConfigInput, BotUncheckedCreateWithoutRoutingConfigInput>
    connectOrCreate?: BotCreateOrConnectWithoutRoutingConfigInput
    connect?: BotWhereUniqueInput
  }

  export type BotUpdateOneRequiredWithoutRoutingConfigNestedInput = {
    create?: XOR<BotCreateWithoutRoutingConfigInput, BotUncheckedCreateWithoutRoutingConfigInput>
    connectOrCreate?: BotCreateOrConnectWithoutRoutingConfigInput
    upsert?: BotUpsertWithoutRoutingConfigInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutRoutingConfigInput, BotUpdateWithoutRoutingConfigInput>, BotUncheckedUpdateWithoutRoutingConfigInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeFilter<$PrismaModel> | $Enums.SexType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeWithAggregatesFilter<$PrismaModel> | $Enums.SexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexTypeFilter<$PrismaModel>
    _max?: NestedEnumSexTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileEnvTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeFilter<$PrismaModel> | $Enums.FileEnvType
  }

  export type NestedEnumFileBucketVendorFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorFilter<$PrismaModel> | $Enums.FileBucketVendor
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileEnvType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileEnvTypeFilter<$PrismaModel>
    _max?: NestedEnumFileEnvTypeFilter<$PrismaModel>
  }

  export type NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel> | $Enums.FileBucketVendor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileBucketVendorFilter<$PrismaModel>
    _max?: NestedEnumFileBucketVendorFilter<$PrismaModel>
  }

  export type NestedEnumBotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusFilter<$PrismaModel> | $Enums.BotStatus
  }

  export type NestedEnumHealthStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthStatusFilter<$PrismaModel> | $Enums.HealthStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusWithAggregatesFilter<$PrismaModel> | $Enums.BotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotStatusFilter<$PrismaModel>
    _max?: NestedEnumBotStatusFilter<$PrismaModel>
  }

  export type NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HealthStatus | EnumHealthStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HealthStatus[] | ListEnumHealthStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHealthStatusWithAggregatesFilter<$PrismaModel> | $Enums.HealthStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHealthStatusFilter<$PrismaModel>
    _max?: NestedEnumHealthStatusFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOperateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeFilter<$PrismaModel> | $Enums.OperateType
  }

  export type NestedEnumOperateTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetFilter<$PrismaModel> | $Enums.OperateTarget
  }

  export type NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTypeFilter<$PrismaModel>
    _max?: NestedEnumOperateTypeFilter<$PrismaModel>
  }

  export type NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel> | $Enums.OperateTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTargetFilter<$PrismaModel>
    _max?: NestedEnumOperateTargetFilter<$PrismaModel>
  }

  export type NestedEnumPluginCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryFilter<$PrismaModel> | $Enums.PluginCategory
  }

  export type NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PluginCategory | EnumPluginCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.PluginCategory[] | ListEnumPluginCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumPluginCategoryWithAggregatesFilter<$PrismaModel> | $Enums.PluginCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPluginCategoryFilter<$PrismaModel>
    _max?: NestedEnumPluginCategoryFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumModelRoutingTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelRoutingType | EnumModelRoutingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModelRoutingTypeFilter<$PrismaModel> | $Enums.ModelRoutingType
  }

  export type NestedEnumModelRoutingTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ModelRoutingType | EnumModelRoutingTypeFieldRefInput<$PrismaModel>
    in?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.ModelRoutingType[] | ListEnumModelRoutingTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumModelRoutingTypeWithAggregatesFilter<$PrismaModel> | $Enums.ModelRoutingType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumModelRoutingTypeFilter<$PrismaModel>
    _max?: NestedEnumModelRoutingTypeFilter<$PrismaModel>
  }

  export type NestedEnumChannelConnectionStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelConnectionStatus | EnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelConnectionStatusFilter<$PrismaModel> | $Enums.ChannelConnectionStatus
  }

  export type NestedEnumChannelConnectionStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ChannelConnectionStatus | EnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ChannelConnectionStatus[] | ListEnumChannelConnectionStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumChannelConnectionStatusWithAggregatesFilter<$PrismaModel> | $Enums.ChannelConnectionStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumChannelConnectionStatusFilter<$PrismaModel>
    _max?: NestedEnumChannelConnectionStatusFilter<$PrismaModel>
  }

  export type FileSourceCreateWithoutUserAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutUserAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutUserAvatarsInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
  }

  export type WechatAuthCreateWithoutUserInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUncheckedCreateWithoutUserInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthCreateOrConnectWithoutUserInput = {
    where: WechatAuthWhereUniqueInput
    create: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
  }

  export type GoogleAuthCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUncheckedCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthCreateOrConnectWithoutUserInput = {
    where: GoogleAuthWhereUniqueInput
    create: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
  }

  export type DiscordAuthCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUncheckedCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthCreateOrConnectWithoutUserInput = {
    where: DiscordAuthWhereUniqueInput
    create: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
  }

  export type MobileAuthCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUncheckedCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthCreateOrConnectWithoutUserInput = {
    where: MobileAuthWhereUniqueInput
    create: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
  }

  export type EmailAuthCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUncheckedCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthCreateOrConnectWithoutUserInput = {
    where: EmailAuthWhereUniqueInput
    create: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageRecipientCreateWithoutUserInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutRecipientsInput
  }

  export type MessageRecipientUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateOrConnectWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    create: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput>
  }

  export type MessageRecipientCreateManyUserInputEnvelope = {
    data: MessageRecipientCreateManyUserInput | MessageRecipientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BotCreateWithoutCreatedByInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput>
  }

  export type BotCreateManyCreatedByInputEnvelope = {
    data: BotCreateManyCreatedByInput | BotCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProviderKeyCreateWithoutCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput>
  }

  export type ProviderKeyCreateManyCreatedByInputEnvelope = {
    data: ProviderKeyCreateManyCreatedByInput | ProviderKeyCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PersonaTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateCreateOrConnectWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type PersonaTemplateCreateManyCreatedByInputEnvelope = {
    data: PersonaTemplateCreateManyCreatedByInput | PersonaTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OperateLogCreateWithoutUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUncheckedCreateWithoutUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogCreateOrConnectWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    create: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput>
  }

  export type OperateLogCreateManyUserInputEnvelope = {
    data: OperateLogCreateManyUserInput | OperateLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileSourceUpsertWithoutUserAvatarsInput = {
    update: XOR<FileSourceUpdateWithoutUserAvatarsInput, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
    create: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutUserAvatarsInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutUserAvatarsInput, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type FileSourceUpdateWithoutUserAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutUserAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type WechatAuthUpsertWithoutUserInput = {
    update: XOR<WechatAuthUpdateWithoutUserInput, WechatAuthUncheckedUpdateWithoutUserInput>
    create: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    where?: WechatAuthWhereInput
  }

  export type WechatAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: WechatAuthWhereInput
    data: XOR<WechatAuthUpdateWithoutUserInput, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type WechatAuthUpdateWithoutUserInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthUncheckedUpdateWithoutUserInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUpsertWithoutUserInput = {
    update: XOR<GoogleAuthUpdateWithoutUserInput, GoogleAuthUncheckedUpdateWithoutUserInput>
    create: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    where?: GoogleAuthWhereInput
  }

  export type GoogleAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: GoogleAuthWhereInput
    data: XOR<GoogleAuthUpdateWithoutUserInput, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUpsertWithoutUserInput = {
    update: XOR<DiscordAuthUpdateWithoutUserInput, DiscordAuthUncheckedUpdateWithoutUserInput>
    create: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    where?: DiscordAuthWhereInput
  }

  export type DiscordAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: DiscordAuthWhereInput
    data: XOR<DiscordAuthUpdateWithoutUserInput, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUpsertWithoutUserInput = {
    update: XOR<MobileAuthUpdateWithoutUserInput, MobileAuthUncheckedUpdateWithoutUserInput>
    create: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    where?: MobileAuthWhereInput
  }

  export type MobileAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: MobileAuthWhereInput
    data: XOR<MobileAuthUpdateWithoutUserInput, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUncheckedUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUpsertWithoutUserInput = {
    update: XOR<EmailAuthUpdateWithoutUserInput, EmailAuthUncheckedUpdateWithoutUserInput>
    create: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    where?: EmailAuthWhereInput
  }

  export type EmailAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailAuthWhereInput
    data: XOR<EmailAuthUpdateWithoutUserInput, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUncheckedUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type MessageRecipientUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    update: XOR<MessageRecipientUpdateWithoutUserInput, MessageRecipientUncheckedUpdateWithoutUserInput>
    create: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput>
  }

  export type MessageRecipientUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    data: XOR<MessageRecipientUpdateWithoutUserInput, MessageRecipientUncheckedUpdateWithoutUserInput>
  }

  export type MessageRecipientUpdateManyWithWhereWithoutUserInput = {
    where: MessageRecipientScalarWhereInput
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageRecipientScalarWhereInput = {
    AND?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
    OR?: MessageRecipientScalarWhereInput[]
    NOT?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
    id?: UuidFilter<"MessageRecipient"> | string
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
  }

  export type BotUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutCreatedByInput, BotUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput>
  }

  export type BotUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutCreatedByInput, BotUncheckedUpdateWithoutCreatedByInput>
  }

  export type BotUpdateManyWithWhereWithoutCreatedByInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BotScalarWhereInput = {
    AND?: BotScalarWhereInput | BotScalarWhereInput[]
    OR?: BotScalarWhereInput[]
    NOT?: BotScalarWhereInput | BotScalarWhereInput[]
    id?: UuidFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    pendingConfig?: JsonNullableFilter<"Bot">
    healthStatus?: EnumHealthStatusFilter<"Bot"> | $Enums.HealthStatus
    lastHealthCheck?: DateTimeNullableFilter<"Bot"> | Date | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
  }

  export type ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    update: XOR<ProviderKeyUpdateWithoutCreatedByInput, ProviderKeyUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput>
  }

  export type ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    data: XOR<ProviderKeyUpdateWithoutCreatedByInput, ProviderKeyUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProviderKeyUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProviderKeyScalarWhereInput
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProviderKeyScalarWhereInput = {
    AND?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
    OR?: ProviderKeyScalarWhereInput[]
    NOT?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
    id?: UuidFilter<"ProviderKey"> | string
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
  }

  export type PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    update: XOR<PersonaTemplateUpdateWithoutCreatedByInput, PersonaTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    data: XOR<PersonaTemplateUpdateWithoutCreatedByInput, PersonaTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: PersonaTemplateScalarWhereInput
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PersonaTemplateScalarWhereInput = {
    AND?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
    OR?: PersonaTemplateScalarWhereInput[]
    NOT?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
    id?: UuidFilter<"PersonaTemplate"> | string
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    locale?: StringFilter<"PersonaTemplate"> | string
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
  }

  export type OperateLogUpsertWithWhereUniqueWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    update: XOR<OperateLogUpdateWithoutUserInput, OperateLogUncheckedUpdateWithoutUserInput>
    create: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput>
  }

  export type OperateLogUpdateWithWhereUniqueWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    data: XOR<OperateLogUpdateWithoutUserInput, OperateLogUncheckedUpdateWithoutUserInput>
  }

  export type OperateLogUpdateManyWithWhereWithoutUserInput = {
    where: OperateLogScalarWhereInput
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyWithoutUserInput>
  }

  export type OperateLogScalarWhereInput = {
    AND?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
    OR?: OperateLogScalarWhereInput[]
    NOT?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
    id?: UuidFilter<"OperateLog"> | string
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
  }

  export type UserInfoCreateWithoutPersonaTemplatesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutPersonaTemplatesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutPersonaTemplatesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
  }

  export type FileSourceCreateWithoutPersonaTemplatesInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutPersonaTemplatesInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutPersonaTemplatesInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
  }

  export type BotCreateWithoutPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput>
  }

  export type BotCreateManyPersonaTemplateInputEnvelope = {
    data: BotCreateManyPersonaTemplateInput | BotCreateManyPersonaTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutPersonaTemplatesInput = {
    update: XOR<UserInfoUpdateWithoutPersonaTemplatesInput, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
    create: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutPersonaTemplatesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutPersonaTemplatesInput, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type UserInfoUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileSourceUpsertWithoutPersonaTemplatesInput = {
    update: XOR<FileSourceUpdateWithoutPersonaTemplatesInput, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
    create: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutPersonaTemplatesInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutPersonaTemplatesInput, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type FileSourceUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type BotUpsertWithWhereUniqueWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutPersonaTemplateInput, BotUncheckedUpdateWithoutPersonaTemplateInput>
    create: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput>
  }

  export type BotUpdateWithWhereUniqueWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutPersonaTemplateInput, BotUncheckedUpdateWithoutPersonaTemplateInput>
  }

  export type BotUpdateManyWithWhereWithoutPersonaTemplateInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutPersonaTemplateInput>
  }

  export type UserInfoCreateWithoutWechatAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutWechatAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutWechatAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
  }

  export type UserInfoUpsertWithoutWechatAuthInput = {
    update: XOR<UserInfoUpdateWithoutWechatAuthInput, UserInfoUncheckedUpdateWithoutWechatAuthInput>
    create: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutWechatAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutWechatAuthInput, UserInfoUncheckedUpdateWithoutWechatAuthInput>
  }

  export type UserInfoUpdateWithoutWechatAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutWechatAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutGoogleAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutGoogleAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutGoogleAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
  }

  export type UserInfoUpsertWithoutGoogleAuthInput = {
    update: XOR<UserInfoUpdateWithoutGoogleAuthInput, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
    create: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutGoogleAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutGoogleAuthInput, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
  }

  export type UserInfoUpdateWithoutGoogleAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutGoogleAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutDiscordAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutDiscordAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutDiscordAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
  }

  export type UserInfoUpsertWithoutDiscordAuthInput = {
    update: XOR<UserInfoUpdateWithoutDiscordAuthInput, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
    create: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutDiscordAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutDiscordAuthInput, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
  }

  export type UserInfoUpdateWithoutDiscordAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutDiscordAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutMobileAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutMobileAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutMobileAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
  }

  export type UserInfoUpsertWithoutMobileAuthInput = {
    update: XOR<UserInfoUpdateWithoutMobileAuthInput, UserInfoUncheckedUpdateWithoutMobileAuthInput>
    create: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutMobileAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutMobileAuthInput, UserInfoUncheckedUpdateWithoutMobileAuthInput>
  }

  export type UserInfoUpdateWithoutMobileAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutMobileAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutEmailAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutEmailAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutEmailAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
  }

  export type UserInfoUpsertWithoutEmailAuthInput = {
    update: XOR<UserInfoUpdateWithoutEmailAuthInput, UserInfoUncheckedUpdateWithoutEmailAuthInput>
    create: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutEmailAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutEmailAuthInput, UserInfoUncheckedUpdateWithoutEmailAuthInput>
  }

  export type UserInfoUpdateWithoutEmailAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutEmailAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput>
  }

  export type UserInfoCreateManyAvatarFileInputEnvelope = {
    data: UserInfoCreateManyAvatarFileInput | UserInfoCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type PersonaTemplateCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateCreateOrConnectWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput>
  }

  export type PersonaTemplateCreateManyAvatarFileInputEnvelope = {
    data: PersonaTemplateCreateManyAvatarFileInput | PersonaTemplateCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type BotCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput>
  }

  export type BotCreateManyAvatarFileInputEnvelope = {
    data: BotCreateManyAvatarFileInput | BotCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    update: XOR<UserInfoUpdateWithoutAvatarFileInput, UserInfoUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput>
  }

  export type UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    data: XOR<UserInfoUpdateWithoutAvatarFileInput, UserInfoUncheckedUpdateWithoutAvatarFileInput>
  }

  export type UserInfoUpdateManyWithWhereWithoutAvatarFileInput = {
    where: UserInfoScalarWhereInput
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type UserInfoScalarWhereInput = {
    AND?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
    OR?: UserInfoScalarWhereInput[]
    NOT?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
    id?: UuidFilter<"UserInfo"> | string
    nickname?: StringFilter<"UserInfo"> | string
    code?: StringNullableFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableFilter<"UserInfo"> | string | null
    googleSub?: StringNullableFilter<"UserInfo"> | string | null
    discordId?: StringNullableFilter<"UserInfo"> | string | null
    mobile?: StringNullableFilter<"UserInfo"> | string | null
    email?: StringNullableFilter<"UserInfo"> | string | null
  }

  export type PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    update: XOR<PersonaTemplateUpdateWithoutAvatarFileInput, PersonaTemplateUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput>
  }

  export type PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    data: XOR<PersonaTemplateUpdateWithoutAvatarFileInput, PersonaTemplateUncheckedUpdateWithoutAvatarFileInput>
  }

  export type PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput = {
    where: PersonaTemplateScalarWhereInput
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type BotUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutAvatarFileInput, BotUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput>
  }

  export type BotUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutAvatarFileInput, BotUncheckedUpdateWithoutAvatarFileInput>
  }

  export type BotUpdateManyWithWhereWithoutAvatarFileInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type UserInfoCreateWithoutBotsInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutBotsInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutBotsInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
  }

  export type PersonaTemplateCreateWithoutBotsInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
  }

  export type PersonaTemplateUncheckedCreateWithoutBotsInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateCreateOrConnectWithoutBotsInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
  }

  export type FileSourceCreateWithoutBotAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutBotAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutBotAvatarsInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
  }

  export type BotProviderKeyCreateWithoutBotInput = {
    id?: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
    providerKey: ProviderKeyCreateNestedOneWithoutBotProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateWithoutBotInput = {
    id?: string
    providerKeyId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotProviderKeyCreateOrConnectWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    create: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput>
  }

  export type BotProviderKeyCreateManyBotInputEnvelope = {
    data: BotProviderKeyCreateManyBotInput | BotProviderKeyCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotUsageLogCreateWithoutBotInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
    providerKey?: ProviderKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateWithoutBotInput = {
    id?: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type BotUsageLogCreateOrConnectWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    create: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput>
  }

  export type BotUsageLogCreateManyBotInputEnvelope = {
    data: BotUsageLogCreateManyBotInput | BotUsageLogCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type ProxyTokenCreateWithoutBotInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providerKey: ProviderKeyCreateNestedOneWithoutProxyTokensInput
  }

  export type ProxyTokenUncheckedCreateWithoutBotInput = {
    id?: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenCreateOrConnectWithoutBotInput = {
    where: ProxyTokenWhereUniqueInput
    create: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
  }

  export type BotPluginCreateWithoutBotInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    plugin: PluginCreateNestedOneWithoutInstallationsInput
  }

  export type BotPluginUncheckedCreateWithoutBotInput = {
    id?: string
    pluginId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotPluginCreateOrConnectWithoutBotInput = {
    where: BotPluginWhereUniqueInput
    create: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput>
  }

  export type BotPluginCreateManyBotInputEnvelope = {
    data: BotPluginCreateManyBotInput | BotPluginCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotSkillCreateWithoutBotInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    skill: SkillCreateNestedOneWithoutInstallationsInput
  }

  export type BotSkillUncheckedCreateWithoutBotInput = {
    id?: string
    skillId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillCreateOrConnectWithoutBotInput = {
    where: BotSkillWhereUniqueInput
    create: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput>
  }

  export type BotSkillCreateManyBotInputEnvelope = {
    data: BotSkillCreateManyBotInput | BotSkillCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotChannelCreateWithoutBotInput = {
    id?: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotChannelUncheckedCreateWithoutBotInput = {
    id?: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotChannelCreateOrConnectWithoutBotInput = {
    where: BotChannelWhereUniqueInput
    create: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput>
  }

  export type BotChannelCreateManyBotInputEnvelope = {
    data: BotChannelCreateManyBotInput | BotChannelCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotModelRoutingCreateWithoutBotInput = {
    id?: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotModelRoutingUncheckedCreateWithoutBotInput = {
    id?: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotModelRoutingCreateOrConnectWithoutBotInput = {
    where: BotModelRoutingWhereUniqueInput
    create: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput>
  }

  export type BotModelRoutingCreateManyBotInputEnvelope = {
    data: BotModelRoutingCreateManyBotInput | BotModelRoutingCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotRoutingConfigCreateWithoutBotInput = {
    id?: string
    routingEnabled?: boolean
    routingMode?: string
    fallbackEnabled?: boolean
    fallbackChainId?: string | null
    costControlEnabled?: boolean
    costStrategyId?: string | null
    dailyBudget?: Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: Decimal | DecimalJsLike | number | string | null
    alertThreshold?: Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: boolean
    downgradeModel?: string | null
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotRoutingConfigUncheckedCreateWithoutBotInput = {
    id?: string
    routingEnabled?: boolean
    routingMode?: string
    fallbackEnabled?: boolean
    fallbackChainId?: string | null
    costControlEnabled?: boolean
    costStrategyId?: string | null
    dailyBudget?: Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: Decimal | DecimalJsLike | number | string | null
    alertThreshold?: Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: boolean
    downgradeModel?: string | null
    complexityRoutingEnabled?: boolean
    complexityRoutingConfigId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotRoutingConfigCreateOrConnectWithoutBotInput = {
    where: BotRoutingConfigWhereUniqueInput
    create: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
  }

  export type UserInfoUpsertWithoutBotsInput = {
    update: XOR<UserInfoUpdateWithoutBotsInput, UserInfoUncheckedUpdateWithoutBotsInput>
    create: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutBotsInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutBotsInput, UserInfoUncheckedUpdateWithoutBotsInput>
  }

  export type UserInfoUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PersonaTemplateUpsertWithoutBotsInput = {
    update: XOR<PersonaTemplateUpdateWithoutBotsInput, PersonaTemplateUncheckedUpdateWithoutBotsInput>
    create: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    where?: PersonaTemplateWhereInput
  }

  export type PersonaTemplateUpdateToOneWithWhereWithoutBotsInput = {
    where?: PersonaTemplateWhereInput
    data: XOR<PersonaTemplateUpdateWithoutBotsInput, PersonaTemplateUncheckedUpdateWithoutBotsInput>
  }

  export type PersonaTemplateUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileSourceUpsertWithoutBotAvatarsInput = {
    update: XOR<FileSourceUpdateWithoutBotAvatarsInput, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
    create: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutBotAvatarsInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutBotAvatarsInput, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
  }

  export type FileSourceUpdateWithoutBotAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutBotAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type BotProviderKeyUpsertWithWhereUniqueWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    update: XOR<BotProviderKeyUpdateWithoutBotInput, BotProviderKeyUncheckedUpdateWithoutBotInput>
    create: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput>
  }

  export type BotProviderKeyUpdateWithWhereUniqueWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    data: XOR<BotProviderKeyUpdateWithoutBotInput, BotProviderKeyUncheckedUpdateWithoutBotInput>
  }

  export type BotProviderKeyUpdateManyWithWhereWithoutBotInput = {
    where: BotProviderKeyScalarWhereInput
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyWithoutBotInput>
  }

  export type BotProviderKeyScalarWhereInput = {
    AND?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
    OR?: BotProviderKeyScalarWhereInput[]
    NOT?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
    id?: UuidFilter<"BotProviderKey"> | string
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    allowedModels?: StringNullableListFilter<"BotProviderKey">
    primaryModel?: StringNullableFilter<"BotProviderKey"> | string | null
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
  }

  export type BotUsageLogUpsertWithWhereUniqueWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    update: XOR<BotUsageLogUpdateWithoutBotInput, BotUsageLogUncheckedUpdateWithoutBotInput>
    create: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput>
  }

  export type BotUsageLogUpdateWithWhereUniqueWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    data: XOR<BotUsageLogUpdateWithoutBotInput, BotUsageLogUncheckedUpdateWithoutBotInput>
  }

  export type BotUsageLogUpdateManyWithWhereWithoutBotInput = {
    where: BotUsageLogScalarWhereInput
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyWithoutBotInput>
  }

  export type BotUsageLogScalarWhereInput = {
    AND?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
    OR?: BotUsageLogScalarWhereInput[]
    NOT?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
    id?: UuidFilter<"BotUsageLog"> | string
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
    model?: StringNullableFilter<"BotUsageLog"> | string | null
    endpoint?: StringNullableFilter<"BotUsageLog"> | string | null
    durationMs?: IntNullableFilter<"BotUsageLog"> | number | null
    errorMessage?: StringNullableFilter<"BotUsageLog"> | string | null
    thinkingTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheReadTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    cacheWriteTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    protocolType?: StringNullableFilter<"BotUsageLog"> | string | null
    inputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    outputCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    cacheCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    totalCost?: DecimalNullableFilter<"BotUsageLog"> | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: BoolNullableFilter<"BotUsageLog"> | boolean | null
    fallbackLevel?: IntNullableFilter<"BotUsageLog"> | number | null
    originalModel?: StringNullableFilter<"BotUsageLog"> | string | null
  }

  export type ProxyTokenUpsertWithoutBotInput = {
    update: XOR<ProxyTokenUpdateWithoutBotInput, ProxyTokenUncheckedUpdateWithoutBotInput>
    create: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    where?: ProxyTokenWhereInput
  }

  export type ProxyTokenUpdateToOneWithWhereWithoutBotInput = {
    where?: ProxyTokenWhereInput
    data: XOR<ProxyTokenUpdateWithoutBotInput, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type ProxyTokenUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerKey?: ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput
  }

  export type ProxyTokenUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotPluginUpsertWithWhereUniqueWithoutBotInput = {
    where: BotPluginWhereUniqueInput
    update: XOR<BotPluginUpdateWithoutBotInput, BotPluginUncheckedUpdateWithoutBotInput>
    create: XOR<BotPluginCreateWithoutBotInput, BotPluginUncheckedCreateWithoutBotInput>
  }

  export type BotPluginUpdateWithWhereUniqueWithoutBotInput = {
    where: BotPluginWhereUniqueInput
    data: XOR<BotPluginUpdateWithoutBotInput, BotPluginUncheckedUpdateWithoutBotInput>
  }

  export type BotPluginUpdateManyWithWhereWithoutBotInput = {
    where: BotPluginScalarWhereInput
    data: XOR<BotPluginUpdateManyMutationInput, BotPluginUncheckedUpdateManyWithoutBotInput>
  }

  export type BotPluginScalarWhereInput = {
    AND?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
    OR?: BotPluginScalarWhereInput[]
    NOT?: BotPluginScalarWhereInput | BotPluginScalarWhereInput[]
    id?: UuidFilter<"BotPlugin"> | string
    botId?: UuidFilter<"BotPlugin"> | string
    pluginId?: UuidFilter<"BotPlugin"> | string
    config?: JsonNullableFilter<"BotPlugin">
    isEnabled?: BoolFilter<"BotPlugin"> | boolean
    createdAt?: DateTimeFilter<"BotPlugin"> | Date | string
    updatedAt?: DateTimeFilter<"BotPlugin"> | Date | string
  }

  export type BotSkillUpsertWithWhereUniqueWithoutBotInput = {
    where: BotSkillWhereUniqueInput
    update: XOR<BotSkillUpdateWithoutBotInput, BotSkillUncheckedUpdateWithoutBotInput>
    create: XOR<BotSkillCreateWithoutBotInput, BotSkillUncheckedCreateWithoutBotInput>
  }

  export type BotSkillUpdateWithWhereUniqueWithoutBotInput = {
    where: BotSkillWhereUniqueInput
    data: XOR<BotSkillUpdateWithoutBotInput, BotSkillUncheckedUpdateWithoutBotInput>
  }

  export type BotSkillUpdateManyWithWhereWithoutBotInput = {
    where: BotSkillScalarWhereInput
    data: XOR<BotSkillUpdateManyMutationInput, BotSkillUncheckedUpdateManyWithoutBotInput>
  }

  export type BotSkillScalarWhereInput = {
    AND?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
    OR?: BotSkillScalarWhereInput[]
    NOT?: BotSkillScalarWhereInput | BotSkillScalarWhereInput[]
    id?: UuidFilter<"BotSkill"> | string
    botId?: UuidFilter<"BotSkill"> | string
    skillId?: UuidFilter<"BotSkill"> | string
    config?: JsonNullableFilter<"BotSkill">
    isEnabled?: BoolFilter<"BotSkill"> | boolean
    createdAt?: DateTimeFilter<"BotSkill"> | Date | string
    updatedAt?: DateTimeFilter<"BotSkill"> | Date | string
  }

  export type BotChannelUpsertWithWhereUniqueWithoutBotInput = {
    where: BotChannelWhereUniqueInput
    update: XOR<BotChannelUpdateWithoutBotInput, BotChannelUncheckedUpdateWithoutBotInput>
    create: XOR<BotChannelCreateWithoutBotInput, BotChannelUncheckedCreateWithoutBotInput>
  }

  export type BotChannelUpdateWithWhereUniqueWithoutBotInput = {
    where: BotChannelWhereUniqueInput
    data: XOR<BotChannelUpdateWithoutBotInput, BotChannelUncheckedUpdateWithoutBotInput>
  }

  export type BotChannelUpdateManyWithWhereWithoutBotInput = {
    where: BotChannelScalarWhereInput
    data: XOR<BotChannelUpdateManyMutationInput, BotChannelUncheckedUpdateManyWithoutBotInput>
  }

  export type BotChannelScalarWhereInput = {
    AND?: BotChannelScalarWhereInput | BotChannelScalarWhereInput[]
    OR?: BotChannelScalarWhereInput[]
    NOT?: BotChannelScalarWhereInput | BotChannelScalarWhereInput[]
    id?: UuidFilter<"BotChannel"> | string
    botId?: UuidFilter<"BotChannel"> | string
    channelType?: StringFilter<"BotChannel"> | string
    name?: StringFilter<"BotChannel"> | string
    credentialsEncrypted?: BytesFilter<"BotChannel"> | Bytes
    config?: JsonNullableFilter<"BotChannel">
    isEnabled?: BoolFilter<"BotChannel"> | boolean
    connectionStatus?: EnumChannelConnectionStatusFilter<"BotChannel"> | $Enums.ChannelConnectionStatus
    lastConnectedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
    lastError?: StringNullableFilter<"BotChannel"> | string | null
    isDeleted?: BoolFilter<"BotChannel"> | boolean
    createdAt?: DateTimeFilter<"BotChannel"> | Date | string
    updatedAt?: DateTimeFilter<"BotChannel"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotChannel"> | Date | string | null
  }

  export type BotModelRoutingUpsertWithWhereUniqueWithoutBotInput = {
    where: BotModelRoutingWhereUniqueInput
    update: XOR<BotModelRoutingUpdateWithoutBotInput, BotModelRoutingUncheckedUpdateWithoutBotInput>
    create: XOR<BotModelRoutingCreateWithoutBotInput, BotModelRoutingUncheckedCreateWithoutBotInput>
  }

  export type BotModelRoutingUpdateWithWhereUniqueWithoutBotInput = {
    where: BotModelRoutingWhereUniqueInput
    data: XOR<BotModelRoutingUpdateWithoutBotInput, BotModelRoutingUncheckedUpdateWithoutBotInput>
  }

  export type BotModelRoutingUpdateManyWithWhereWithoutBotInput = {
    where: BotModelRoutingScalarWhereInput
    data: XOR<BotModelRoutingUpdateManyMutationInput, BotModelRoutingUncheckedUpdateManyWithoutBotInput>
  }

  export type BotModelRoutingScalarWhereInput = {
    AND?: BotModelRoutingScalarWhereInput | BotModelRoutingScalarWhereInput[]
    OR?: BotModelRoutingScalarWhereInput[]
    NOT?: BotModelRoutingScalarWhereInput | BotModelRoutingScalarWhereInput[]
    id?: UuidFilter<"BotModelRouting"> | string
    botId?: UuidFilter<"BotModelRouting"> | string
    routingType?: EnumModelRoutingTypeFilter<"BotModelRouting"> | $Enums.ModelRoutingType
    name?: StringFilter<"BotModelRouting"> | string
    config?: JsonFilter<"BotModelRouting">
    priority?: IntFilter<"BotModelRouting"> | number
    isEnabled?: BoolFilter<"BotModelRouting"> | boolean
    isDeleted?: BoolFilter<"BotModelRouting"> | boolean
    createdAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    updatedAt?: DateTimeFilter<"BotModelRouting"> | Date | string
    deletedAt?: DateTimeNullableFilter<"BotModelRouting"> | Date | string | null
  }

  export type BotRoutingConfigUpsertWithoutBotInput = {
    update: XOR<BotRoutingConfigUpdateWithoutBotInput, BotRoutingConfigUncheckedUpdateWithoutBotInput>
    create: XOR<BotRoutingConfigCreateWithoutBotInput, BotRoutingConfigUncheckedCreateWithoutBotInput>
    where?: BotRoutingConfigWhereInput
  }

  export type BotRoutingConfigUpdateToOneWithWhereWithoutBotInput = {
    where?: BotRoutingConfigWhereInput
    data: XOR<BotRoutingConfigUpdateWithoutBotInput, BotRoutingConfigUncheckedUpdateWithoutBotInput>
  }

  export type BotRoutingConfigUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotRoutingConfigUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingEnabled?: BoolFieldUpdateOperationsInput | boolean
    routingMode?: StringFieldUpdateOperationsInput | string
    fallbackEnabled?: BoolFieldUpdateOperationsInput | boolean
    fallbackChainId?: NullableStringFieldUpdateOperationsInput | string | null
    costControlEnabled?: BoolFieldUpdateOperationsInput | boolean
    costStrategyId?: NullableStringFieldUpdateOperationsInput | string | null
    dailyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    monthlyBudget?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    alertThreshold?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    autoDowngrade?: BoolFieldUpdateOperationsInput | boolean
    downgradeModel?: NullableStringFieldUpdateOperationsInput | string | null
    complexityRoutingEnabled?: BoolFieldUpdateOperationsInput | boolean
    complexityRoutingConfigId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInfoCreateWithoutProviderKeysInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutProviderKeysInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutProviderKeysInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
  }

  export type BotProviderKeyCreateWithoutProviderKeyInput = {
    id?: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotProviderKeyCreateOrConnectWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    create: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotProviderKeyCreateManyProviderKeyInputEnvelope = {
    data: BotProviderKeyCreateManyProviderKeyInput | BotProviderKeyCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type BotUsageLogCreateWithoutProviderKeyInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
    bot: BotCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type BotUsageLogCreateOrConnectWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    create: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotUsageLogCreateManyProviderKeyInputEnvelope = {
    data: BotUsageLogCreateManyProviderKeyInput | BotUsageLogCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type ProxyTokenCreateWithoutProviderKeyInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutProxyTokenInput
  }

  export type ProxyTokenUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenCreateOrConnectWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    create: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput>
  }

  export type ProxyTokenCreateManyProviderKeyInputEnvelope = {
    data: ProxyTokenCreateManyProviderKeyInput | ProxyTokenCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutProviderKeysInput = {
    update: XOR<UserInfoUpdateWithoutProviderKeysInput, UserInfoUncheckedUpdateWithoutProviderKeysInput>
    create: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutProviderKeysInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutProviderKeysInput, UserInfoUncheckedUpdateWithoutProviderKeysInput>
  }

  export type UserInfoUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    update: XOR<BotProviderKeyUpdateWithoutProviderKeyInput, BotProviderKeyUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    data: XOR<BotProviderKeyUpdateWithoutProviderKeyInput, BotProviderKeyUncheckedUpdateWithoutProviderKeyInput>
  }

  export type BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput = {
    where: BotProviderKeyScalarWhereInput
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    update: XOR<BotUsageLogUpdateWithoutProviderKeyInput, BotUsageLogUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    data: XOR<BotUsageLogUpdateWithoutProviderKeyInput, BotUsageLogUncheckedUpdateWithoutProviderKeyInput>
  }

  export type BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput = {
    where: BotUsageLogScalarWhereInput
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    update: XOR<ProxyTokenUpdateWithoutProviderKeyInput, ProxyTokenUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput>
  }

  export type ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    data: XOR<ProxyTokenUpdateWithoutProviderKeyInput, ProxyTokenUncheckedUpdateWithoutProviderKeyInput>
  }

  export type ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput = {
    where: ProxyTokenScalarWhereInput
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type ProxyTokenScalarWhereInput = {
    AND?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
    OR?: ProxyTokenScalarWhereInput[]
    NOT?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
    id?: UuidFilter<"ProxyToken"> | string
    botId?: UuidFilter<"ProxyToken"> | string
    tokenHash?: StringFilter<"ProxyToken"> | string
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
  }

  export type BotCreateWithoutProviderKeysInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutProviderKeysInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutProviderKeysInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
  }

  export type ProviderKeyCreateWithoutBotProviderKeysInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutBotProviderKeysInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutBotProviderKeysInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
  }

  export type BotUpsertWithoutProviderKeysInput = {
    update: XOR<BotUpdateWithoutProviderKeysInput, BotUncheckedUpdateWithoutProviderKeysInput>
    create: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutProviderKeysInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutProviderKeysInput, BotUncheckedUpdateWithoutProviderKeysInput>
  }

  export type BotUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutBotProviderKeysInput = {
    update: XOR<ProviderKeyUpdateWithoutBotProviderKeysInput, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
    create: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutBotProviderKeysInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutBotProviderKeysInput, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
  }

  export type ProviderKeyUpdateWithoutBotProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type BotCreateWithoutUsageLogsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutUsageLogsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
  }

  export type ProviderKeyCreateWithoutUsageLogsInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutUsageLogsInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
  }

  export type BotUpsertWithoutUsageLogsInput = {
    update: XOR<BotUpdateWithoutUsageLogsInput, BotUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutUsageLogsInput, BotUncheckedUpdateWithoutUsageLogsInput>
  }

  export type BotUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutUsageLogsInput = {
    update: XOR<ProviderKeyUpdateWithoutUsageLogsInput, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutUsageLogsInput, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProviderKeyUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type BotCreateWithoutProxyTokenInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutProxyTokenInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutProxyTokenInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
  }

  export type ProviderKeyCreateWithoutProxyTokensInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutProxyTokensInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutProxyTokensInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
  }

  export type BotUpsertWithoutProxyTokenInput = {
    update: XOR<BotUpdateWithoutProxyTokenInput, BotUncheckedUpdateWithoutProxyTokenInput>
    create: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutProxyTokenInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutProxyTokenInput, BotUncheckedUpdateWithoutProxyTokenInput>
  }

  export type BotUpdateWithoutProxyTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutProxyTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutProxyTokensInput = {
    update: XOR<ProviderKeyUpdateWithoutProxyTokensInput, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
    create: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutProxyTokensInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutProxyTokensInput, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
  }

  export type ProviderKeyUpdateWithoutProxyTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutProxyTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type UserInfoCreateWithoutSentMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutSentMessagesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
  }

  export type MessageRecipientCreateWithoutMessageInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageRecipientUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateOrConnectWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    create: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientCreateManyMessageInputEnvelope = {
    data: MessageRecipientCreateManyMessageInput | MessageRecipientCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutSentMessagesInput = {
    update: XOR<UserInfoUpdateWithoutSentMessagesInput, UserInfoUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutSentMessagesInput, UserInfoUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserInfoUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageRecipientUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    update: XOR<MessageRecipientUpdateWithoutMessageInput, MessageRecipientUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    data: XOR<MessageRecipientUpdateWithoutMessageInput, MessageRecipientUncheckedUpdateWithoutMessageInput>
  }

  export type MessageRecipientUpdateManyWithWhereWithoutMessageInput = {
    where: MessageRecipientScalarWhereInput
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutRecipientsInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    sender?: UserInfoCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutRecipientsInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type UserInfoCreateWithoutReceivedMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MessageUpsertWithoutRecipientsInput = {
    update: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type MessageUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserInfoUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserInfoUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserInfoUpdateWithoutReceivedMessagesInput, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutReceivedMessagesInput, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserInfoUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutOperateLogsInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserInfoUncheckedCreateWithoutOperateLogsInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserInfoCreateOrConnectWithoutOperateLogsInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
  }

  export type UserInfoUpsertWithoutOperateLogsInput = {
    update: XOR<UserInfoUpdateWithoutOperateLogsInput, UserInfoUncheckedUpdateWithoutOperateLogsInput>
    create: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutOperateLogsInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutOperateLogsInput, UserInfoUncheckedUpdateWithoutOperateLogsInput>
  }

  export type UserInfoUpdateWithoutOperateLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutOperateLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ChannelCredentialFieldCreateWithoutChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUncheckedCreateWithoutChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldCreateOrConnectWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    create: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCredentialFieldCreateManyChannelInputEnvelope = {
    data: ChannelCredentialFieldCreateManyChannelInput | ChannelCredentialFieldCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    update: XOR<ChannelCredentialFieldUpdateWithoutChannelInput, ChannelCredentialFieldUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    data: XOR<ChannelCredentialFieldUpdateWithoutChannelInput, ChannelCredentialFieldUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelCredentialFieldScalarWhereInput
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelCredentialFieldScalarWhereInput = {
    AND?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
    OR?: ChannelCredentialFieldScalarWhereInput[]
    NOT?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
    id?: UuidFilter<"ChannelCredentialField"> | string
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
  }

  export type ChannelDefinitionCreateWithoutCredentialFieldsInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    popularLocales?: ChannelDefinitionCreatepopularLocalesInput | string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    popularLocales?: ChannelDefinitionCreatepopularLocalesInput | string[]
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput = {
    where: ChannelDefinitionWhereUniqueInput
    create: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
  }

  export type ChannelDefinitionUpsertWithoutCredentialFieldsInput = {
    update: XOR<ChannelDefinitionUpdateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
    create: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    where?: ChannelDefinitionWhereInput
  }

  export type ChannelDefinitionUpdateToOneWithWhereWithoutCredentialFieldsInput = {
    where?: ChannelDefinitionWhereInput
    data: XOR<ChannelDefinitionUpdateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
  }

  export type ChannelDefinitionUpdateWithoutCredentialFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    popularLocales?: ChannelDefinitionUpdatepopularLocalesInput | string[]
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotPluginCreateWithoutPluginInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutPluginsInput
  }

  export type BotPluginUncheckedCreateWithoutPluginInput = {
    id?: string
    botId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotPluginCreateOrConnectWithoutPluginInput = {
    where: BotPluginWhereUniqueInput
    create: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput>
  }

  export type BotPluginCreateManyPluginInputEnvelope = {
    data: BotPluginCreateManyPluginInput | BotPluginCreateManyPluginInput[]
    skipDuplicates?: boolean
  }

  export type BotPluginUpsertWithWhereUniqueWithoutPluginInput = {
    where: BotPluginWhereUniqueInput
    update: XOR<BotPluginUpdateWithoutPluginInput, BotPluginUncheckedUpdateWithoutPluginInput>
    create: XOR<BotPluginCreateWithoutPluginInput, BotPluginUncheckedCreateWithoutPluginInput>
  }

  export type BotPluginUpdateWithWhereUniqueWithoutPluginInput = {
    where: BotPluginWhereUniqueInput
    data: XOR<BotPluginUpdateWithoutPluginInput, BotPluginUncheckedUpdateWithoutPluginInput>
  }

  export type BotPluginUpdateManyWithWhereWithoutPluginInput = {
    where: BotPluginScalarWhereInput
    data: XOR<BotPluginUpdateManyMutationInput, BotPluginUncheckedUpdateManyWithoutPluginInput>
  }

  export type BotCreateWithoutPluginsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutPluginsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutPluginsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutPluginsInput, BotUncheckedCreateWithoutPluginsInput>
  }

  export type PluginCreateWithoutInstallationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version: string
    author?: string | null
    category: $Enums.PluginCategory
    region?: string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: string | null
    iconEmoji?: string | null
    iconUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PluginUncheckedCreateWithoutInstallationsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    version: string
    author?: string | null
    category: $Enums.PluginCategory
    region?: string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: boolean
    isEnabled?: boolean
    downloadUrl?: string | null
    iconEmoji?: string | null
    iconUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PluginCreateOrConnectWithoutInstallationsInput = {
    where: PluginWhereUniqueInput
    create: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
  }

  export type BotUpsertWithoutPluginsInput = {
    update: XOR<BotUpdateWithoutPluginsInput, BotUncheckedUpdateWithoutPluginsInput>
    create: XOR<BotCreateWithoutPluginsInput, BotUncheckedCreateWithoutPluginsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutPluginsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutPluginsInput, BotUncheckedUpdateWithoutPluginsInput>
  }

  export type BotUpdateWithoutPluginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutPluginsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type PluginUpsertWithoutInstallationsInput = {
    update: XOR<PluginUpdateWithoutInstallationsInput, PluginUncheckedUpdateWithoutInstallationsInput>
    create: XOR<PluginCreateWithoutInstallationsInput, PluginUncheckedCreateWithoutInstallationsInput>
    where?: PluginWhereInput
  }

  export type PluginUpdateToOneWithWhereWithoutInstallationsInput = {
    where?: PluginWhereInput
    data: XOR<PluginUpdateWithoutInstallationsInput, PluginUncheckedUpdateWithoutInstallationsInput>
  }

  export type PluginUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PluginUncheckedUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    category?: EnumPluginCategoryFieldUpdateOperationsInput | $Enums.PluginCategory
    region?: StringFieldUpdateOperationsInput | string
    configSchema?: NullableJsonNullValueInput | InputJsonValue
    defaultConfig?: NullableJsonNullValueInput | InputJsonValue
    mcpConfig?: NullableJsonNullValueInput | InputJsonValue
    isOfficial?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    downloadUrl?: NullableStringFieldUpdateOperationsInput | string | null
    iconEmoji?: NullableStringFieldUpdateOperationsInput | string | null
    iconUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillCreateWithoutSkillTypeInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installations?: BotSkillCreateNestedManyWithoutSkillInput
  }

  export type SkillUncheckedCreateWithoutSkillTypeInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    installations?: BotSkillUncheckedCreateNestedManyWithoutSkillInput
  }

  export type SkillCreateOrConnectWithoutSkillTypeInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput>
  }

  export type SkillCreateManySkillTypeInputEnvelope = {
    data: SkillCreateManySkillTypeInput | SkillCreateManySkillTypeInput[]
    skipDuplicates?: boolean
  }

  export type SkillUpsertWithWhereUniqueWithoutSkillTypeInput = {
    where: SkillWhereUniqueInput
    update: XOR<SkillUpdateWithoutSkillTypeInput, SkillUncheckedUpdateWithoutSkillTypeInput>
    create: XOR<SkillCreateWithoutSkillTypeInput, SkillUncheckedCreateWithoutSkillTypeInput>
  }

  export type SkillUpdateWithWhereUniqueWithoutSkillTypeInput = {
    where: SkillWhereUniqueInput
    data: XOR<SkillUpdateWithoutSkillTypeInput, SkillUncheckedUpdateWithoutSkillTypeInput>
  }

  export type SkillUpdateManyWithWhereWithoutSkillTypeInput = {
    where: SkillScalarWhereInput
    data: XOR<SkillUpdateManyMutationInput, SkillUncheckedUpdateManyWithoutSkillTypeInput>
  }

  export type SkillScalarWhereInput = {
    AND?: SkillScalarWhereInput | SkillScalarWhereInput[]
    OR?: SkillScalarWhereInput[]
    NOT?: SkillScalarWhereInput | SkillScalarWhereInput[]
    id?: UuidFilter<"Skill"> | string
    name?: StringFilter<"Skill"> | string
    nameZh?: StringNullableFilter<"Skill"> | string | null
    slug?: StringFilter<"Skill"> | string
    description?: StringNullableFilter<"Skill"> | string | null
    descriptionZh?: StringNullableFilter<"Skill"> | string | null
    version?: StringFilter<"Skill"> | string
    skillTypeId?: UuidNullableFilter<"Skill"> | string | null
    definition?: JsonFilter<"Skill">
    examples?: JsonNullableFilter<"Skill">
    isSystem?: BoolFilter<"Skill"> | boolean
    isEnabled?: BoolFilter<"Skill"> | boolean
    createdById?: UuidNullableFilter<"Skill"> | string | null
    source?: StringNullableFilter<"Skill"> | string | null
    sourceUrl?: StringNullableFilter<"Skill"> | string | null
    author?: StringNullableFilter<"Skill"> | string | null
    lastSyncedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
    isDeleted?: BoolFilter<"Skill"> | boolean
    createdAt?: DateTimeFilter<"Skill"> | Date | string
    updatedAt?: DateTimeFilter<"Skill"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Skill"> | Date | string | null
  }

  export type SkillTypeCreateWithoutSkillsInput = {
    id?: string
    slug: string
    name: string
    nameZh?: string | null
    description?: string | null
    descriptionZh?: string | null
    icon?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillTypeUncheckedCreateWithoutSkillsInput = {
    id?: string
    slug: string
    name: string
    nameZh?: string | null
    description?: string | null
    descriptionZh?: string | null
    icon?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillTypeCreateOrConnectWithoutSkillsInput = {
    where: SkillTypeWhereUniqueInput
    create: XOR<SkillTypeCreateWithoutSkillsInput, SkillTypeUncheckedCreateWithoutSkillsInput>
  }

  export type BotSkillCreateWithoutSkillInput = {
    id?: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutSkillsInput
  }

  export type BotSkillUncheckedCreateWithoutSkillInput = {
    id?: string
    botId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillCreateOrConnectWithoutSkillInput = {
    where: BotSkillWhereUniqueInput
    create: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput>
  }

  export type BotSkillCreateManySkillInputEnvelope = {
    data: BotSkillCreateManySkillInput | BotSkillCreateManySkillInput[]
    skipDuplicates?: boolean
  }

  export type SkillTypeUpsertWithoutSkillsInput = {
    update: XOR<SkillTypeUpdateWithoutSkillsInput, SkillTypeUncheckedUpdateWithoutSkillsInput>
    create: XOR<SkillTypeCreateWithoutSkillsInput, SkillTypeUncheckedCreateWithoutSkillsInput>
    where?: SkillTypeWhereInput
  }

  export type SkillTypeUpdateToOneWithWhereWithoutSkillsInput = {
    where?: SkillTypeWhereInput
    data: XOR<SkillTypeUpdateWithoutSkillsInput, SkillTypeUncheckedUpdateWithoutSkillsInput>
  }

  export type SkillTypeUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SkillTypeUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotSkillUpsertWithWhereUniqueWithoutSkillInput = {
    where: BotSkillWhereUniqueInput
    update: XOR<BotSkillUpdateWithoutSkillInput, BotSkillUncheckedUpdateWithoutSkillInput>
    create: XOR<BotSkillCreateWithoutSkillInput, BotSkillUncheckedCreateWithoutSkillInput>
  }

  export type BotSkillUpdateWithWhereUniqueWithoutSkillInput = {
    where: BotSkillWhereUniqueInput
    data: XOR<BotSkillUpdateWithoutSkillInput, BotSkillUncheckedUpdateWithoutSkillInput>
  }

  export type BotSkillUpdateManyWithWhereWithoutSkillInput = {
    where: BotSkillScalarWhereInput
    data: XOR<BotSkillUpdateManyMutationInput, BotSkillUncheckedUpdateManyWithoutSkillInput>
  }

  export type BotCreateWithoutSkillsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutSkillsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutSkillsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutSkillsInput, BotUncheckedCreateWithoutSkillsInput>
  }

  export type SkillCreateWithoutInstallationsInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    skillType?: SkillTypeCreateNestedOneWithoutSkillsInput
  }

  export type SkillUncheckedCreateWithoutInstallationsInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    skillTypeId?: string | null
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillCreateOrConnectWithoutInstallationsInput = {
    where: SkillWhereUniqueInput
    create: XOR<SkillCreateWithoutInstallationsInput, SkillUncheckedCreateWithoutInstallationsInput>
  }

  export type BotUpsertWithoutSkillsInput = {
    update: XOR<BotUpdateWithoutSkillsInput, BotUncheckedUpdateWithoutSkillsInput>
    create: XOR<BotCreateWithoutSkillsInput, BotUncheckedCreateWithoutSkillsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutSkillsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutSkillsInput, BotUncheckedUpdateWithoutSkillsInput>
  }

  export type BotUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutSkillsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type SkillUpsertWithoutInstallationsInput = {
    update: XOR<SkillUpdateWithoutInstallationsInput, SkillUncheckedUpdateWithoutInstallationsInput>
    create: XOR<SkillCreateWithoutInstallationsInput, SkillUncheckedCreateWithoutInstallationsInput>
    where?: SkillWhereInput
  }

  export type SkillUpdateToOneWithWhereWithoutInstallationsInput = {
    where?: SkillWhereInput
    data: XOR<SkillUpdateWithoutInstallationsInput, SkillUncheckedUpdateWithoutInstallationsInput>
  }

  export type SkillUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    skillType?: SkillTypeUpdateOneWithoutSkillsNestedInput
  }

  export type SkillUncheckedUpdateWithoutInstallationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    skillTypeId?: NullableStringFieldUpdateOperationsInput | string | null
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotCreateWithoutModelRoutingsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutModelRoutingsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutModelRoutingsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutModelRoutingsInput, BotUncheckedCreateWithoutModelRoutingsInput>
  }

  export type BotUpsertWithoutModelRoutingsInput = {
    update: XOR<BotUpdateWithoutModelRoutingsInput, BotUncheckedUpdateWithoutModelRoutingsInput>
    create: XOR<BotCreateWithoutModelRoutingsInput, BotUncheckedCreateWithoutModelRoutingsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutModelRoutingsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutModelRoutingsInput, BotUncheckedUpdateWithoutModelRoutingsInput>
  }

  export type BotUpdateWithoutModelRoutingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutModelRoutingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotCreateWithoutChannelsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutChannelsInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
    routingConfig?: BotRoutingConfigUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutChannelsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutChannelsInput, BotUncheckedCreateWithoutChannelsInput>
  }

  export type BotUpsertWithoutChannelsInput = {
    update: XOR<BotUpdateWithoutChannelsInput, BotUncheckedUpdateWithoutChannelsInput>
    create: XOR<BotCreateWithoutChannelsInput, BotUncheckedCreateWithoutChannelsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutChannelsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutChannelsInput, BotUncheckedUpdateWithoutChannelsInput>
  }

  export type BotUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutChannelsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotCreateWithoutRoutingConfigInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
    plugins?: BotPluginCreateNestedManyWithoutBotInput
    skills?: BotSkillCreateNestedManyWithoutBotInput
    channels?: BotChannelCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutRoutingConfigInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
    plugins?: BotPluginUncheckedCreateNestedManyWithoutBotInput
    skills?: BotSkillUncheckedCreateNestedManyWithoutBotInput
    channels?: BotChannelUncheckedCreateNestedManyWithoutBotInput
    modelRoutings?: BotModelRoutingUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutRoutingConfigInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutRoutingConfigInput, BotUncheckedCreateWithoutRoutingConfigInput>
  }

  export type BotUpsertWithoutRoutingConfigInput = {
    update: XOR<BotUpdateWithoutRoutingConfigInput, BotUncheckedUpdateWithoutRoutingConfigInput>
    create: XOR<BotCreateWithoutRoutingConfigInput, BotUncheckedCreateWithoutRoutingConfigInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutRoutingConfigInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutRoutingConfigInput, BotUncheckedUpdateWithoutRoutingConfigInput>
  }

  export type BotUpdateWithoutRoutingConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutRoutingConfigInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
  }

  export type MessageCreateManySenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateManyUserInput = {
    id?: string
    messageId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type BotCreateManyCreatedByInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProviderKeyCreateManyCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OperateLogCreateManyUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type MessageRecipientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonaTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperateLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotCreateManyPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotUpdateWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserInfoCreateManyAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
  }

  export type PersonaTemplateCreateManyAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    locale?: string
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotCreateManyAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    soulMarkdown?: string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: $Enums.HealthStatus
    lastHealthCheck?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserInfoUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaTemplateUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    locale?: StringFieldUpdateOperationsInput | string
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUpdateManyWithoutBotNestedInput
    skills?: BotSkillUpdateManyWithoutBotNestedInput
    channels?: BotChannelUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
    plugins?: BotPluginUncheckedUpdateManyWithoutBotNestedInput
    skills?: BotSkillUncheckedUpdateManyWithoutBotNestedInput
    channels?: BotChannelUncheckedUpdateManyWithoutBotNestedInput
    modelRoutings?: BotModelRoutingUncheckedUpdateManyWithoutBotNestedInput
    routingConfig?: BotRoutingConfigUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    pendingConfig?: NullableJsonNullValueInput | InputJsonValue
    healthStatus?: EnumHealthStatusFieldUpdateOperationsInput | $Enums.HealthStatus
    lastHealthCheck?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotProviderKeyCreateManyBotInput = {
    id?: string
    providerKeyId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotUsageLogCreateManyBotInput = {
    id?: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type BotPluginCreateManyBotInput = {
    id?: string
    pluginId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillCreateManyBotInput = {
    id?: string
    skillId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotChannelCreateManyBotInput = {
    id?: string
    channelType: string
    name: string
    credentialsEncrypted: Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    connectionStatus?: $Enums.ChannelConnectionStatus
    lastConnectedAt?: Date | string | null
    lastError?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotModelRoutingCreateManyBotInput = {
    id?: string
    routingType: $Enums.ModelRoutingType
    name: string
    config: JsonNullValueInput | InputJsonValue
    priority?: number
    isEnabled?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotProviderKeyUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerKey?: ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
    providerKey?: ProviderKeyUpdateOneWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BotUsageLogUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BotPluginUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    plugin?: PluginUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type BotPluginUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotPluginUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    pluginId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotSkillUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    skill?: SkillUpdateOneRequiredWithoutInstallationsNestedInput
  }

  export type BotSkillUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotSkillUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    skillId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotChannelUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotChannelUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotChannelUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    credentialsEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    connectionStatus?: EnumChannelConnectionStatusFieldUpdateOperationsInput | $Enums.ChannelConnectionStatus
    lastConnectedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastError?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotModelRoutingUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    routingType?: EnumModelRoutingTypeFieldUpdateOperationsInput | $Enums.ModelRoutingType
    name?: StringFieldUpdateOperationsInput | string
    config?: JsonNullValueInput | InputJsonValue
    priority?: IntFieldUpdateOperationsInput | number
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotProviderKeyCreateManyProviderKeyInput = {
    id?: string
    botId: string
    isPrimary?: boolean
    allowedModels?: BotProviderKeyCreateallowedModelsInput | string[]
    primaryModel?: string | null
    createdAt?: Date | string
  }

  export type BotUsageLogCreateManyProviderKeyInput = {
    id?: string
    botId: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    model?: string | null
    endpoint?: string | null
    durationMs?: number | null
    errorMessage?: string | null
    thinkingTokens?: number | null
    cacheReadTokens?: number | null
    cacheWriteTokens?: number | null
    protocolType?: string | null
    inputCost?: Decimal | DecimalJsLike | number | string | null
    outputCost?: Decimal | DecimalJsLike | number | string | null
    thinkingCost?: Decimal | DecimalJsLike | number | string | null
    cacheCost?: Decimal | DecimalJsLike | number | string | null
    totalCost?: Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: boolean | null
    fallbackLevel?: number | null
    originalModel?: string | null
  }

  export type ProxyTokenCreateManyProviderKeyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotProviderKeyUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    allowedModels?: BotProviderKeyUpdateallowedModelsInput | string[]
    primaryModel?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
    bot?: BotUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type BotUsageLogUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: NullableStringFieldUpdateOperationsInput | string | null
    endpoint?: NullableStringFieldUpdateOperationsInput | string | null
    durationMs?: NullableIntFieldUpdateOperationsInput | number | null
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    thinkingTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheReadTokens?: NullableIntFieldUpdateOperationsInput | number | null
    cacheWriteTokens?: NullableIntFieldUpdateOperationsInput | number | null
    protocolType?: NullableStringFieldUpdateOperationsInput | string | null
    inputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    outputCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    thinkingCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    cacheCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    totalCost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    fallbackUsed?: NullableBoolFieldUpdateOperationsInput | boolean | null
    fallbackLevel?: NullableIntFieldUpdateOperationsInput | number | null
    originalModel?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ProxyTokenUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProxyTokenNestedInput
  }

  export type ProxyTokenUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRecipientCreateManyMessageInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageRecipientUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateManyChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotPluginCreateManyPluginInput = {
    id?: string
    botId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotPluginUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutPluginsNestedInput
  }

  export type BotPluginUncheckedUpdateWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotPluginUncheckedUpdateManyWithoutPluginInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SkillCreateManySkillTypeInput = {
    id?: string
    name: string
    nameZh?: string | null
    slug: string
    description?: string | null
    descriptionZh?: string | null
    version?: string
    definition: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: boolean
    isEnabled?: boolean
    createdById?: string | null
    source?: string | null
    sourceUrl?: string | null
    author?: string | null
    lastSyncedAt?: Date | string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type SkillUpdateWithoutSkillTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installations?: BotSkillUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateWithoutSkillTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    installations?: BotSkillUncheckedUpdateManyWithoutSkillNestedInput
  }

  export type SkillUncheckedUpdateManyWithoutSkillTypeInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    nameZh?: NullableStringFieldUpdateOperationsInput | string | null
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    descriptionZh?: NullableStringFieldUpdateOperationsInput | string | null
    version?: StringFieldUpdateOperationsInput | string
    definition?: JsonNullValueInput | InputJsonValue
    examples?: NullableJsonNullValueInput | InputJsonValue
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    source?: NullableStringFieldUpdateOperationsInput | string | null
    sourceUrl?: NullableStringFieldUpdateOperationsInput | string | null
    author?: NullableStringFieldUpdateOperationsInput | string | null
    lastSyncedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotSkillCreateManySkillInput = {
    id?: string
    botId: string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotSkillUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutSkillsNestedInput
  }

  export type BotSkillUncheckedUpdateWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotSkillUncheckedUpdateManyWithoutSkillInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    config?: NullableJsonNullValueInput | InputJsonValue
    isEnabled?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}