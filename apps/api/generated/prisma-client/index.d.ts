
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model UserInfo
 * 
 */
export type UserInfo = $Result.DefaultSelection<Prisma.$UserInfoPayload>
/**
 * Model PersonaTemplate
 * PersonaTemplate - ‰∫∫Ê†ºÊ®°Êùø
 * ÊîØÊåÅÁ≥ªÁªüÈ¢ÑËÆæÊ®°ÊùøÂíåÁî®Êà∑Ëá™ÂÆö‰πâÊ®°Êùø
 * ÂõæÊ†áÊîØÊåÅ‰∏§ÁßçÂΩ¢ÂºèÔºà‰∫åÈÄâ‰∏ÄÔºâÔºö
 * - emoji: emoji Â≠óÁ¨¶‰∏≤ÔºàÂ¶Ç "ü§ñ"Ôºâ
 * - avatarFileId: ‰∏ä‰º†ÁöÑÂ§¥ÂÉèÊñá‰ª∂ IDÔºàÂÖ≥ËÅî FileSourceÔºâ
 */
export type PersonaTemplate = $Result.DefaultSelection<Prisma.$PersonaTemplatePayload>
/**
 * Model WechatAuth
 * 
 */
export type WechatAuth = $Result.DefaultSelection<Prisma.$WechatAuthPayload>
/**
 * Model GoogleAuth
 * 
 */
export type GoogleAuth = $Result.DefaultSelection<Prisma.$GoogleAuthPayload>
/**
 * Model DiscordAuth
 * 
 */
export type DiscordAuth = $Result.DefaultSelection<Prisma.$DiscordAuthPayload>
/**
 * Model MobileAuth
 * 
 */
export type MobileAuth = $Result.DefaultSelection<Prisma.$MobileAuthPayload>
/**
 * Model EmailAuth
 * 
 */
export type EmailAuth = $Result.DefaultSelection<Prisma.$EmailAuthPayload>
/**
 * Model RiskDetectionRecord
 * 
 */
export type RiskDetectionRecord = $Result.DefaultSelection<Prisma.$RiskDetectionRecordPayload>
/**
 * Model SystemTaskQueue
 * 
 */
export type SystemTaskQueue = $Result.DefaultSelection<Prisma.$SystemTaskQueuePayload>
/**
 * Model FileSource
 * 
 */
export type FileSource = $Result.DefaultSelection<Prisma.$FileSourcePayload>
/**
 * Model CountryCode
 * 
 */
export type CountryCode = $Result.DefaultSelection<Prisma.$CountryCodePayload>
/**
 * Model Bot
 * Bot - Êú∫Âô®‰∫∫ÂÆû‰Ωì
 * ÁÆ°ÁêÜ AI Êú∫Âô®‰∫∫ÁöÑÁîüÂëΩÂë®ÊúüÂíåÈÖçÁΩÆ
 */
export type Bot = $Result.DefaultSelection<Prisma.$BotPayload>
/**
 * Model ProviderKey
 * ProviderKey - AI Êèê‰æõÂïÜ API ÂØÜÈí•
 * Â≠òÂÇ®Âä†ÂØÜÁöÑ API ÂØÜÈí•ÔºåÊîØÊåÅÂ§öÊèê‰æõÂïÜÂíåÊ†áÁ≠æË∑ØÁî±
 * ProviderKey - API ÂØÜÈí•ÈÖçÁΩÆ
 * Â≠òÂÇ®Áî®Êà∑ÈÖçÁΩÆÁöÑÂêÑÁ±ª AI ÊúçÂä°ÂïÜ API ÂØÜÈí•
 * ÊîØÊåÅ OpenAI„ÄÅAnthropic„ÄÅGoogle„ÄÅDeepSeek Á≠â‰∏ªÊµÅÊúçÂä°ÂïÜÔºå‰ª•ÂèäËá™ÂÆö‰πâÊúçÂä°ÂïÜ
 */
export type ProviderKey = $Result.DefaultSelection<Prisma.$ProviderKeyPayload>
/**
 * Model BotProviderKey
 * BotProviderKey - Bot ‰∏é ProviderKey ÁöÑÂÖ≥ËÅîË°®
 */
export type BotProviderKey = $Result.DefaultSelection<Prisma.$BotProviderKeyPayload>
/**
 * Model BotUsageLog
 * BotUsageLog - Bot API ‰ΩøÁî®Êó•Âøó
 * ËÆ∞ÂΩïÊØèÊ¨° API Ë∞ÉÁî®ÁöÑ‰ΩøÁî®ÊÉÖÂÜµ
 */
export type BotUsageLog = $Result.DefaultSelection<Prisma.$BotUsageLogPayload>
/**
 * Model ProxyToken
 * ProxyToken - Zero-Trust Ê®°ÂºèÁöÑ‰ª£ÁêÜ‰ª§Áâå
 * Bot ÂÆπÂô®‰ΩøÁî®Ê≠§‰ª§ÁâåÈÄöËøá Proxy ËÆøÈóÆ AI APIÔºåËÄå‰∏çÁõ¥Êé•ÊåÅÊúâ API Key
 * Ê†∏ÂøÉÂÆâÂÖ®ÂéüÂàôÔºöBot ÂÆπÂô®Ê∞∏Ëøú‰∏çÊåÅÊúâÁúüÂÆûÁöÑ API Key
 */
export type ProxyToken = $Result.DefaultSelection<Prisma.$ProxyTokenPayload>
/**
 * Model Message
 * User Message System
 * Áî®Êà∑Ê∂àÊÅØÁ≥ªÁªü - ÊîØÊåÅÁ≥ªÁªüÈÄöÁü•„ÄÅÁî®Êà∑Èó¥Ê∂àÊÅØÁ≠â
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model MessageRecipient
 * Message Recipient - Ê∂àÊÅØÊé•Êî∂ËÆ∞ÂΩï
 * ËÆ∞ÂΩïÊØè‰∏™Áî®Êà∑Êé•Êî∂Âà∞ÁöÑÊ∂àÊÅØÂèäÂÖ∂ÈòÖËØªÁä∂ÊÄÅ
 */
export type MessageRecipient = $Result.DefaultSelection<Prisma.$MessageRecipientPayload>
/**
 * Model OperateLog
 * OperateLog - Êìç‰ΩúÊó•Âøó
 * ËÆ∞ÂΩïÁî®Êà∑ÁöÑÊìç‰ΩúË°å‰∏∫ÔºåÁî®‰∫éÂÆ°ËÆ°ÂíåËøΩË∏™
 */
export type OperateLog = $Result.DefaultSelection<Prisma.$OperateLogPayload>
/**
 * Model ChannelDefinition
 * ChannelDefinition - Ê∏†ÈÅìÂÆö‰πâ
 * Â≠òÂÇ®ÂêÑÁßçÊ∂àÊÅØÊ∏†ÈÅìÁöÑÈÖçÁΩÆ‰ø°ÊÅØÔºåÂåÖÊã¨ÊâÄÈúÄÁöÑÂá≠ËØÅÂ≠óÊÆµ
 */
export type ChannelDefinition = $Result.DefaultSelection<Prisma.$ChannelDefinitionPayload>
/**
 * Model ChannelCredentialField
 * ChannelCredentialField - Ê∏†ÈÅìÂá≠ËØÅÂ≠óÊÆµ
 * ÂÆö‰πâÊØè‰∏™Ê∏†ÈÅìÊâÄÈúÄÁöÑÂá≠ËØÅÂ≠óÊÆµÈÖçÁΩÆ
 */
export type ChannelCredentialField = $Result.DefaultSelection<Prisma.$ChannelCredentialFieldPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const SexType: {
  UNKNOWN: 'UNKNOWN',
  MALE: 'MALE',
  FEMALE: 'FEMALE'
};

export type SexType = (typeof SexType)[keyof typeof SexType]


export const TaskType: {
  SMS: 'SMS',
  EMAIL: 'EMAIL',
  PUSH: 'PUSH'
};

export type TaskType = (typeof TaskType)[keyof typeof TaskType]


export const TaskStatus: {
  SUCCESS: 'SUCCESS',
  FAILED: 'FAILED'
};

export type TaskStatus = (typeof TaskStatus)[keyof typeof TaskStatus]


export const FileBucketVendor: {
  oss: 'oss',
  us3: 'us3',
  qiniu: 'qiniu',
  s3: 's3',
  gcs: 'gcs',
  tos: 'tos',
  tencent: 'tencent',
  ksyun: 'ksyun'
};

export type FileBucketVendor = (typeof FileBucketVendor)[keyof typeof FileBucketVendor]


export const FileEnvType: {
  dev: 'dev',
  test: 'test',
  prod: 'prod',
  produs: 'produs',
  prodap: 'prodap'
};

export type FileEnvType = (typeof FileEnvType)[keyof typeof FileEnvType]


export const BotStatus: {
  created: 'created',
  starting: 'starting',
  running: 'running',
  stopped: 'stopped',
  error: 'error'
};

export type BotStatus = (typeof BotStatus)[keyof typeof BotStatus]


export const OperateType: {
  CREATE: 'CREATE',
  UPDATE: 'UPDATE',
  DELETE: 'DELETE',
  LOGIN: 'LOGIN',
  LOGOUT: 'LOGOUT',
  START: 'START',
  STOP: 'STOP',
  EXPORT: 'EXPORT',
  IMPORT: 'IMPORT'
};

export type OperateType = (typeof OperateType)[keyof typeof OperateType]


export const OperateTarget: {
  BOT: 'BOT',
  PROVIDER_KEY: 'PROVIDER_KEY',
  USER: 'USER',
  PERSONA_TEMPLATE: 'PERSONA_TEMPLATE',
  SYSTEM: 'SYSTEM'
};

export type OperateTarget = (typeof OperateTarget)[keyof typeof OperateTarget]

}

export type SexType = $Enums.SexType

export const SexType: typeof $Enums.SexType

export type TaskType = $Enums.TaskType

export const TaskType: typeof $Enums.TaskType

export type TaskStatus = $Enums.TaskStatus

export const TaskStatus: typeof $Enums.TaskStatus

export type FileBucketVendor = $Enums.FileBucketVendor

export const FileBucketVendor: typeof $Enums.FileBucketVendor

export type FileEnvType = $Enums.FileEnvType

export const FileEnvType: typeof $Enums.FileEnvType

export type BotStatus = $Enums.BotStatus

export const BotStatus: typeof $Enums.BotStatus

export type OperateType = $Enums.OperateType

export const OperateType: typeof $Enums.OperateType

export type OperateTarget = $Enums.OperateTarget

export const OperateTarget: typeof $Enums.OperateTarget

/**
 * ##  Prisma Client  ≤À¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more UserInfos
 * const userInfos = await prisma.userInfo.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client  ≤À¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more UserInfos
   * const userInfos = await prisma.userInfo.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.userInfo`: Exposes CRUD operations for the **UserInfo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserInfos
    * const userInfos = await prisma.userInfo.findMany()
    * ```
    */
  get userInfo(): Prisma.UserInfoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.personaTemplate`: Exposes CRUD operations for the **PersonaTemplate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PersonaTemplates
    * const personaTemplates = await prisma.personaTemplate.findMany()
    * ```
    */
  get personaTemplate(): Prisma.PersonaTemplateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.wechatAuth`: Exposes CRUD operations for the **WechatAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more WechatAuths
    * const wechatAuths = await prisma.wechatAuth.findMany()
    * ```
    */
  get wechatAuth(): Prisma.WechatAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.googleAuth`: Exposes CRUD operations for the **GoogleAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GoogleAuths
    * const googleAuths = await prisma.googleAuth.findMany()
    * ```
    */
  get googleAuth(): Prisma.GoogleAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.discordAuth`: Exposes CRUD operations for the **DiscordAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DiscordAuths
    * const discordAuths = await prisma.discordAuth.findMany()
    * ```
    */
  get discordAuth(): Prisma.DiscordAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.mobileAuth`: Exposes CRUD operations for the **MobileAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MobileAuths
    * const mobileAuths = await prisma.mobileAuth.findMany()
    * ```
    */
  get mobileAuth(): Prisma.MobileAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailAuth`: Exposes CRUD operations for the **EmailAuth** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailAuths
    * const emailAuths = await prisma.emailAuth.findMany()
    * ```
    */
  get emailAuth(): Prisma.EmailAuthDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.riskDetectionRecord`: Exposes CRUD operations for the **RiskDetectionRecord** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RiskDetectionRecords
    * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany()
    * ```
    */
  get riskDetectionRecord(): Prisma.RiskDetectionRecordDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemTaskQueue`: Exposes CRUD operations for the **SystemTaskQueue** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemTaskQueues
    * const systemTaskQueues = await prisma.systemTaskQueue.findMany()
    * ```
    */
  get systemTaskQueue(): Prisma.SystemTaskQueueDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.fileSource`: Exposes CRUD operations for the **FileSource** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more FileSources
    * const fileSources = await prisma.fileSource.findMany()
    * ```
    */
  get fileSource(): Prisma.FileSourceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.countryCode`: Exposes CRUD operations for the **CountryCode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CountryCodes
    * const countryCodes = await prisma.countryCode.findMany()
    * ```
    */
  get countryCode(): Prisma.CountryCodeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bot`: Exposes CRUD operations for the **Bot** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bots
    * const bots = await prisma.bot.findMany()
    * ```
    */
  get bot(): Prisma.BotDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providerKey`: Exposes CRUD operations for the **ProviderKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProviderKeys
    * const providerKeys = await prisma.providerKey.findMany()
    * ```
    */
  get providerKey(): Prisma.ProviderKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botProviderKey`: Exposes CRUD operations for the **BotProviderKey** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotProviderKeys
    * const botProviderKeys = await prisma.botProviderKey.findMany()
    * ```
    */
  get botProviderKey(): Prisma.BotProviderKeyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.botUsageLog`: Exposes CRUD operations for the **BotUsageLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BotUsageLogs
    * const botUsageLogs = await prisma.botUsageLog.findMany()
    * ```
    */
  get botUsageLog(): Prisma.BotUsageLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.proxyToken`: Exposes CRUD operations for the **ProxyToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProxyTokens
    * const proxyTokens = await prisma.proxyToken.findMany()
    * ```
    */
  get proxyToken(): Prisma.ProxyTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.messageRecipient`: Exposes CRUD operations for the **MessageRecipient** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MessageRecipients
    * const messageRecipients = await prisma.messageRecipient.findMany()
    * ```
    */
  get messageRecipient(): Prisma.MessageRecipientDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.operateLog`: Exposes CRUD operations for the **OperateLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more OperateLogs
    * const operateLogs = await prisma.operateLog.findMany()
    * ```
    */
  get operateLog(): Prisma.OperateLogDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelDefinition`: Exposes CRUD operations for the **ChannelDefinition** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelDefinitions
    * const channelDefinitions = await prisma.channelDefinition.findMany()
    * ```
    */
  get channelDefinition(): Prisma.ChannelDefinitionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.channelCredentialField`: Exposes CRUD operations for the **ChannelCredentialField** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChannelCredentialFields
    * const channelCredentialFields = await prisma.channelCredentialField.findMany()
    * ```
    */
  get channelCredentialField(): Prisma.ChannelCredentialFieldDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    UserInfo: 'UserInfo',
    PersonaTemplate: 'PersonaTemplate',
    WechatAuth: 'WechatAuth',
    GoogleAuth: 'GoogleAuth',
    DiscordAuth: 'DiscordAuth',
    MobileAuth: 'MobileAuth',
    EmailAuth: 'EmailAuth',
    RiskDetectionRecord: 'RiskDetectionRecord',
    SystemTaskQueue: 'SystemTaskQueue',
    FileSource: 'FileSource',
    CountryCode: 'CountryCode',
    Bot: 'Bot',
    ProviderKey: 'ProviderKey',
    BotProviderKey: 'BotProviderKey',
    BotUsageLog: 'BotUsageLog',
    ProxyToken: 'ProxyToken',
    Message: 'Message',
    MessageRecipient: 'MessageRecipient',
    OperateLog: 'OperateLog',
    ChannelDefinition: 'ChannelDefinition',
    ChannelCredentialField: 'ChannelCredentialField'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "userInfo" | "personaTemplate" | "wechatAuth" | "googleAuth" | "discordAuth" | "mobileAuth" | "emailAuth" | "riskDetectionRecord" | "systemTaskQueue" | "fileSource" | "countryCode" | "bot" | "providerKey" | "botProviderKey" | "botUsageLog" | "proxyToken" | "message" | "messageRecipient" | "operateLog" | "channelDefinition" | "channelCredentialField"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      UserInfo: {
        payload: Prisma.$UserInfoPayload<ExtArgs>
        fields: Prisma.UserInfoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserInfoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserInfoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          findFirst: {
            args: Prisma.UserInfoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserInfoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          findMany: {
            args: Prisma.UserInfoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          create: {
            args: Prisma.UserInfoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          createMany: {
            args: Prisma.UserInfoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserInfoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          delete: {
            args: Prisma.UserInfoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          update: {
            args: Prisma.UserInfoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          deleteMany: {
            args: Prisma.UserInfoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserInfoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserInfoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>[]
          }
          upsert: {
            args: Prisma.UserInfoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserInfoPayload>
          }
          aggregate: {
            args: Prisma.UserInfoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserInfo>
          }
          groupBy: {
            args: Prisma.UserInfoGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserInfoGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserInfoCountArgs<ExtArgs>
            result: $Utils.Optional<UserInfoCountAggregateOutputType> | number
          }
        }
      }
      PersonaTemplate: {
        payload: Prisma.$PersonaTemplatePayload<ExtArgs>
        fields: Prisma.PersonaTemplateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PersonaTemplateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PersonaTemplateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          findFirst: {
            args: Prisma.PersonaTemplateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PersonaTemplateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          findMany: {
            args: Prisma.PersonaTemplateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          create: {
            args: Prisma.PersonaTemplateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          createMany: {
            args: Prisma.PersonaTemplateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PersonaTemplateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          delete: {
            args: Prisma.PersonaTemplateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          update: {
            args: Prisma.PersonaTemplateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          deleteMany: {
            args: Prisma.PersonaTemplateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PersonaTemplateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PersonaTemplateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>[]
          }
          upsert: {
            args: Prisma.PersonaTemplateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PersonaTemplatePayload>
          }
          aggregate: {
            args: Prisma.PersonaTemplateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePersonaTemplate>
          }
          groupBy: {
            args: Prisma.PersonaTemplateGroupByArgs<ExtArgs>
            result: $Utils.Optional<PersonaTemplateGroupByOutputType>[]
          }
          count: {
            args: Prisma.PersonaTemplateCountArgs<ExtArgs>
            result: $Utils.Optional<PersonaTemplateCountAggregateOutputType> | number
          }
        }
      }
      WechatAuth: {
        payload: Prisma.$WechatAuthPayload<ExtArgs>
        fields: Prisma.WechatAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.WechatAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.WechatAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          findFirst: {
            args: Prisma.WechatAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.WechatAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          findMany: {
            args: Prisma.WechatAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          create: {
            args: Prisma.WechatAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          createMany: {
            args: Prisma.WechatAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.WechatAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          delete: {
            args: Prisma.WechatAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          update: {
            args: Prisma.WechatAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          deleteMany: {
            args: Prisma.WechatAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.WechatAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.WechatAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>[]
          }
          upsert: {
            args: Prisma.WechatAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$WechatAuthPayload>
          }
          aggregate: {
            args: Prisma.WechatAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateWechatAuth>
          }
          groupBy: {
            args: Prisma.WechatAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<WechatAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.WechatAuthCountArgs<ExtArgs>
            result: $Utils.Optional<WechatAuthCountAggregateOutputType> | number
          }
        }
      }
      GoogleAuth: {
        payload: Prisma.$GoogleAuthPayload<ExtArgs>
        fields: Prisma.GoogleAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GoogleAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GoogleAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          findFirst: {
            args: Prisma.GoogleAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GoogleAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          findMany: {
            args: Prisma.GoogleAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          create: {
            args: Prisma.GoogleAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          createMany: {
            args: Prisma.GoogleAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GoogleAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          delete: {
            args: Prisma.GoogleAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          update: {
            args: Prisma.GoogleAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          deleteMany: {
            args: Prisma.GoogleAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GoogleAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GoogleAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>[]
          }
          upsert: {
            args: Prisma.GoogleAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GoogleAuthPayload>
          }
          aggregate: {
            args: Prisma.GoogleAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGoogleAuth>
          }
          groupBy: {
            args: Prisma.GoogleAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.GoogleAuthCountArgs<ExtArgs>
            result: $Utils.Optional<GoogleAuthCountAggregateOutputType> | number
          }
        }
      }
      DiscordAuth: {
        payload: Prisma.$DiscordAuthPayload<ExtArgs>
        fields: Prisma.DiscordAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DiscordAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DiscordAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          findFirst: {
            args: Prisma.DiscordAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DiscordAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          findMany: {
            args: Prisma.DiscordAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          create: {
            args: Prisma.DiscordAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          createMany: {
            args: Prisma.DiscordAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DiscordAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          delete: {
            args: Prisma.DiscordAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          update: {
            args: Prisma.DiscordAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          deleteMany: {
            args: Prisma.DiscordAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DiscordAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DiscordAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>[]
          }
          upsert: {
            args: Prisma.DiscordAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DiscordAuthPayload>
          }
          aggregate: {
            args: Prisma.DiscordAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDiscordAuth>
          }
          groupBy: {
            args: Prisma.DiscordAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<DiscordAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.DiscordAuthCountArgs<ExtArgs>
            result: $Utils.Optional<DiscordAuthCountAggregateOutputType> | number
          }
        }
      }
      MobileAuth: {
        payload: Prisma.$MobileAuthPayload<ExtArgs>
        fields: Prisma.MobileAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MobileAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MobileAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          findFirst: {
            args: Prisma.MobileAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MobileAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          findMany: {
            args: Prisma.MobileAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          create: {
            args: Prisma.MobileAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          createMany: {
            args: Prisma.MobileAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MobileAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          delete: {
            args: Prisma.MobileAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          update: {
            args: Prisma.MobileAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          deleteMany: {
            args: Prisma.MobileAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MobileAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MobileAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>[]
          }
          upsert: {
            args: Prisma.MobileAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MobileAuthPayload>
          }
          aggregate: {
            args: Prisma.MobileAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMobileAuth>
          }
          groupBy: {
            args: Prisma.MobileAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<MobileAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.MobileAuthCountArgs<ExtArgs>
            result: $Utils.Optional<MobileAuthCountAggregateOutputType> | number
          }
        }
      }
      EmailAuth: {
        payload: Prisma.$EmailAuthPayload<ExtArgs>
        fields: Prisma.EmailAuthFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailAuthFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailAuthFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          findFirst: {
            args: Prisma.EmailAuthFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailAuthFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          findMany: {
            args: Prisma.EmailAuthFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          create: {
            args: Prisma.EmailAuthCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          createMany: {
            args: Prisma.EmailAuthCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailAuthCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          delete: {
            args: Prisma.EmailAuthDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          update: {
            args: Prisma.EmailAuthUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          deleteMany: {
            args: Prisma.EmailAuthDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailAuthUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailAuthUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>[]
          }
          upsert: {
            args: Prisma.EmailAuthUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailAuthPayload>
          }
          aggregate: {
            args: Prisma.EmailAuthAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailAuth>
          }
          groupBy: {
            args: Prisma.EmailAuthGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailAuthGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailAuthCountArgs<ExtArgs>
            result: $Utils.Optional<EmailAuthCountAggregateOutputType> | number
          }
        }
      }
      RiskDetectionRecord: {
        payload: Prisma.$RiskDetectionRecordPayload<ExtArgs>
        fields: Prisma.RiskDetectionRecordFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RiskDetectionRecordFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          findFirst: {
            args: Prisma.RiskDetectionRecordFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          findMany: {
            args: Prisma.RiskDetectionRecordFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          create: {
            args: Prisma.RiskDetectionRecordCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          createMany: {
            args: Prisma.RiskDetectionRecordCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          delete: {
            args: Prisma.RiskDetectionRecordDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          update: {
            args: Prisma.RiskDetectionRecordUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          deleteMany: {
            args: Prisma.RiskDetectionRecordDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RiskDetectionRecordUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>[]
          }
          upsert: {
            args: Prisma.RiskDetectionRecordUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RiskDetectionRecordPayload>
          }
          aggregate: {
            args: Prisma.RiskDetectionRecordAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRiskDetectionRecord>
          }
          groupBy: {
            args: Prisma.RiskDetectionRecordGroupByArgs<ExtArgs>
            result: $Utils.Optional<RiskDetectionRecordGroupByOutputType>[]
          }
          count: {
            args: Prisma.RiskDetectionRecordCountArgs<ExtArgs>
            result: $Utils.Optional<RiskDetectionRecordCountAggregateOutputType> | number
          }
        }
      }
      SystemTaskQueue: {
        payload: Prisma.$SystemTaskQueuePayload<ExtArgs>
        fields: Prisma.SystemTaskQueueFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemTaskQueueFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          findFirst: {
            args: Prisma.SystemTaskQueueFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemTaskQueueFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          findMany: {
            args: Prisma.SystemTaskQueueFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          create: {
            args: Prisma.SystemTaskQueueCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          createMany: {
            args: Prisma.SystemTaskQueueCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemTaskQueueCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          delete: {
            args: Prisma.SystemTaskQueueDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          update: {
            args: Prisma.SystemTaskQueueUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          deleteMany: {
            args: Prisma.SystemTaskQueueDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemTaskQueueUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>[]
          }
          upsert: {
            args: Prisma.SystemTaskQueueUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemTaskQueuePayload>
          }
          aggregate: {
            args: Prisma.SystemTaskQueueAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemTaskQueue>
          }
          groupBy: {
            args: Prisma.SystemTaskQueueGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemTaskQueueGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemTaskQueueCountArgs<ExtArgs>
            result: $Utils.Optional<SystemTaskQueueCountAggregateOutputType> | number
          }
        }
      }
      FileSource: {
        payload: Prisma.$FileSourcePayload<ExtArgs>
        fields: Prisma.FileSourceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileSourceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileSourceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          findFirst: {
            args: Prisma.FileSourceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileSourceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          findMany: {
            args: Prisma.FileSourceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          create: {
            args: Prisma.FileSourceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          createMany: {
            args: Prisma.FileSourceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileSourceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          delete: {
            args: Prisma.FileSourceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          update: {
            args: Prisma.FileSourceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          deleteMany: {
            args: Prisma.FileSourceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileSourceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileSourceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>[]
          }
          upsert: {
            args: Prisma.FileSourceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FileSourcePayload>
          }
          aggregate: {
            args: Prisma.FileSourceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFileSource>
          }
          groupBy: {
            args: Prisma.FileSourceGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileSourceGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileSourceCountArgs<ExtArgs>
            result: $Utils.Optional<FileSourceCountAggregateOutputType> | number
          }
        }
      }
      CountryCode: {
        payload: Prisma.$CountryCodePayload<ExtArgs>
        fields: Prisma.CountryCodeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CountryCodeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CountryCodeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          findFirst: {
            args: Prisma.CountryCodeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CountryCodeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          findMany: {
            args: Prisma.CountryCodeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          create: {
            args: Prisma.CountryCodeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          createMany: {
            args: Prisma.CountryCodeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CountryCodeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          delete: {
            args: Prisma.CountryCodeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          update: {
            args: Prisma.CountryCodeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          deleteMany: {
            args: Prisma.CountryCodeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CountryCodeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.CountryCodeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>[]
          }
          upsert: {
            args: Prisma.CountryCodeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CountryCodePayload>
          }
          aggregate: {
            args: Prisma.CountryCodeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCountryCode>
          }
          groupBy: {
            args: Prisma.CountryCodeGroupByArgs<ExtArgs>
            result: $Utils.Optional<CountryCodeGroupByOutputType>[]
          }
          count: {
            args: Prisma.CountryCodeCountArgs<ExtArgs>
            result: $Utils.Optional<CountryCodeCountAggregateOutputType> | number
          }
        }
      }
      Bot: {
        payload: Prisma.$BotPayload<ExtArgs>
        fields: Prisma.BotFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findFirst: {
            args: Prisma.BotFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          findMany: {
            args: Prisma.BotFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          create: {
            args: Prisma.BotCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          createMany: {
            args: Prisma.BotCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          delete: {
            args: Prisma.BotDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          update: {
            args: Prisma.BotUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          deleteMany: {
            args: Prisma.BotDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>[]
          }
          upsert: {
            args: Prisma.BotUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotPayload>
          }
          aggregate: {
            args: Prisma.BotAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBot>
          }
          groupBy: {
            args: Prisma.BotGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotCountArgs<ExtArgs>
            result: $Utils.Optional<BotCountAggregateOutputType> | number
          }
        }
      }
      ProviderKey: {
        payload: Prisma.$ProviderKeyPayload<ExtArgs>
        fields: Prisma.ProviderKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProviderKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProviderKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          findFirst: {
            args: Prisma.ProviderKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProviderKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          findMany: {
            args: Prisma.ProviderKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          create: {
            args: Prisma.ProviderKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          createMany: {
            args: Prisma.ProviderKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProviderKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          delete: {
            args: Prisma.ProviderKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          update: {
            args: Prisma.ProviderKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          deleteMany: {
            args: Prisma.ProviderKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProviderKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProviderKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>[]
          }
          upsert: {
            args: Prisma.ProviderKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProviderKeyPayload>
          }
          aggregate: {
            args: Prisma.ProviderKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviderKey>
          }
          groupBy: {
            args: Prisma.ProviderKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProviderKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProviderKeyCountArgs<ExtArgs>
            result: $Utils.Optional<ProviderKeyCountAggregateOutputType> | number
          }
        }
      }
      BotProviderKey: {
        payload: Prisma.$BotProviderKeyPayload<ExtArgs>
        fields: Prisma.BotProviderKeyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotProviderKeyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotProviderKeyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          findFirst: {
            args: Prisma.BotProviderKeyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotProviderKeyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          findMany: {
            args: Prisma.BotProviderKeyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          create: {
            args: Prisma.BotProviderKeyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          createMany: {
            args: Prisma.BotProviderKeyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotProviderKeyCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          delete: {
            args: Prisma.BotProviderKeyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          update: {
            args: Prisma.BotProviderKeyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          deleteMany: {
            args: Prisma.BotProviderKeyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotProviderKeyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotProviderKeyUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>[]
          }
          upsert: {
            args: Prisma.BotProviderKeyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotProviderKeyPayload>
          }
          aggregate: {
            args: Prisma.BotProviderKeyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotProviderKey>
          }
          groupBy: {
            args: Prisma.BotProviderKeyGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotProviderKeyGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotProviderKeyCountArgs<ExtArgs>
            result: $Utils.Optional<BotProviderKeyCountAggregateOutputType> | number
          }
        }
      }
      BotUsageLog: {
        payload: Prisma.$BotUsageLogPayload<ExtArgs>
        fields: Prisma.BotUsageLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BotUsageLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BotUsageLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          findFirst: {
            args: Prisma.BotUsageLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BotUsageLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          findMany: {
            args: Prisma.BotUsageLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          create: {
            args: Prisma.BotUsageLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          createMany: {
            args: Prisma.BotUsageLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BotUsageLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          delete: {
            args: Prisma.BotUsageLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          update: {
            args: Prisma.BotUsageLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          deleteMany: {
            args: Prisma.BotUsageLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BotUsageLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BotUsageLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>[]
          }
          upsert: {
            args: Prisma.BotUsageLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BotUsageLogPayload>
          }
          aggregate: {
            args: Prisma.BotUsageLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBotUsageLog>
          }
          groupBy: {
            args: Prisma.BotUsageLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<BotUsageLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.BotUsageLogCountArgs<ExtArgs>
            result: $Utils.Optional<BotUsageLogCountAggregateOutputType> | number
          }
        }
      }
      ProxyToken: {
        payload: Prisma.$ProxyTokenPayload<ExtArgs>
        fields: Prisma.ProxyTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProxyTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProxyTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          findFirst: {
            args: Prisma.ProxyTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProxyTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          findMany: {
            args: Prisma.ProxyTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          create: {
            args: Prisma.ProxyTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          createMany: {
            args: Prisma.ProxyTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProxyTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          delete: {
            args: Prisma.ProxyTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          update: {
            args: Prisma.ProxyTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          deleteMany: {
            args: Prisma.ProxyTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProxyTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProxyTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>[]
          }
          upsert: {
            args: Prisma.ProxyTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProxyTokenPayload>
          }
          aggregate: {
            args: Prisma.ProxyTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProxyToken>
          }
          groupBy: {
            args: Prisma.ProxyTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProxyTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProxyTokenCountArgs<ExtArgs>
            result: $Utils.Optional<ProxyTokenCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      MessageRecipient: {
        payload: Prisma.$MessageRecipientPayload<ExtArgs>
        fields: Prisma.MessageRecipientFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageRecipientFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageRecipientFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          findFirst: {
            args: Prisma.MessageRecipientFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageRecipientFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          findMany: {
            args: Prisma.MessageRecipientFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          create: {
            args: Prisma.MessageRecipientCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          createMany: {
            args: Prisma.MessageRecipientCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageRecipientCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          delete: {
            args: Prisma.MessageRecipientDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          update: {
            args: Prisma.MessageRecipientUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          deleteMany: {
            args: Prisma.MessageRecipientDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageRecipientUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageRecipientUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>[]
          }
          upsert: {
            args: Prisma.MessageRecipientUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessageRecipientPayload>
          }
          aggregate: {
            args: Prisma.MessageRecipientAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessageRecipient>
          }
          groupBy: {
            args: Prisma.MessageRecipientGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageRecipientGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageRecipientCountArgs<ExtArgs>
            result: $Utils.Optional<MessageRecipientCountAggregateOutputType> | number
          }
        }
      }
      OperateLog: {
        payload: Prisma.$OperateLogPayload<ExtArgs>
        fields: Prisma.OperateLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OperateLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OperateLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          findFirst: {
            args: Prisma.OperateLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OperateLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          findMany: {
            args: Prisma.OperateLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          create: {
            args: Prisma.OperateLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          createMany: {
            args: Prisma.OperateLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.OperateLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          delete: {
            args: Prisma.OperateLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          update: {
            args: Prisma.OperateLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          deleteMany: {
            args: Prisma.OperateLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.OperateLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.OperateLogUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>[]
          }
          upsert: {
            args: Prisma.OperateLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$OperateLogPayload>
          }
          aggregate: {
            args: Prisma.OperateLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateOperateLog>
          }
          groupBy: {
            args: Prisma.OperateLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<OperateLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.OperateLogCountArgs<ExtArgs>
            result: $Utils.Optional<OperateLogCountAggregateOutputType> | number
          }
        }
      }
      ChannelDefinition: {
        payload: Prisma.$ChannelDefinitionPayload<ExtArgs>
        fields: Prisma.ChannelDefinitionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelDefinitionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          findFirst: {
            args: Prisma.ChannelDefinitionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelDefinitionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          findMany: {
            args: Prisma.ChannelDefinitionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          create: {
            args: Prisma.ChannelDefinitionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          createMany: {
            args: Prisma.ChannelDefinitionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelDefinitionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          delete: {
            args: Prisma.ChannelDefinitionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          update: {
            args: Prisma.ChannelDefinitionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          deleteMany: {
            args: Prisma.ChannelDefinitionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelDefinitionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>[]
          }
          upsert: {
            args: Prisma.ChannelDefinitionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelDefinitionPayload>
          }
          aggregate: {
            args: Prisma.ChannelDefinitionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelDefinition>
          }
          groupBy: {
            args: Prisma.ChannelDefinitionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelDefinitionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelDefinitionCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelDefinitionCountAggregateOutputType> | number
          }
        }
      }
      ChannelCredentialField: {
        payload: Prisma.$ChannelCredentialFieldPayload<ExtArgs>
        fields: Prisma.ChannelCredentialFieldFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChannelCredentialFieldFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          findFirst: {
            args: Prisma.ChannelCredentialFieldFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          findMany: {
            args: Prisma.ChannelCredentialFieldFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          create: {
            args: Prisma.ChannelCredentialFieldCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          createMany: {
            args: Prisma.ChannelCredentialFieldCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          delete: {
            args: Prisma.ChannelCredentialFieldDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          update: {
            args: Prisma.ChannelCredentialFieldUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          deleteMany: {
            args: Prisma.ChannelCredentialFieldDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChannelCredentialFieldUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>[]
          }
          upsert: {
            args: Prisma.ChannelCredentialFieldUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChannelCredentialFieldPayload>
          }
          aggregate: {
            args: Prisma.ChannelCredentialFieldAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChannelCredentialField>
          }
          groupBy: {
            args: Prisma.ChannelCredentialFieldGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChannelCredentialFieldGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChannelCredentialFieldCountArgs<ExtArgs>
            result: $Utils.Optional<ChannelCredentialFieldCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    userInfo?: UserInfoOmit
    personaTemplate?: PersonaTemplateOmit
    wechatAuth?: WechatAuthOmit
    googleAuth?: GoogleAuthOmit
    discordAuth?: DiscordAuthOmit
    mobileAuth?: MobileAuthOmit
    emailAuth?: EmailAuthOmit
    riskDetectionRecord?: RiskDetectionRecordOmit
    systemTaskQueue?: SystemTaskQueueOmit
    fileSource?: FileSourceOmit
    countryCode?: CountryCodeOmit
    bot?: BotOmit
    providerKey?: ProviderKeyOmit
    botProviderKey?: BotProviderKeyOmit
    botUsageLog?: BotUsageLogOmit
    proxyToken?: ProxyTokenOmit
    message?: MessageOmit
    messageRecipient?: MessageRecipientOmit
    operateLog?: OperateLogOmit
    channelDefinition?: ChannelDefinitionOmit
    channelCredentialField?: ChannelCredentialFieldOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserInfoCountOutputType
   */

  export type UserInfoCountOutputType = {
    sentMessages: number
    receivedMessages: number
    bots: number
    providerKeys: number
    personaTemplates: number
    operateLogs: number
  }

  export type UserInfoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sentMessages?: boolean | UserInfoCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserInfoCountOutputTypeCountReceivedMessagesArgs
    bots?: boolean | UserInfoCountOutputTypeCountBotsArgs
    providerKeys?: boolean | UserInfoCountOutputTypeCountProviderKeysArgs
    personaTemplates?: boolean | UserInfoCountOutputTypeCountPersonaTemplatesArgs
    operateLogs?: boolean | UserInfoCountOutputTypeCountOperateLogsArgs
  }

  // Custom InputTypes
  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfoCountOutputType
     */
    select?: UserInfoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderKeyWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountPersonaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
  }

  /**
   * UserInfoCountOutputType without action
   */
  export type UserInfoCountOutputTypeCountOperateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperateLogWhereInput
  }


  /**
   * Count Type PersonaTemplateCountOutputType
   */

  export type PersonaTemplateCountOutputType = {
    bots: number
  }

  export type PersonaTemplateCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bots?: boolean | PersonaTemplateCountOutputTypeCountBotsArgs
  }

  // Custom InputTypes
  /**
   * PersonaTemplateCountOutputType without action
   */
  export type PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplateCountOutputType
     */
    select?: PersonaTemplateCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PersonaTemplateCountOutputType without action
   */
  export type PersonaTemplateCountOutputTypeCountBotsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }


  /**
   * Count Type FileSourceCountOutputType
   */

  export type FileSourceCountOutputType = {
    userAvatars: number
    personaTemplates: number
    botAvatars: number
  }

  export type FileSourceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAvatars?: boolean | FileSourceCountOutputTypeCountUserAvatarsArgs
    personaTemplates?: boolean | FileSourceCountOutputTypeCountPersonaTemplatesArgs
    botAvatars?: boolean | FileSourceCountOutputTypeCountBotAvatarsArgs
  }

  // Custom InputTypes
  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSourceCountOutputType
     */
    select?: FileSourceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountUserAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInfoWhereInput
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountPersonaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
  }

  /**
   * FileSourceCountOutputType without action
   */
  export type FileSourceCountOutputTypeCountBotAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
  }


  /**
   * Count Type BotCountOutputType
   */

  export type BotCountOutputType = {
    providerKeys: number
    usageLogs: number
  }

  export type BotCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    providerKeys?: boolean | BotCountOutputTypeCountProviderKeysArgs
    usageLogs?: boolean | BotCountOutputTypeCountUsageLogsArgs
  }

  // Custom InputTypes
  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotCountOutputType
     */
    select?: BotCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
  }

  /**
   * BotCountOutputType without action
   */
  export type BotCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
  }


  /**
   * Count Type ProviderKeyCountOutputType
   */

  export type ProviderKeyCountOutputType = {
    botProviderKeys: number
    usageLogs: number
    proxyTokens: number
  }

  export type ProviderKeyCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    botProviderKeys?: boolean | ProviderKeyCountOutputTypeCountBotProviderKeysArgs
    usageLogs?: boolean | ProviderKeyCountOutputTypeCountUsageLogsArgs
    proxyTokens?: boolean | ProviderKeyCountOutputTypeCountProxyTokensArgs
  }

  // Custom InputTypes
  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKeyCountOutputType
     */
    select?: ProviderKeyCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountBotProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountUsageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
  }

  /**
   * ProviderKeyCountOutputType without action
   */
  export type ProviderKeyCountOutputTypeCountProxyTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyTokenWhereInput
  }


  /**
   * Count Type MessageCountOutputType
   */

  export type MessageCountOutputType = {
    recipients: number
  }

  export type MessageCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    recipients?: boolean | MessageCountOutputTypeCountRecipientsArgs
  }

  // Custom InputTypes
  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageCountOutputType
     */
    select?: MessageCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * MessageCountOutputType without action
   */
  export type MessageCountOutputTypeCountRecipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
  }


  /**
   * Count Type ChannelDefinitionCountOutputType
   */

  export type ChannelDefinitionCountOutputType = {
    credentialFields: number
  }

  export type ChannelDefinitionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credentialFields?: boolean | ChannelDefinitionCountOutputTypeCountCredentialFieldsArgs
  }

  // Custom InputTypes
  /**
   * ChannelDefinitionCountOutputType without action
   */
  export type ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinitionCountOutputType
     */
    select?: ChannelDefinitionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChannelDefinitionCountOutputType without action
   */
  export type ChannelDefinitionCountOutputTypeCountCredentialFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCredentialFieldWhereInput
  }


  /**
   * Models
   */

  /**
   * Model UserInfo
   */

  export type AggregateUserInfo = {
    _count: UserInfoCountAggregateOutputType | null
    _min: UserInfoMinAggregateOutputType | null
    _max: UserInfoMaxAggregateOutputType | null
  }

  export type UserInfoMinAggregateOutputType = {
    id: string | null
    nickname: string | null
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType | null
    locale: string | null
    isAnonymity: boolean | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
  }

  export type UserInfoMaxAggregateOutputType = {
    id: string | null
    nickname: string | null
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType | null
    locale: string | null
    isAnonymity: boolean | null
    isAdmin: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
  }

  export type UserInfoCountAggregateOutputType = {
    id: number
    nickname: number
    code: number
    avatarFileId: number
    sex: number
    locale: number
    isAnonymity: number
    isAdmin: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    deviceId: number
    wechatOpenid: number
    wechatUnionId: number
    googleSub: number
    discordId: number
    mobile: number
    email: number
    _all: number
  }


  export type UserInfoMinAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
  }

  export type UserInfoMaxAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
  }

  export type UserInfoCountAggregateInputType = {
    id?: true
    nickname?: true
    code?: true
    avatarFileId?: true
    sex?: true
    locale?: true
    isAnonymity?: true
    isAdmin?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    deviceId?: true
    wechatOpenid?: true
    wechatUnionId?: true
    googleSub?: true
    discordId?: true
    mobile?: true
    email?: true
    _all?: true
  }

  export type UserInfoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInfo to aggregate.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserInfos
    **/
    _count?: true | UserInfoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserInfoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserInfoMaxAggregateInputType
  }

  export type GetUserInfoAggregateType<T extends UserInfoAggregateArgs> = {
        [P in keyof T & keyof AggregateUserInfo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserInfo[P]>
      : GetScalarType<T[P], AggregateUserInfo[P]>
  }




  export type UserInfoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserInfoWhereInput
    orderBy?: UserInfoOrderByWithAggregationInput | UserInfoOrderByWithAggregationInput[]
    by: UserInfoScalarFieldEnum[] | UserInfoScalarFieldEnum
    having?: UserInfoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserInfoCountAggregateInputType | true
    _min?: UserInfoMinAggregateInputType
    _max?: UserInfoMaxAggregateInputType
  }

  export type UserInfoGroupByOutputType = {
    id: string
    nickname: string
    code: string | null
    avatarFileId: string | null
    sex: $Enums.SexType
    locale: string | null
    isAnonymity: boolean
    isAdmin: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    deviceId: string | null
    wechatOpenid: string | null
    wechatUnionId: string | null
    googleSub: string | null
    discordId: string | null
    mobile: string | null
    email: string | null
    _count: UserInfoCountAggregateOutputType | null
    _min: UserInfoMinAggregateOutputType | null
    _max: UserInfoMaxAggregateOutputType | null
  }

  type GetUserInfoGroupByPayload<T extends UserInfoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserInfoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserInfoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserInfoGroupByOutputType[P]>
            : GetScalarType<T[P], UserInfoGroupByOutputType[P]>
        }
      >
    >


  export type UserInfoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
    wechatAuth?: boolean | UserInfo$wechatAuthArgs<ExtArgs>
    googleAuth?: boolean | UserInfo$googleAuthArgs<ExtArgs>
    discordAuth?: boolean | UserInfo$discordAuthArgs<ExtArgs>
    mobileAuth?: boolean | UserInfo$mobileAuthArgs<ExtArgs>
    emailAuth?: boolean | UserInfo$emailAuthArgs<ExtArgs>
    sentMessages?: boolean | UserInfo$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | UserInfo$receivedMessagesArgs<ExtArgs>
    bots?: boolean | UserInfo$botsArgs<ExtArgs>
    providerKeys?: boolean | UserInfo$providerKeysArgs<ExtArgs>
    personaTemplates?: boolean | UserInfo$personaTemplatesArgs<ExtArgs>
    operateLogs?: boolean | UserInfo$operateLogsArgs<ExtArgs>
    _count?: boolean | UserInfoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["userInfo"]>

  export type UserInfoSelectScalar = {
    id?: boolean
    nickname?: boolean
    code?: boolean
    avatarFileId?: boolean
    sex?: boolean
    locale?: boolean
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    deviceId?: boolean
    wechatOpenid?: boolean
    wechatUnionId?: boolean
    googleSub?: boolean
    discordId?: boolean
    mobile?: boolean
    email?: boolean
  }

  export type UserInfoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "nickname" | "code" | "avatarFileId" | "sex" | "locale" | "isAnonymity" | "isAdmin" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt" | "deviceId" | "wechatOpenid" | "wechatUnionId" | "googleSub" | "discordId" | "mobile" | "email", ExtArgs["result"]["userInfo"]>
  export type UserInfoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
    wechatAuth?: boolean | UserInfo$wechatAuthArgs<ExtArgs>
    googleAuth?: boolean | UserInfo$googleAuthArgs<ExtArgs>
    discordAuth?: boolean | UserInfo$discordAuthArgs<ExtArgs>
    mobileAuth?: boolean | UserInfo$mobileAuthArgs<ExtArgs>
    emailAuth?: boolean | UserInfo$emailAuthArgs<ExtArgs>
    sentMessages?: boolean | UserInfo$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | UserInfo$receivedMessagesArgs<ExtArgs>
    bots?: boolean | UserInfo$botsArgs<ExtArgs>
    providerKeys?: boolean | UserInfo$providerKeysArgs<ExtArgs>
    personaTemplates?: boolean | UserInfo$personaTemplatesArgs<ExtArgs>
    operateLogs?: boolean | UserInfo$operateLogsArgs<ExtArgs>
    _count?: boolean | UserInfoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserInfoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }
  export type UserInfoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    avatarFile?: boolean | UserInfo$avatarFileArgs<ExtArgs>
  }

  export type $UserInfoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserInfo"
    objects: {
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      wechatAuth: Prisma.$WechatAuthPayload<ExtArgs> | null
      googleAuth: Prisma.$GoogleAuthPayload<ExtArgs> | null
      discordAuth: Prisma.$DiscordAuthPayload<ExtArgs> | null
      mobileAuth: Prisma.$MobileAuthPayload<ExtArgs> | null
      emailAuth: Prisma.$EmailAuthPayload<ExtArgs> | null
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessageRecipientPayload<ExtArgs>[]
      bots: Prisma.$BotPayload<ExtArgs>[]
      providerKeys: Prisma.$ProviderKeyPayload<ExtArgs>[]
      personaTemplates: Prisma.$PersonaTemplatePayload<ExtArgs>[]
      operateLogs: Prisma.$OperateLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nickname: string
      code: string | null
      avatarFileId: string | null
      sex: $Enums.SexType
      locale: string | null
      isAnonymity: boolean
      isAdmin: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
      deviceId: string | null
      wechatOpenid: string | null
      wechatUnionId: string | null
      googleSub: string | null
      discordId: string | null
      mobile: string | null
      email: string | null
    }, ExtArgs["result"]["userInfo"]>
    composites: {}
  }

  type UserInfoGetPayload<S extends boolean | null | undefined | UserInfoDefaultArgs> = $Result.GetResult<Prisma.$UserInfoPayload, S>

  type UserInfoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserInfoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserInfoCountAggregateInputType | true
    }

  export interface UserInfoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserInfo'], meta: { name: 'UserInfo' } }
    /**
     * Find zero or one UserInfo that matches the filter.
     * @param {UserInfoFindUniqueArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserInfoFindUniqueArgs>(args: SelectSubset<T, UserInfoFindUniqueArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserInfo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserInfoFindUniqueOrThrowArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserInfoFindUniqueOrThrowArgs>(args: SelectSubset<T, UserInfoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInfo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindFirstArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserInfoFindFirstArgs>(args?: SelectSubset<T, UserInfoFindFirstArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserInfo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindFirstOrThrowArgs} args - Arguments to find a UserInfo
     * @example
     * // Get one UserInfo
     * const userInfo = await prisma.userInfo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserInfoFindFirstOrThrowArgs>(args?: SelectSubset<T, UserInfoFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserInfos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserInfos
     * const userInfos = await prisma.userInfo.findMany()
     * 
     * // Get first 10 UserInfos
     * const userInfos = await prisma.userInfo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserInfoFindManyArgs>(args?: SelectSubset<T, UserInfoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserInfo.
     * @param {UserInfoCreateArgs} args - Arguments to create a UserInfo.
     * @example
     * // Create one UserInfo
     * const UserInfo = await prisma.userInfo.create({
     *   data: {
     *     // ... data to create a UserInfo
     *   }
     * })
     * 
     */
    create<T extends UserInfoCreateArgs>(args: SelectSubset<T, UserInfoCreateArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserInfos.
     * @param {UserInfoCreateManyArgs} args - Arguments to create many UserInfos.
     * @example
     * // Create many UserInfos
     * const userInfo = await prisma.userInfo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserInfoCreateManyArgs>(args?: SelectSubset<T, UserInfoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserInfos and returns the data saved in the database.
     * @param {UserInfoCreateManyAndReturnArgs} args - Arguments to create many UserInfos.
     * @example
     * // Create many UserInfos
     * const userInfo = await prisma.userInfo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserInfos and only return the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserInfoCreateManyAndReturnArgs>(args?: SelectSubset<T, UserInfoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserInfo.
     * @param {UserInfoDeleteArgs} args - Arguments to delete one UserInfo.
     * @example
     * // Delete one UserInfo
     * const UserInfo = await prisma.userInfo.delete({
     *   where: {
     *     // ... filter to delete one UserInfo
     *   }
     * })
     * 
     */
    delete<T extends UserInfoDeleteArgs>(args: SelectSubset<T, UserInfoDeleteArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserInfo.
     * @param {UserInfoUpdateArgs} args - Arguments to update one UserInfo.
     * @example
     * // Update one UserInfo
     * const userInfo = await prisma.userInfo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserInfoUpdateArgs>(args: SelectSubset<T, UserInfoUpdateArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserInfos.
     * @param {UserInfoDeleteManyArgs} args - Arguments to filter UserInfos to delete.
     * @example
     * // Delete a few UserInfos
     * const { count } = await prisma.userInfo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserInfoDeleteManyArgs>(args?: SelectSubset<T, UserInfoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserInfos
     * const userInfo = await prisma.userInfo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserInfoUpdateManyArgs>(args: SelectSubset<T, UserInfoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserInfos and returns the data updated in the database.
     * @param {UserInfoUpdateManyAndReturnArgs} args - Arguments to update many UserInfos.
     * @example
     * // Update many UserInfos
     * const userInfo = await prisma.userInfo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserInfos and only return the `id`
     * const userInfoWithIdOnly = await prisma.userInfo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserInfoUpdateManyAndReturnArgs>(args: SelectSubset<T, UserInfoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserInfo.
     * @param {UserInfoUpsertArgs} args - Arguments to update or create a UserInfo.
     * @example
     * // Update or create a UserInfo
     * const userInfo = await prisma.userInfo.upsert({
     *   create: {
     *     // ... data to create a UserInfo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserInfo we want to update
     *   }
     * })
     */
    upsert<T extends UserInfoUpsertArgs>(args: SelectSubset<T, UserInfoUpsertArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserInfos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoCountArgs} args - Arguments to filter UserInfos to count.
     * @example
     * // Count the number of UserInfos
     * const count = await prisma.userInfo.count({
     *   where: {
     *     // ... the filter for the UserInfos we want to count
     *   }
     * })
    **/
    count<T extends UserInfoCountArgs>(
      args?: Subset<T, UserInfoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserInfoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserInfoAggregateArgs>(args: Subset<T, UserInfoAggregateArgs>): Prisma.PrismaPromise<GetUserInfoAggregateType<T>>

    /**
     * Group by UserInfo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserInfoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserInfoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserInfoGroupByArgs['orderBy'] }
        : { orderBy?: UserInfoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserInfoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserInfoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserInfo model
   */
  readonly fields: UserInfoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserInfo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserInfoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    avatarFile<T extends UserInfo$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    wechatAuth<T extends UserInfo$wechatAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$wechatAuthArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    googleAuth<T extends UserInfo$googleAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$googleAuthArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    discordAuth<T extends UserInfo$discordAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$discordAuthArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    mobileAuth<T extends UserInfo$mobileAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$mobileAuthArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    emailAuth<T extends UserInfo$emailAuthArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$emailAuthArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    sentMessages<T extends UserInfo$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends UserInfo$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bots<T extends UserInfo$botsArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$botsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providerKeys<T extends UserInfo$providerKeysArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$providerKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personaTemplates<T extends UserInfo$personaTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$personaTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    operateLogs<T extends UserInfo$operateLogsArgs<ExtArgs> = {}>(args?: Subset<T, UserInfo$operateLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserInfo model
   */
  interface UserInfoFieldRefs {
    readonly id: FieldRef<"UserInfo", 'String'>
    readonly nickname: FieldRef<"UserInfo", 'String'>
    readonly code: FieldRef<"UserInfo", 'String'>
    readonly avatarFileId: FieldRef<"UserInfo", 'String'>
    readonly sex: FieldRef<"UserInfo", 'SexType'>
    readonly locale: FieldRef<"UserInfo", 'String'>
    readonly isAnonymity: FieldRef<"UserInfo", 'Boolean'>
    readonly isAdmin: FieldRef<"UserInfo", 'Boolean'>
    readonly isDeleted: FieldRef<"UserInfo", 'Boolean'>
    readonly createdAt: FieldRef<"UserInfo", 'DateTime'>
    readonly updatedAt: FieldRef<"UserInfo", 'DateTime'>
    readonly deletedAt: FieldRef<"UserInfo", 'DateTime'>
    readonly deviceId: FieldRef<"UserInfo", 'String'>
    readonly wechatOpenid: FieldRef<"UserInfo", 'String'>
    readonly wechatUnionId: FieldRef<"UserInfo", 'String'>
    readonly googleSub: FieldRef<"UserInfo", 'String'>
    readonly discordId: FieldRef<"UserInfo", 'String'>
    readonly mobile: FieldRef<"UserInfo", 'String'>
    readonly email: FieldRef<"UserInfo", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserInfo findUnique
   */
  export type UserInfoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo findUniqueOrThrow
   */
  export type UserInfoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo findFirst
   */
  export type UserInfoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInfos.
     */
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo findFirstOrThrow
   */
  export type UserInfoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfo to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserInfos.
     */
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo findMany
   */
  export type UserInfoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter, which UserInfos to fetch.
     */
    where?: UserInfoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserInfos to fetch.
     */
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserInfos.
     */
    cursor?: UserInfoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` UserInfos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserInfos.
     */
    skip?: number
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * UserInfo create
   */
  export type UserInfoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The data needed to create a UserInfo.
     */
    data: XOR<UserInfoCreateInput, UserInfoUncheckedCreateInput>
  }

  /**
   * UserInfo createMany
   */
  export type UserInfoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserInfos.
     */
    data: UserInfoCreateManyInput | UserInfoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserInfo createManyAndReturn
   */
  export type UserInfoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * The data used to create many UserInfos.
     */
    data: UserInfoCreateManyInput | UserInfoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInfo update
   */
  export type UserInfoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The data needed to update a UserInfo.
     */
    data: XOR<UserInfoUpdateInput, UserInfoUncheckedUpdateInput>
    /**
     * Choose, which UserInfo to update.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo updateMany
   */
  export type UserInfoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserInfos.
     */
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyInput>
    /**
     * Filter which UserInfos to update
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to update.
     */
    limit?: number
  }

  /**
   * UserInfo updateManyAndReturn
   */
  export type UserInfoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * The data used to update UserInfos.
     */
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyInput>
    /**
     * Filter which UserInfos to update
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserInfo upsert
   */
  export type UserInfoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * The filter to search for the UserInfo to update in case it exists.
     */
    where: UserInfoWhereUniqueInput
    /**
     * In case the UserInfo found by the `where` argument doesn't exist, create a new UserInfo with this data.
     */
    create: XOR<UserInfoCreateInput, UserInfoUncheckedCreateInput>
    /**
     * In case the UserInfo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserInfoUpdateInput, UserInfoUncheckedUpdateInput>
  }

  /**
   * UserInfo delete
   */
  export type UserInfoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    /**
     * Filter which UserInfo to delete.
     */
    where: UserInfoWhereUniqueInput
  }

  /**
   * UserInfo deleteMany
   */
  export type UserInfoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserInfos to delete
     */
    where?: UserInfoWhereInput
    /**
     * Limit how many UserInfos to delete.
     */
    limit?: number
  }

  /**
   * UserInfo.avatarFile
   */
  export type UserInfo$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * UserInfo.wechatAuth
   */
  export type UserInfo$wechatAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    where?: WechatAuthWhereInput
  }

  /**
   * UserInfo.googleAuth
   */
  export type UserInfo$googleAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    where?: GoogleAuthWhereInput
  }

  /**
   * UserInfo.discordAuth
   */
  export type UserInfo$discordAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    where?: DiscordAuthWhereInput
  }

  /**
   * UserInfo.mobileAuth
   */
  export type UserInfo$mobileAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    where?: MobileAuthWhereInput
  }

  /**
   * UserInfo.emailAuth
   */
  export type UserInfo$emailAuthArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    where?: EmailAuthWhereInput
  }

  /**
   * UserInfo.sentMessages
   */
  export type UserInfo$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * UserInfo.receivedMessages
   */
  export type UserInfo$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    cursor?: MessageRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * UserInfo.bots
   */
  export type UserInfo$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * UserInfo.providerKeys
   */
  export type UserInfo$providerKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    where?: ProviderKeyWhereInput
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    cursor?: ProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * UserInfo.personaTemplates
   */
  export type UserInfo$personaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    cursor?: PersonaTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * UserInfo.operateLogs
   */
  export type UserInfo$operateLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    where?: OperateLogWhereInput
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    cursor?: OperateLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * UserInfo without action
   */
  export type UserInfoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
  }


  /**
   * Model PersonaTemplate
   */

  export type AggregatePersonaTemplate = {
    _count: PersonaTemplateCountAggregateOutputType | null
    _min: PersonaTemplateMinAggregateOutputType | null
    _max: PersonaTemplateMaxAggregateOutputType | null
  }

  export type PersonaTemplateMinAggregateOutputType = {
    id: string | null
    name: string | null
    emoji: string | null
    avatarFileId: string | null
    tagline: string | null
    soulMarkdown: string | null
    soulPreview: string | null
    isSystem: boolean | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonaTemplateMaxAggregateOutputType = {
    id: string | null
    name: string | null
    emoji: string | null
    avatarFileId: string | null
    tagline: string | null
    soulMarkdown: string | null
    soulPreview: string | null
    isSystem: boolean | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type PersonaTemplateCountAggregateOutputType = {
    id: number
    name: number
    emoji: number
    avatarFileId: number
    tagline: number
    soulMarkdown: number
    soulPreview: number
    isSystem: number
    createdById: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type PersonaTemplateMinAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonaTemplateMaxAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type PersonaTemplateCountAggregateInputType = {
    id?: true
    name?: true
    emoji?: true
    avatarFileId?: true
    tagline?: true
    soulMarkdown?: true
    soulPreview?: true
    isSystem?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type PersonaTemplateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonaTemplate to aggregate.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PersonaTemplates
    **/
    _count?: true | PersonaTemplateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PersonaTemplateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PersonaTemplateMaxAggregateInputType
  }

  export type GetPersonaTemplateAggregateType<T extends PersonaTemplateAggregateArgs> = {
        [P in keyof T & keyof AggregatePersonaTemplate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePersonaTemplate[P]>
      : GetScalarType<T[P], AggregatePersonaTemplate[P]>
  }




  export type PersonaTemplateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithAggregationInput | PersonaTemplateOrderByWithAggregationInput[]
    by: PersonaTemplateScalarFieldEnum[] | PersonaTemplateScalarFieldEnum
    having?: PersonaTemplateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PersonaTemplateCountAggregateInputType | true
    _min?: PersonaTemplateMinAggregateInputType
    _max?: PersonaTemplateMaxAggregateInputType
  }

  export type PersonaTemplateGroupByOutputType = {
    id: string
    name: string
    emoji: string | null
    avatarFileId: string | null
    tagline: string
    soulMarkdown: string
    soulPreview: string | null
    isSystem: boolean
    createdById: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: PersonaTemplateCountAggregateOutputType | null
    _min: PersonaTemplateMinAggregateOutputType | null
    _max: PersonaTemplateMaxAggregateOutputType | null
  }

  type GetPersonaTemplateGroupByPayload<T extends PersonaTemplateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PersonaTemplateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PersonaTemplateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PersonaTemplateGroupByOutputType[P]>
            : GetScalarType<T[P], PersonaTemplateGroupByOutputType[P]>
        }
      >
    >


  export type PersonaTemplateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
    bots?: boolean | PersonaTemplate$botsArgs<ExtArgs>
    _count?: boolean | PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["personaTemplate"]>

  export type PersonaTemplateSelectScalar = {
    id?: boolean
    name?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    tagline?: boolean
    soulMarkdown?: boolean
    soulPreview?: boolean
    isSystem?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type PersonaTemplateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "emoji" | "avatarFileId" | "tagline" | "soulMarkdown" | "soulPreview" | "isSystem" | "createdById" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["personaTemplate"]>
  export type PersonaTemplateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
    bots?: boolean | PersonaTemplate$botsArgs<ExtArgs>
    _count?: boolean | PersonaTemplateCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PersonaTemplateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }
  export type PersonaTemplateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | PersonaTemplate$createdByArgs<ExtArgs>
    avatarFile?: boolean | PersonaTemplate$avatarFileArgs<ExtArgs>
  }

  export type $PersonaTemplatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PersonaTemplate"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs> | null
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      bots: Prisma.$BotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      emoji: string | null
      avatarFileId: string | null
      tagline: string
      soulMarkdown: string
      soulPreview: string | null
      isSystem: boolean
      createdById: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["personaTemplate"]>
    composites: {}
  }

  type PersonaTemplateGetPayload<S extends boolean | null | undefined | PersonaTemplateDefaultArgs> = $Result.GetResult<Prisma.$PersonaTemplatePayload, S>

  type PersonaTemplateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PersonaTemplateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PersonaTemplateCountAggregateInputType | true
    }

  export interface PersonaTemplateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PersonaTemplate'], meta: { name: 'PersonaTemplate' } }
    /**
     * Find zero or one PersonaTemplate that matches the filter.
     * @param {PersonaTemplateFindUniqueArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PersonaTemplateFindUniqueArgs>(args: SelectSubset<T, PersonaTemplateFindUniqueArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PersonaTemplate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PersonaTemplateFindUniqueOrThrowArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PersonaTemplateFindUniqueOrThrowArgs>(args: SelectSubset<T, PersonaTemplateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonaTemplate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindFirstArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PersonaTemplateFindFirstArgs>(args?: SelectSubset<T, PersonaTemplateFindFirstArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PersonaTemplate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindFirstOrThrowArgs} args - Arguments to find a PersonaTemplate
     * @example
     * // Get one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PersonaTemplateFindFirstOrThrowArgs>(args?: SelectSubset<T, PersonaTemplateFindFirstOrThrowArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PersonaTemplates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PersonaTemplates
     * const personaTemplates = await prisma.personaTemplate.findMany()
     * 
     * // Get first 10 PersonaTemplates
     * const personaTemplates = await prisma.personaTemplate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PersonaTemplateFindManyArgs>(args?: SelectSubset<T, PersonaTemplateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PersonaTemplate.
     * @param {PersonaTemplateCreateArgs} args - Arguments to create a PersonaTemplate.
     * @example
     * // Create one PersonaTemplate
     * const PersonaTemplate = await prisma.personaTemplate.create({
     *   data: {
     *     // ... data to create a PersonaTemplate
     *   }
     * })
     * 
     */
    create<T extends PersonaTemplateCreateArgs>(args: SelectSubset<T, PersonaTemplateCreateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PersonaTemplates.
     * @param {PersonaTemplateCreateManyArgs} args - Arguments to create many PersonaTemplates.
     * @example
     * // Create many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PersonaTemplateCreateManyArgs>(args?: SelectSubset<T, PersonaTemplateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PersonaTemplates and returns the data saved in the database.
     * @param {PersonaTemplateCreateManyAndReturnArgs} args - Arguments to create many PersonaTemplates.
     * @example
     * // Create many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PersonaTemplates and only return the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PersonaTemplateCreateManyAndReturnArgs>(args?: SelectSubset<T, PersonaTemplateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PersonaTemplate.
     * @param {PersonaTemplateDeleteArgs} args - Arguments to delete one PersonaTemplate.
     * @example
     * // Delete one PersonaTemplate
     * const PersonaTemplate = await prisma.personaTemplate.delete({
     *   where: {
     *     // ... filter to delete one PersonaTemplate
     *   }
     * })
     * 
     */
    delete<T extends PersonaTemplateDeleteArgs>(args: SelectSubset<T, PersonaTemplateDeleteArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PersonaTemplate.
     * @param {PersonaTemplateUpdateArgs} args - Arguments to update one PersonaTemplate.
     * @example
     * // Update one PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PersonaTemplateUpdateArgs>(args: SelectSubset<T, PersonaTemplateUpdateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PersonaTemplates.
     * @param {PersonaTemplateDeleteManyArgs} args - Arguments to filter PersonaTemplates to delete.
     * @example
     * // Delete a few PersonaTemplates
     * const { count } = await prisma.personaTemplate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PersonaTemplateDeleteManyArgs>(args?: SelectSubset<T, PersonaTemplateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PersonaTemplateUpdateManyArgs>(args: SelectSubset<T, PersonaTemplateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PersonaTemplates and returns the data updated in the database.
     * @param {PersonaTemplateUpdateManyAndReturnArgs} args - Arguments to update many PersonaTemplates.
     * @example
     * // Update many PersonaTemplates
     * const personaTemplate = await prisma.personaTemplate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PersonaTemplates and only return the `id`
     * const personaTemplateWithIdOnly = await prisma.personaTemplate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PersonaTemplateUpdateManyAndReturnArgs>(args: SelectSubset<T, PersonaTemplateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PersonaTemplate.
     * @param {PersonaTemplateUpsertArgs} args - Arguments to update or create a PersonaTemplate.
     * @example
     * // Update or create a PersonaTemplate
     * const personaTemplate = await prisma.personaTemplate.upsert({
     *   create: {
     *     // ... data to create a PersonaTemplate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PersonaTemplate we want to update
     *   }
     * })
     */
    upsert<T extends PersonaTemplateUpsertArgs>(args: SelectSubset<T, PersonaTemplateUpsertArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PersonaTemplates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateCountArgs} args - Arguments to filter PersonaTemplates to count.
     * @example
     * // Count the number of PersonaTemplates
     * const count = await prisma.personaTemplate.count({
     *   where: {
     *     // ... the filter for the PersonaTemplates we want to count
     *   }
     * })
    **/
    count<T extends PersonaTemplateCountArgs>(
      args?: Subset<T, PersonaTemplateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PersonaTemplateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PersonaTemplateAggregateArgs>(args: Subset<T, PersonaTemplateAggregateArgs>): Prisma.PrismaPromise<GetPersonaTemplateAggregateType<T>>

    /**
     * Group by PersonaTemplate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PersonaTemplateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PersonaTemplateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PersonaTemplateGroupByArgs['orderBy'] }
        : { orderBy?: PersonaTemplateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PersonaTemplateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPersonaTemplateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PersonaTemplate model
   */
  readonly fields: PersonaTemplateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PersonaTemplate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PersonaTemplateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends PersonaTemplate$createdByArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$createdByArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avatarFile<T extends PersonaTemplate$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    bots<T extends PersonaTemplate$botsArgs<ExtArgs> = {}>(args?: Subset<T, PersonaTemplate$botsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PersonaTemplate model
   */
  interface PersonaTemplateFieldRefs {
    readonly id: FieldRef<"PersonaTemplate", 'String'>
    readonly name: FieldRef<"PersonaTemplate", 'String'>
    readonly emoji: FieldRef<"PersonaTemplate", 'String'>
    readonly avatarFileId: FieldRef<"PersonaTemplate", 'String'>
    readonly tagline: FieldRef<"PersonaTemplate", 'String'>
    readonly soulMarkdown: FieldRef<"PersonaTemplate", 'String'>
    readonly soulPreview: FieldRef<"PersonaTemplate", 'String'>
    readonly isSystem: FieldRef<"PersonaTemplate", 'Boolean'>
    readonly createdById: FieldRef<"PersonaTemplate", 'String'>
    readonly isDeleted: FieldRef<"PersonaTemplate", 'Boolean'>
    readonly createdAt: FieldRef<"PersonaTemplate", 'DateTime'>
    readonly updatedAt: FieldRef<"PersonaTemplate", 'DateTime'>
    readonly deletedAt: FieldRef<"PersonaTemplate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PersonaTemplate findUnique
   */
  export type PersonaTemplateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate findUniqueOrThrow
   */
  export type PersonaTemplateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate findFirst
   */
  export type PersonaTemplateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonaTemplates.
     */
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate findFirstOrThrow
   */
  export type PersonaTemplateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplate to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PersonaTemplates.
     */
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate findMany
   */
  export type PersonaTemplateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter, which PersonaTemplates to fetch.
     */
    where?: PersonaTemplateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PersonaTemplates to fetch.
     */
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PersonaTemplates.
     */
    cursor?: PersonaTemplateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` PersonaTemplates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PersonaTemplates.
     */
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * PersonaTemplate create
   */
  export type PersonaTemplateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to create a PersonaTemplate.
     */
    data: XOR<PersonaTemplateCreateInput, PersonaTemplateUncheckedCreateInput>
  }

  /**
   * PersonaTemplate createMany
   */
  export type PersonaTemplateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PersonaTemplates.
     */
    data: PersonaTemplateCreateManyInput | PersonaTemplateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PersonaTemplate createManyAndReturn
   */
  export type PersonaTemplateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * The data used to create many PersonaTemplates.
     */
    data: PersonaTemplateCreateManyInput | PersonaTemplateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonaTemplate update
   */
  export type PersonaTemplateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The data needed to update a PersonaTemplate.
     */
    data: XOR<PersonaTemplateUpdateInput, PersonaTemplateUncheckedUpdateInput>
    /**
     * Choose, which PersonaTemplate to update.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate updateMany
   */
  export type PersonaTemplateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PersonaTemplates.
     */
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PersonaTemplates to update
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to update.
     */
    limit?: number
  }

  /**
   * PersonaTemplate updateManyAndReturn
   */
  export type PersonaTemplateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * The data used to update PersonaTemplates.
     */
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyInput>
    /**
     * Filter which PersonaTemplates to update
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PersonaTemplate upsert
   */
  export type PersonaTemplateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * The filter to search for the PersonaTemplate to update in case it exists.
     */
    where: PersonaTemplateWhereUniqueInput
    /**
     * In case the PersonaTemplate found by the `where` argument doesn't exist, create a new PersonaTemplate with this data.
     */
    create: XOR<PersonaTemplateCreateInput, PersonaTemplateUncheckedCreateInput>
    /**
     * In case the PersonaTemplate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PersonaTemplateUpdateInput, PersonaTemplateUncheckedUpdateInput>
  }

  /**
   * PersonaTemplate delete
   */
  export type PersonaTemplateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    /**
     * Filter which PersonaTemplate to delete.
     */
    where: PersonaTemplateWhereUniqueInput
  }

  /**
   * PersonaTemplate deleteMany
   */
  export type PersonaTemplateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PersonaTemplates to delete
     */
    where?: PersonaTemplateWhereInput
    /**
     * Limit how many PersonaTemplates to delete.
     */
    limit?: number
  }

  /**
   * PersonaTemplate.createdBy
   */
  export type PersonaTemplate$createdByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
  }

  /**
   * PersonaTemplate.avatarFile
   */
  export type PersonaTemplate$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * PersonaTemplate.bots
   */
  export type PersonaTemplate$botsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * PersonaTemplate without action
   */
  export type PersonaTemplateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
  }


  /**
   * Model WechatAuth
   */

  export type AggregateWechatAuth = {
    _count: WechatAuthCountAggregateOutputType | null
    _min: WechatAuthMinAggregateOutputType | null
    _max: WechatAuthMaxAggregateOutputType | null
  }

  export type WechatAuthMinAggregateOutputType = {
    openid: string | null
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WechatAuthMaxAggregateOutputType = {
    openid: string | null
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type WechatAuthCountAggregateOutputType = {
    openid: number
    sessionKey: number
    refreshToken: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type WechatAuthMinAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WechatAuthMaxAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type WechatAuthCountAggregateInputType = {
    openid?: true
    sessionKey?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type WechatAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WechatAuth to aggregate.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned WechatAuths
    **/
    _count?: true | WechatAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: WechatAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: WechatAuthMaxAggregateInputType
  }

  export type GetWechatAuthAggregateType<T extends WechatAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateWechatAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateWechatAuth[P]>
      : GetScalarType<T[P], AggregateWechatAuth[P]>
  }




  export type WechatAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: WechatAuthWhereInput
    orderBy?: WechatAuthOrderByWithAggregationInput | WechatAuthOrderByWithAggregationInput[]
    by: WechatAuthScalarFieldEnum[] | WechatAuthScalarFieldEnum
    having?: WechatAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: WechatAuthCountAggregateInputType | true
    _min?: WechatAuthMinAggregateInputType
    _max?: WechatAuthMaxAggregateInputType
  }

  export type WechatAuthGroupByOutputType = {
    openid: string
    sessionKey: string | null
    refreshToken: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: WechatAuthCountAggregateOutputType | null
    _min: WechatAuthMinAggregateOutputType | null
    _max: WechatAuthMaxAggregateOutputType | null
  }

  type GetWechatAuthGroupByPayload<T extends WechatAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<WechatAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof WechatAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], WechatAuthGroupByOutputType[P]>
            : GetScalarType<T[P], WechatAuthGroupByOutputType[P]>
        }
      >
    >


  export type WechatAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["wechatAuth"]>

  export type WechatAuthSelectScalar = {
    openid?: boolean
    sessionKey?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type WechatAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"openid" | "sessionKey" | "refreshToken" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["wechatAuth"]>
  export type WechatAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type WechatAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type WechatAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $WechatAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "WechatAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      openid: string
      sessionKey: string | null
      refreshToken: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["wechatAuth"]>
    composites: {}
  }

  type WechatAuthGetPayload<S extends boolean | null | undefined | WechatAuthDefaultArgs> = $Result.GetResult<Prisma.$WechatAuthPayload, S>

  type WechatAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<WechatAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: WechatAuthCountAggregateInputType | true
    }

  export interface WechatAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['WechatAuth'], meta: { name: 'WechatAuth' } }
    /**
     * Find zero or one WechatAuth that matches the filter.
     * @param {WechatAuthFindUniqueArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends WechatAuthFindUniqueArgs>(args: SelectSubset<T, WechatAuthFindUniqueArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one WechatAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {WechatAuthFindUniqueOrThrowArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends WechatAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, WechatAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WechatAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindFirstArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends WechatAuthFindFirstArgs>(args?: SelectSubset<T, WechatAuthFindFirstArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first WechatAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindFirstOrThrowArgs} args - Arguments to find a WechatAuth
     * @example
     * // Get one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends WechatAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, WechatAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more WechatAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all WechatAuths
     * const wechatAuths = await prisma.wechatAuth.findMany()
     * 
     * // Get first 10 WechatAuths
     * const wechatAuths = await prisma.wechatAuth.findMany({ take: 10 })
     * 
     * // Only select the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.findMany({ select: { openid: true } })
     * 
     */
    findMany<T extends WechatAuthFindManyArgs>(args?: SelectSubset<T, WechatAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a WechatAuth.
     * @param {WechatAuthCreateArgs} args - Arguments to create a WechatAuth.
     * @example
     * // Create one WechatAuth
     * const WechatAuth = await prisma.wechatAuth.create({
     *   data: {
     *     // ... data to create a WechatAuth
     *   }
     * })
     * 
     */
    create<T extends WechatAuthCreateArgs>(args: SelectSubset<T, WechatAuthCreateArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many WechatAuths.
     * @param {WechatAuthCreateManyArgs} args - Arguments to create many WechatAuths.
     * @example
     * // Create many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends WechatAuthCreateManyArgs>(args?: SelectSubset<T, WechatAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many WechatAuths and returns the data saved in the database.
     * @param {WechatAuthCreateManyAndReturnArgs} args - Arguments to create many WechatAuths.
     * @example
     * // Create many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many WechatAuths and only return the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.createManyAndReturn({
     *   select: { openid: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends WechatAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, WechatAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a WechatAuth.
     * @param {WechatAuthDeleteArgs} args - Arguments to delete one WechatAuth.
     * @example
     * // Delete one WechatAuth
     * const WechatAuth = await prisma.wechatAuth.delete({
     *   where: {
     *     // ... filter to delete one WechatAuth
     *   }
     * })
     * 
     */
    delete<T extends WechatAuthDeleteArgs>(args: SelectSubset<T, WechatAuthDeleteArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one WechatAuth.
     * @param {WechatAuthUpdateArgs} args - Arguments to update one WechatAuth.
     * @example
     * // Update one WechatAuth
     * const wechatAuth = await prisma.wechatAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends WechatAuthUpdateArgs>(args: SelectSubset<T, WechatAuthUpdateArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more WechatAuths.
     * @param {WechatAuthDeleteManyArgs} args - Arguments to filter WechatAuths to delete.
     * @example
     * // Delete a few WechatAuths
     * const { count } = await prisma.wechatAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends WechatAuthDeleteManyArgs>(args?: SelectSubset<T, WechatAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WechatAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends WechatAuthUpdateManyArgs>(args: SelectSubset<T, WechatAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more WechatAuths and returns the data updated in the database.
     * @param {WechatAuthUpdateManyAndReturnArgs} args - Arguments to update many WechatAuths.
     * @example
     * // Update many WechatAuths
     * const wechatAuth = await prisma.wechatAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more WechatAuths and only return the `openid`
     * const wechatAuthWithOpenidOnly = await prisma.wechatAuth.updateManyAndReturn({
     *   select: { openid: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends WechatAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, WechatAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one WechatAuth.
     * @param {WechatAuthUpsertArgs} args - Arguments to update or create a WechatAuth.
     * @example
     * // Update or create a WechatAuth
     * const wechatAuth = await prisma.wechatAuth.upsert({
     *   create: {
     *     // ... data to create a WechatAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the WechatAuth we want to update
     *   }
     * })
     */
    upsert<T extends WechatAuthUpsertArgs>(args: SelectSubset<T, WechatAuthUpsertArgs<ExtArgs>>): Prisma__WechatAuthClient<$Result.GetResult<Prisma.$WechatAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of WechatAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthCountArgs} args - Arguments to filter WechatAuths to count.
     * @example
     * // Count the number of WechatAuths
     * const count = await prisma.wechatAuth.count({
     *   where: {
     *     // ... the filter for the WechatAuths we want to count
     *   }
     * })
    **/
    count<T extends WechatAuthCountArgs>(
      args?: Subset<T, WechatAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], WechatAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a WechatAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends WechatAuthAggregateArgs>(args: Subset<T, WechatAuthAggregateArgs>): Prisma.PrismaPromise<GetWechatAuthAggregateType<T>>

    /**
     * Group by WechatAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {WechatAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends WechatAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: WechatAuthGroupByArgs['orderBy'] }
        : { orderBy?: WechatAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, WechatAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetWechatAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the WechatAuth model
   */
  readonly fields: WechatAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for WechatAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__WechatAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the WechatAuth model
   */
  interface WechatAuthFieldRefs {
    readonly openid: FieldRef<"WechatAuth", 'String'>
    readonly sessionKey: FieldRef<"WechatAuth", 'String'>
    readonly refreshToken: FieldRef<"WechatAuth", 'String'>
    readonly isDeleted: FieldRef<"WechatAuth", 'Boolean'>
    readonly createdAt: FieldRef<"WechatAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"WechatAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"WechatAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * WechatAuth findUnique
   */
  export type WechatAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth findUniqueOrThrow
   */
  export type WechatAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth findFirst
   */
  export type WechatAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WechatAuths.
     */
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth findFirstOrThrow
   */
  export type WechatAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuth to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of WechatAuths.
     */
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth findMany
   */
  export type WechatAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter, which WechatAuths to fetch.
     */
    where?: WechatAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of WechatAuths to fetch.
     */
    orderBy?: WechatAuthOrderByWithRelationInput | WechatAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing WechatAuths.
     */
    cursor?: WechatAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` WechatAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` WechatAuths.
     */
    skip?: number
    distinct?: WechatAuthScalarFieldEnum | WechatAuthScalarFieldEnum[]
  }

  /**
   * WechatAuth create
   */
  export type WechatAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a WechatAuth.
     */
    data: XOR<WechatAuthCreateInput, WechatAuthUncheckedCreateInput>
  }

  /**
   * WechatAuth createMany
   */
  export type WechatAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many WechatAuths.
     */
    data: WechatAuthCreateManyInput | WechatAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * WechatAuth createManyAndReturn
   */
  export type WechatAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * The data used to create many WechatAuths.
     */
    data: WechatAuthCreateManyInput | WechatAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * WechatAuth update
   */
  export type WechatAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a WechatAuth.
     */
    data: XOR<WechatAuthUpdateInput, WechatAuthUncheckedUpdateInput>
    /**
     * Choose, which WechatAuth to update.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth updateMany
   */
  export type WechatAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update WechatAuths.
     */
    data: XOR<WechatAuthUpdateManyMutationInput, WechatAuthUncheckedUpdateManyInput>
    /**
     * Filter which WechatAuths to update
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to update.
     */
    limit?: number
  }

  /**
   * WechatAuth updateManyAndReturn
   */
  export type WechatAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * The data used to update WechatAuths.
     */
    data: XOR<WechatAuthUpdateManyMutationInput, WechatAuthUncheckedUpdateManyInput>
    /**
     * Filter which WechatAuths to update
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * WechatAuth upsert
   */
  export type WechatAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the WechatAuth to update in case it exists.
     */
    where: WechatAuthWhereUniqueInput
    /**
     * In case the WechatAuth found by the `where` argument doesn't exist, create a new WechatAuth with this data.
     */
    create: XOR<WechatAuthCreateInput, WechatAuthUncheckedCreateInput>
    /**
     * In case the WechatAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<WechatAuthUpdateInput, WechatAuthUncheckedUpdateInput>
  }

  /**
   * WechatAuth delete
   */
  export type WechatAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
    /**
     * Filter which WechatAuth to delete.
     */
    where: WechatAuthWhereUniqueInput
  }

  /**
   * WechatAuth deleteMany
   */
  export type WechatAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which WechatAuths to delete
     */
    where?: WechatAuthWhereInput
    /**
     * Limit how many WechatAuths to delete.
     */
    limit?: number
  }

  /**
   * WechatAuth without action
   */
  export type WechatAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the WechatAuth
     */
    select?: WechatAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the WechatAuth
     */
    omit?: WechatAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: WechatAuthInclude<ExtArgs> | null
  }


  /**
   * Model GoogleAuth
   */

  export type AggregateGoogleAuth = {
    _count: GoogleAuthCountAggregateOutputType | null
    _avg: GoogleAuthAvgAggregateOutputType | null
    _sum: GoogleAuthSumAggregateOutputType | null
    _min: GoogleAuthMinAggregateOutputType | null
    _max: GoogleAuthMaxAggregateOutputType | null
  }

  export type GoogleAuthAvgAggregateOutputType = {
    exp: number | null
    iat: number | null
  }

  export type GoogleAuthSumAggregateOutputType = {
    exp: number | null
    iat: number | null
  }

  export type GoogleAuthMinAggregateOutputType = {
    sub: string | null
    email: string | null
    verifiedEmail: boolean | null
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number | null
    iat: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GoogleAuthMaxAggregateOutputType = {
    sub: string | null
    email: string | null
    verifiedEmail: boolean | null
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number | null
    iat: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type GoogleAuthCountAggregateOutputType = {
    sub: number
    email: number
    verifiedEmail: number
    atHash: number
    name: number
    picture: number
    givenName: number
    familyName: number
    exp: number
    iat: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type GoogleAuthAvgAggregateInputType = {
    exp?: true
    iat?: true
  }

  export type GoogleAuthSumAggregateInputType = {
    exp?: true
    iat?: true
  }

  export type GoogleAuthMinAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GoogleAuthMaxAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type GoogleAuthCountAggregateInputType = {
    sub?: true
    email?: true
    verifiedEmail?: true
    atHash?: true
    name?: true
    picture?: true
    givenName?: true
    familyName?: true
    exp?: true
    iat?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type GoogleAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuth to aggregate.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GoogleAuths
    **/
    _count?: true | GoogleAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: GoogleAuthAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: GoogleAuthSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GoogleAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GoogleAuthMaxAggregateInputType
  }

  export type GetGoogleAuthAggregateType<T extends GoogleAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateGoogleAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGoogleAuth[P]>
      : GetScalarType<T[P], AggregateGoogleAuth[P]>
  }




  export type GoogleAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GoogleAuthWhereInput
    orderBy?: GoogleAuthOrderByWithAggregationInput | GoogleAuthOrderByWithAggregationInput[]
    by: GoogleAuthScalarFieldEnum[] | GoogleAuthScalarFieldEnum
    having?: GoogleAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GoogleAuthCountAggregateInputType | true
    _avg?: GoogleAuthAvgAggregateInputType
    _sum?: GoogleAuthSumAggregateInputType
    _min?: GoogleAuthMinAggregateInputType
    _max?: GoogleAuthMaxAggregateInputType
  }

  export type GoogleAuthGroupByOutputType = {
    sub: string
    email: string
    verifiedEmail: boolean
    atHash: string | null
    name: string | null
    picture: string | null
    givenName: string | null
    familyName: string | null
    exp: number
    iat: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: GoogleAuthCountAggregateOutputType | null
    _avg: GoogleAuthAvgAggregateOutputType | null
    _sum: GoogleAuthSumAggregateOutputType | null
    _min: GoogleAuthMinAggregateOutputType | null
    _max: GoogleAuthMaxAggregateOutputType | null
  }

  type GetGoogleAuthGroupByPayload<T extends GoogleAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GoogleAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GoogleAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GoogleAuthGroupByOutputType[P]>
            : GetScalarType<T[P], GoogleAuthGroupByOutputType[P]>
        }
      >
    >


  export type GoogleAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["googleAuth"]>

  export type GoogleAuthSelectScalar = {
    sub?: boolean
    email?: boolean
    verifiedEmail?: boolean
    atHash?: boolean
    name?: boolean
    picture?: boolean
    givenName?: boolean
    familyName?: boolean
    exp?: boolean
    iat?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type GoogleAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"sub" | "email" | "verifiedEmail" | "atHash" | "name" | "picture" | "givenName" | "familyName" | "exp" | "iat" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["googleAuth"]>
  export type GoogleAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type GoogleAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type GoogleAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $GoogleAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GoogleAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      sub: string
      email: string
      verifiedEmail: boolean
      atHash: string | null
      name: string | null
      picture: string | null
      givenName: string | null
      familyName: string | null
      exp: number
      iat: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["googleAuth"]>
    composites: {}
  }

  type GoogleAuthGetPayload<S extends boolean | null | undefined | GoogleAuthDefaultArgs> = $Result.GetResult<Prisma.$GoogleAuthPayload, S>

  type GoogleAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GoogleAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GoogleAuthCountAggregateInputType | true
    }

  export interface GoogleAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GoogleAuth'], meta: { name: 'GoogleAuth' } }
    /**
     * Find zero or one GoogleAuth that matches the filter.
     * @param {GoogleAuthFindUniqueArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GoogleAuthFindUniqueArgs>(args: SelectSubset<T, GoogleAuthFindUniqueArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GoogleAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GoogleAuthFindUniqueOrThrowArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GoogleAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, GoogleAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoogleAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindFirstArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GoogleAuthFindFirstArgs>(args?: SelectSubset<T, GoogleAuthFindFirstArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GoogleAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindFirstOrThrowArgs} args - Arguments to find a GoogleAuth
     * @example
     * // Get one GoogleAuth
     * const googleAuth = await prisma.googleAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GoogleAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, GoogleAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GoogleAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GoogleAuths
     * const googleAuths = await prisma.googleAuth.findMany()
     * 
     * // Get first 10 GoogleAuths
     * const googleAuths = await prisma.googleAuth.findMany({ take: 10 })
     * 
     * // Only select the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.findMany({ select: { sub: true } })
     * 
     */
    findMany<T extends GoogleAuthFindManyArgs>(args?: SelectSubset<T, GoogleAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GoogleAuth.
     * @param {GoogleAuthCreateArgs} args - Arguments to create a GoogleAuth.
     * @example
     * // Create one GoogleAuth
     * const GoogleAuth = await prisma.googleAuth.create({
     *   data: {
     *     // ... data to create a GoogleAuth
     *   }
     * })
     * 
     */
    create<T extends GoogleAuthCreateArgs>(args: SelectSubset<T, GoogleAuthCreateArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GoogleAuths.
     * @param {GoogleAuthCreateManyArgs} args - Arguments to create many GoogleAuths.
     * @example
     * // Create many GoogleAuths
     * const googleAuth = await prisma.googleAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GoogleAuthCreateManyArgs>(args?: SelectSubset<T, GoogleAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GoogleAuths and returns the data saved in the database.
     * @param {GoogleAuthCreateManyAndReturnArgs} args - Arguments to create many GoogleAuths.
     * @example
     * // Create many GoogleAuths
     * const googleAuth = await prisma.googleAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GoogleAuths and only return the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.createManyAndReturn({
     *   select: { sub: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GoogleAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, GoogleAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GoogleAuth.
     * @param {GoogleAuthDeleteArgs} args - Arguments to delete one GoogleAuth.
     * @example
     * // Delete one GoogleAuth
     * const GoogleAuth = await prisma.googleAuth.delete({
     *   where: {
     *     // ... filter to delete one GoogleAuth
     *   }
     * })
     * 
     */
    delete<T extends GoogleAuthDeleteArgs>(args: SelectSubset<T, GoogleAuthDeleteArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GoogleAuth.
     * @param {GoogleAuthUpdateArgs} args - Arguments to update one GoogleAuth.
     * @example
     * // Update one GoogleAuth
     * const googleAuth = await prisma.googleAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GoogleAuthUpdateArgs>(args: SelectSubset<T, GoogleAuthUpdateArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GoogleAuths.
     * @param {GoogleAuthDeleteManyArgs} args - Arguments to filter GoogleAuths to delete.
     * @example
     * // Delete a few GoogleAuths
     * const { count } = await prisma.googleAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GoogleAuthDeleteManyArgs>(args?: SelectSubset<T, GoogleAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GoogleAuths
     * const googleAuth = await prisma.googleAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GoogleAuthUpdateManyArgs>(args: SelectSubset<T, GoogleAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GoogleAuths and returns the data updated in the database.
     * @param {GoogleAuthUpdateManyAndReturnArgs} args - Arguments to update many GoogleAuths.
     * @example
     * // Update many GoogleAuths
     * const googleAuth = await prisma.googleAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GoogleAuths and only return the `sub`
     * const googleAuthWithSubOnly = await prisma.googleAuth.updateManyAndReturn({
     *   select: { sub: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GoogleAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, GoogleAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GoogleAuth.
     * @param {GoogleAuthUpsertArgs} args - Arguments to update or create a GoogleAuth.
     * @example
     * // Update or create a GoogleAuth
     * const googleAuth = await prisma.googleAuth.upsert({
     *   create: {
     *     // ... data to create a GoogleAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GoogleAuth we want to update
     *   }
     * })
     */
    upsert<T extends GoogleAuthUpsertArgs>(args: SelectSubset<T, GoogleAuthUpsertArgs<ExtArgs>>): Prisma__GoogleAuthClient<$Result.GetResult<Prisma.$GoogleAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GoogleAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthCountArgs} args - Arguments to filter GoogleAuths to count.
     * @example
     * // Count the number of GoogleAuths
     * const count = await prisma.googleAuth.count({
     *   where: {
     *     // ... the filter for the GoogleAuths we want to count
     *   }
     * })
    **/
    count<T extends GoogleAuthCountArgs>(
      args?: Subset<T, GoogleAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GoogleAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GoogleAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GoogleAuthAggregateArgs>(args: Subset<T, GoogleAuthAggregateArgs>): Prisma.PrismaPromise<GetGoogleAuthAggregateType<T>>

    /**
     * Group by GoogleAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GoogleAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GoogleAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GoogleAuthGroupByArgs['orderBy'] }
        : { orderBy?: GoogleAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GoogleAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGoogleAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GoogleAuth model
   */
  readonly fields: GoogleAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GoogleAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GoogleAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GoogleAuth model
   */
  interface GoogleAuthFieldRefs {
    readonly sub: FieldRef<"GoogleAuth", 'String'>
    readonly email: FieldRef<"GoogleAuth", 'String'>
    readonly verifiedEmail: FieldRef<"GoogleAuth", 'Boolean'>
    readonly atHash: FieldRef<"GoogleAuth", 'String'>
    readonly name: FieldRef<"GoogleAuth", 'String'>
    readonly picture: FieldRef<"GoogleAuth", 'String'>
    readonly givenName: FieldRef<"GoogleAuth", 'String'>
    readonly familyName: FieldRef<"GoogleAuth", 'String'>
    readonly exp: FieldRef<"GoogleAuth", 'Int'>
    readonly iat: FieldRef<"GoogleAuth", 'Int'>
    readonly isDeleted: FieldRef<"GoogleAuth", 'Boolean'>
    readonly createdAt: FieldRef<"GoogleAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"GoogleAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"GoogleAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GoogleAuth findUnique
   */
  export type GoogleAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth findUniqueOrThrow
   */
  export type GoogleAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth findFirst
   */
  export type GoogleAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuths.
     */
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth findFirstOrThrow
   */
  export type GoogleAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuth to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GoogleAuths.
     */
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth findMany
   */
  export type GoogleAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter, which GoogleAuths to fetch.
     */
    where?: GoogleAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GoogleAuths to fetch.
     */
    orderBy?: GoogleAuthOrderByWithRelationInput | GoogleAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GoogleAuths.
     */
    cursor?: GoogleAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` GoogleAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GoogleAuths.
     */
    skip?: number
    distinct?: GoogleAuthScalarFieldEnum | GoogleAuthScalarFieldEnum[]
  }

  /**
   * GoogleAuth create
   */
  export type GoogleAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a GoogleAuth.
     */
    data: XOR<GoogleAuthCreateInput, GoogleAuthUncheckedCreateInput>
  }

  /**
   * GoogleAuth createMany
   */
  export type GoogleAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GoogleAuths.
     */
    data: GoogleAuthCreateManyInput | GoogleAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GoogleAuth createManyAndReturn
   */
  export type GoogleAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * The data used to create many GoogleAuths.
     */
    data: GoogleAuthCreateManyInput | GoogleAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoogleAuth update
   */
  export type GoogleAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a GoogleAuth.
     */
    data: XOR<GoogleAuthUpdateInput, GoogleAuthUncheckedUpdateInput>
    /**
     * Choose, which GoogleAuth to update.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth updateMany
   */
  export type GoogleAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GoogleAuths.
     */
    data: XOR<GoogleAuthUpdateManyMutationInput, GoogleAuthUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAuths to update
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to update.
     */
    limit?: number
  }

  /**
   * GoogleAuth updateManyAndReturn
   */
  export type GoogleAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * The data used to update GoogleAuths.
     */
    data: XOR<GoogleAuthUpdateManyMutationInput, GoogleAuthUncheckedUpdateManyInput>
    /**
     * Filter which GoogleAuths to update
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GoogleAuth upsert
   */
  export type GoogleAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the GoogleAuth to update in case it exists.
     */
    where: GoogleAuthWhereUniqueInput
    /**
     * In case the GoogleAuth found by the `where` argument doesn't exist, create a new GoogleAuth with this data.
     */
    create: XOR<GoogleAuthCreateInput, GoogleAuthUncheckedCreateInput>
    /**
     * In case the GoogleAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GoogleAuthUpdateInput, GoogleAuthUncheckedUpdateInput>
  }

  /**
   * GoogleAuth delete
   */
  export type GoogleAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
    /**
     * Filter which GoogleAuth to delete.
     */
    where: GoogleAuthWhereUniqueInput
  }

  /**
   * GoogleAuth deleteMany
   */
  export type GoogleAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GoogleAuths to delete
     */
    where?: GoogleAuthWhereInput
    /**
     * Limit how many GoogleAuths to delete.
     */
    limit?: number
  }

  /**
   * GoogleAuth without action
   */
  export type GoogleAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GoogleAuth
     */
    select?: GoogleAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GoogleAuth
     */
    omit?: GoogleAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GoogleAuthInclude<ExtArgs> | null
  }


  /**
   * Model DiscordAuth
   */

  export type AggregateDiscordAuth = {
    _count: DiscordAuthCountAggregateOutputType | null
    _min: DiscordAuthMinAggregateOutputType | null
    _max: DiscordAuthMaxAggregateOutputType | null
  }

  export type DiscordAuthMinAggregateOutputType = {
    discordId: string | null
    email: string | null
    verifiedEmail: boolean | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DiscordAuthMaxAggregateOutputType = {
    discordId: string | null
    email: string | null
    verifiedEmail: boolean | null
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type DiscordAuthCountAggregateOutputType = {
    discordId: number
    email: number
    verifiedEmail: number
    name: number
    accessToken: number
    refreshToken: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type DiscordAuthMinAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DiscordAuthMaxAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type DiscordAuthCountAggregateInputType = {
    discordId?: true
    email?: true
    verifiedEmail?: true
    name?: true
    accessToken?: true
    refreshToken?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type DiscordAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAuth to aggregate.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DiscordAuths
    **/
    _count?: true | DiscordAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DiscordAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DiscordAuthMaxAggregateInputType
  }

  export type GetDiscordAuthAggregateType<T extends DiscordAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateDiscordAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDiscordAuth[P]>
      : GetScalarType<T[P], AggregateDiscordAuth[P]>
  }




  export type DiscordAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DiscordAuthWhereInput
    orderBy?: DiscordAuthOrderByWithAggregationInput | DiscordAuthOrderByWithAggregationInput[]
    by: DiscordAuthScalarFieldEnum[] | DiscordAuthScalarFieldEnum
    having?: DiscordAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DiscordAuthCountAggregateInputType | true
    _min?: DiscordAuthMinAggregateInputType
    _max?: DiscordAuthMaxAggregateInputType
  }

  export type DiscordAuthGroupByOutputType = {
    discordId: string
    email: string
    verifiedEmail: boolean
    name: string | null
    accessToken: string | null
    refreshToken: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: DiscordAuthCountAggregateOutputType | null
    _min: DiscordAuthMinAggregateOutputType | null
    _max: DiscordAuthMaxAggregateOutputType | null
  }

  type GetDiscordAuthGroupByPayload<T extends DiscordAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DiscordAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DiscordAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DiscordAuthGroupByOutputType[P]>
            : GetScalarType<T[P], DiscordAuthGroupByOutputType[P]>
        }
      >
    >


  export type DiscordAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["discordAuth"]>

  export type DiscordAuthSelectScalar = {
    discordId?: boolean
    email?: boolean
    verifiedEmail?: boolean
    name?: boolean
    accessToken?: boolean
    refreshToken?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type DiscordAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"discordId" | "email" | "verifiedEmail" | "name" | "accessToken" | "refreshToken" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["discordAuth"]>
  export type DiscordAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type DiscordAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type DiscordAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $DiscordAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DiscordAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      discordId: string
      email: string
      verifiedEmail: boolean
      name: string | null
      accessToken: string | null
      refreshToken: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["discordAuth"]>
    composites: {}
  }

  type DiscordAuthGetPayload<S extends boolean | null | undefined | DiscordAuthDefaultArgs> = $Result.GetResult<Prisma.$DiscordAuthPayload, S>

  type DiscordAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DiscordAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DiscordAuthCountAggregateInputType | true
    }

  export interface DiscordAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DiscordAuth'], meta: { name: 'DiscordAuth' } }
    /**
     * Find zero or one DiscordAuth that matches the filter.
     * @param {DiscordAuthFindUniqueArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DiscordAuthFindUniqueArgs>(args: SelectSubset<T, DiscordAuthFindUniqueArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one DiscordAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DiscordAuthFindUniqueOrThrowArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DiscordAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, DiscordAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindFirstArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DiscordAuthFindFirstArgs>(args?: SelectSubset<T, DiscordAuthFindFirstArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first DiscordAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindFirstOrThrowArgs} args - Arguments to find a DiscordAuth
     * @example
     * // Get one DiscordAuth
     * const discordAuth = await prisma.discordAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DiscordAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, DiscordAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more DiscordAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DiscordAuths
     * const discordAuths = await prisma.discordAuth.findMany()
     * 
     * // Get first 10 DiscordAuths
     * const discordAuths = await prisma.discordAuth.findMany({ take: 10 })
     * 
     * // Only select the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.findMany({ select: { discordId: true } })
     * 
     */
    findMany<T extends DiscordAuthFindManyArgs>(args?: SelectSubset<T, DiscordAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a DiscordAuth.
     * @param {DiscordAuthCreateArgs} args - Arguments to create a DiscordAuth.
     * @example
     * // Create one DiscordAuth
     * const DiscordAuth = await prisma.discordAuth.create({
     *   data: {
     *     // ... data to create a DiscordAuth
     *   }
     * })
     * 
     */
    create<T extends DiscordAuthCreateArgs>(args: SelectSubset<T, DiscordAuthCreateArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many DiscordAuths.
     * @param {DiscordAuthCreateManyArgs} args - Arguments to create many DiscordAuths.
     * @example
     * // Create many DiscordAuths
     * const discordAuth = await prisma.discordAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DiscordAuthCreateManyArgs>(args?: SelectSubset<T, DiscordAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many DiscordAuths and returns the data saved in the database.
     * @param {DiscordAuthCreateManyAndReturnArgs} args - Arguments to create many DiscordAuths.
     * @example
     * // Create many DiscordAuths
     * const discordAuth = await prisma.discordAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many DiscordAuths and only return the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.createManyAndReturn({
     *   select: { discordId: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DiscordAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, DiscordAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a DiscordAuth.
     * @param {DiscordAuthDeleteArgs} args - Arguments to delete one DiscordAuth.
     * @example
     * // Delete one DiscordAuth
     * const DiscordAuth = await prisma.discordAuth.delete({
     *   where: {
     *     // ... filter to delete one DiscordAuth
     *   }
     * })
     * 
     */
    delete<T extends DiscordAuthDeleteArgs>(args: SelectSubset<T, DiscordAuthDeleteArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one DiscordAuth.
     * @param {DiscordAuthUpdateArgs} args - Arguments to update one DiscordAuth.
     * @example
     * // Update one DiscordAuth
     * const discordAuth = await prisma.discordAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DiscordAuthUpdateArgs>(args: SelectSubset<T, DiscordAuthUpdateArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more DiscordAuths.
     * @param {DiscordAuthDeleteManyArgs} args - Arguments to filter DiscordAuths to delete.
     * @example
     * // Delete a few DiscordAuths
     * const { count } = await prisma.discordAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DiscordAuthDeleteManyArgs>(args?: SelectSubset<T, DiscordAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DiscordAuths
     * const discordAuth = await prisma.discordAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DiscordAuthUpdateManyArgs>(args: SelectSubset<T, DiscordAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DiscordAuths and returns the data updated in the database.
     * @param {DiscordAuthUpdateManyAndReturnArgs} args - Arguments to update many DiscordAuths.
     * @example
     * // Update many DiscordAuths
     * const discordAuth = await prisma.discordAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more DiscordAuths and only return the `discordId`
     * const discordAuthWithDiscordIdOnly = await prisma.discordAuth.updateManyAndReturn({
     *   select: { discordId: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DiscordAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, DiscordAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one DiscordAuth.
     * @param {DiscordAuthUpsertArgs} args - Arguments to update or create a DiscordAuth.
     * @example
     * // Update or create a DiscordAuth
     * const discordAuth = await prisma.discordAuth.upsert({
     *   create: {
     *     // ... data to create a DiscordAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DiscordAuth we want to update
     *   }
     * })
     */
    upsert<T extends DiscordAuthUpsertArgs>(args: SelectSubset<T, DiscordAuthUpsertArgs<ExtArgs>>): Prisma__DiscordAuthClient<$Result.GetResult<Prisma.$DiscordAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of DiscordAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthCountArgs} args - Arguments to filter DiscordAuths to count.
     * @example
     * // Count the number of DiscordAuths
     * const count = await prisma.discordAuth.count({
     *   where: {
     *     // ... the filter for the DiscordAuths we want to count
     *   }
     * })
    **/
    count<T extends DiscordAuthCountArgs>(
      args?: Subset<T, DiscordAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DiscordAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DiscordAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DiscordAuthAggregateArgs>(args: Subset<T, DiscordAuthAggregateArgs>): Prisma.PrismaPromise<GetDiscordAuthAggregateType<T>>

    /**
     * Group by DiscordAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DiscordAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DiscordAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DiscordAuthGroupByArgs['orderBy'] }
        : { orderBy?: DiscordAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DiscordAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDiscordAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DiscordAuth model
   */
  readonly fields: DiscordAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DiscordAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DiscordAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DiscordAuth model
   */
  interface DiscordAuthFieldRefs {
    readonly discordId: FieldRef<"DiscordAuth", 'String'>
    readonly email: FieldRef<"DiscordAuth", 'String'>
    readonly verifiedEmail: FieldRef<"DiscordAuth", 'Boolean'>
    readonly name: FieldRef<"DiscordAuth", 'String'>
    readonly accessToken: FieldRef<"DiscordAuth", 'String'>
    readonly refreshToken: FieldRef<"DiscordAuth", 'String'>
    readonly isDeleted: FieldRef<"DiscordAuth", 'Boolean'>
    readonly createdAt: FieldRef<"DiscordAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"DiscordAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"DiscordAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DiscordAuth findUnique
   */
  export type DiscordAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth findUniqueOrThrow
   */
  export type DiscordAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth findFirst
   */
  export type DiscordAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAuths.
     */
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth findFirstOrThrow
   */
  export type DiscordAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuth to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DiscordAuths.
     */
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth findMany
   */
  export type DiscordAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter, which DiscordAuths to fetch.
     */
    where?: DiscordAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DiscordAuths to fetch.
     */
    orderBy?: DiscordAuthOrderByWithRelationInput | DiscordAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DiscordAuths.
     */
    cursor?: DiscordAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` DiscordAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DiscordAuths.
     */
    skip?: number
    distinct?: DiscordAuthScalarFieldEnum | DiscordAuthScalarFieldEnum[]
  }

  /**
   * DiscordAuth create
   */
  export type DiscordAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a DiscordAuth.
     */
    data: XOR<DiscordAuthCreateInput, DiscordAuthUncheckedCreateInput>
  }

  /**
   * DiscordAuth createMany
   */
  export type DiscordAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DiscordAuths.
     */
    data: DiscordAuthCreateManyInput | DiscordAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DiscordAuth createManyAndReturn
   */
  export type DiscordAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * The data used to create many DiscordAuths.
     */
    data: DiscordAuthCreateManyInput | DiscordAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscordAuth update
   */
  export type DiscordAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a DiscordAuth.
     */
    data: XOR<DiscordAuthUpdateInput, DiscordAuthUncheckedUpdateInput>
    /**
     * Choose, which DiscordAuth to update.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth updateMany
   */
  export type DiscordAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DiscordAuths.
     */
    data: XOR<DiscordAuthUpdateManyMutationInput, DiscordAuthUncheckedUpdateManyInput>
    /**
     * Filter which DiscordAuths to update
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to update.
     */
    limit?: number
  }

  /**
   * DiscordAuth updateManyAndReturn
   */
  export type DiscordAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * The data used to update DiscordAuths.
     */
    data: XOR<DiscordAuthUpdateManyMutationInput, DiscordAuthUncheckedUpdateManyInput>
    /**
     * Filter which DiscordAuths to update
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * DiscordAuth upsert
   */
  export type DiscordAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the DiscordAuth to update in case it exists.
     */
    where: DiscordAuthWhereUniqueInput
    /**
     * In case the DiscordAuth found by the `where` argument doesn't exist, create a new DiscordAuth with this data.
     */
    create: XOR<DiscordAuthCreateInput, DiscordAuthUncheckedCreateInput>
    /**
     * In case the DiscordAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DiscordAuthUpdateInput, DiscordAuthUncheckedUpdateInput>
  }

  /**
   * DiscordAuth delete
   */
  export type DiscordAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
    /**
     * Filter which DiscordAuth to delete.
     */
    where: DiscordAuthWhereUniqueInput
  }

  /**
   * DiscordAuth deleteMany
   */
  export type DiscordAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DiscordAuths to delete
     */
    where?: DiscordAuthWhereInput
    /**
     * Limit how many DiscordAuths to delete.
     */
    limit?: number
  }

  /**
   * DiscordAuth without action
   */
  export type DiscordAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DiscordAuth
     */
    select?: DiscordAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the DiscordAuth
     */
    omit?: DiscordAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DiscordAuthInclude<ExtArgs> | null
  }


  /**
   * Model MobileAuth
   */

  export type AggregateMobileAuth = {
    _count: MobileAuthCountAggregateOutputType | null
    _min: MobileAuthMinAggregateOutputType | null
    _max: MobileAuthMaxAggregateOutputType | null
  }

  export type MobileAuthMinAggregateOutputType = {
    mobile: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MobileAuthMaxAggregateOutputType = {
    mobile: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type MobileAuthCountAggregateOutputType = {
    mobile: number
    password: number
    verified: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type MobileAuthMinAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MobileAuthMaxAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type MobileAuthCountAggregateInputType = {
    mobile?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type MobileAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileAuth to aggregate.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MobileAuths
    **/
    _count?: true | MobileAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MobileAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MobileAuthMaxAggregateInputType
  }

  export type GetMobileAuthAggregateType<T extends MobileAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateMobileAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMobileAuth[P]>
      : GetScalarType<T[P], AggregateMobileAuth[P]>
  }




  export type MobileAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MobileAuthWhereInput
    orderBy?: MobileAuthOrderByWithAggregationInput | MobileAuthOrderByWithAggregationInput[]
    by: MobileAuthScalarFieldEnum[] | MobileAuthScalarFieldEnum
    having?: MobileAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MobileAuthCountAggregateInputType | true
    _min?: MobileAuthMinAggregateInputType
    _max?: MobileAuthMaxAggregateInputType
  }

  export type MobileAuthGroupByOutputType = {
    mobile: string
    password: string
    verified: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: MobileAuthCountAggregateOutputType | null
    _min: MobileAuthMinAggregateOutputType | null
    _max: MobileAuthMaxAggregateOutputType | null
  }

  type GetMobileAuthGroupByPayload<T extends MobileAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MobileAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MobileAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MobileAuthGroupByOutputType[P]>
            : GetScalarType<T[P], MobileAuthGroupByOutputType[P]>
        }
      >
    >


  export type MobileAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["mobileAuth"]>

  export type MobileAuthSelectScalar = {
    mobile?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type MobileAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"mobile" | "password" | "verified" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["mobileAuth"]>
  export type MobileAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MobileAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MobileAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $MobileAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MobileAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      mobile: string
      password: string
      verified: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["mobileAuth"]>
    composites: {}
  }

  type MobileAuthGetPayload<S extends boolean | null | undefined | MobileAuthDefaultArgs> = $Result.GetResult<Prisma.$MobileAuthPayload, S>

  type MobileAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MobileAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MobileAuthCountAggregateInputType | true
    }

  export interface MobileAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MobileAuth'], meta: { name: 'MobileAuth' } }
    /**
     * Find zero or one MobileAuth that matches the filter.
     * @param {MobileAuthFindUniqueArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MobileAuthFindUniqueArgs>(args: SelectSubset<T, MobileAuthFindUniqueArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MobileAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MobileAuthFindUniqueOrThrowArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MobileAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, MobileAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindFirstArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MobileAuthFindFirstArgs>(args?: SelectSubset<T, MobileAuthFindFirstArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MobileAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindFirstOrThrowArgs} args - Arguments to find a MobileAuth
     * @example
     * // Get one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MobileAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, MobileAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MobileAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MobileAuths
     * const mobileAuths = await prisma.mobileAuth.findMany()
     * 
     * // Get first 10 MobileAuths
     * const mobileAuths = await prisma.mobileAuth.findMany({ take: 10 })
     * 
     * // Only select the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.findMany({ select: { mobile: true } })
     * 
     */
    findMany<T extends MobileAuthFindManyArgs>(args?: SelectSubset<T, MobileAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MobileAuth.
     * @param {MobileAuthCreateArgs} args - Arguments to create a MobileAuth.
     * @example
     * // Create one MobileAuth
     * const MobileAuth = await prisma.mobileAuth.create({
     *   data: {
     *     // ... data to create a MobileAuth
     *   }
     * })
     * 
     */
    create<T extends MobileAuthCreateArgs>(args: SelectSubset<T, MobileAuthCreateArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MobileAuths.
     * @param {MobileAuthCreateManyArgs} args - Arguments to create many MobileAuths.
     * @example
     * // Create many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MobileAuthCreateManyArgs>(args?: SelectSubset<T, MobileAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MobileAuths and returns the data saved in the database.
     * @param {MobileAuthCreateManyAndReturnArgs} args - Arguments to create many MobileAuths.
     * @example
     * // Create many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MobileAuths and only return the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.createManyAndReturn({
     *   select: { mobile: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MobileAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, MobileAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MobileAuth.
     * @param {MobileAuthDeleteArgs} args - Arguments to delete one MobileAuth.
     * @example
     * // Delete one MobileAuth
     * const MobileAuth = await prisma.mobileAuth.delete({
     *   where: {
     *     // ... filter to delete one MobileAuth
     *   }
     * })
     * 
     */
    delete<T extends MobileAuthDeleteArgs>(args: SelectSubset<T, MobileAuthDeleteArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MobileAuth.
     * @param {MobileAuthUpdateArgs} args - Arguments to update one MobileAuth.
     * @example
     * // Update one MobileAuth
     * const mobileAuth = await prisma.mobileAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MobileAuthUpdateArgs>(args: SelectSubset<T, MobileAuthUpdateArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MobileAuths.
     * @param {MobileAuthDeleteManyArgs} args - Arguments to filter MobileAuths to delete.
     * @example
     * // Delete a few MobileAuths
     * const { count } = await prisma.mobileAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MobileAuthDeleteManyArgs>(args?: SelectSubset<T, MobileAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MobileAuthUpdateManyArgs>(args: SelectSubset<T, MobileAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MobileAuths and returns the data updated in the database.
     * @param {MobileAuthUpdateManyAndReturnArgs} args - Arguments to update many MobileAuths.
     * @example
     * // Update many MobileAuths
     * const mobileAuth = await prisma.mobileAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MobileAuths and only return the `mobile`
     * const mobileAuthWithMobileOnly = await prisma.mobileAuth.updateManyAndReturn({
     *   select: { mobile: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MobileAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, MobileAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MobileAuth.
     * @param {MobileAuthUpsertArgs} args - Arguments to update or create a MobileAuth.
     * @example
     * // Update or create a MobileAuth
     * const mobileAuth = await prisma.mobileAuth.upsert({
     *   create: {
     *     // ... data to create a MobileAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MobileAuth we want to update
     *   }
     * })
     */
    upsert<T extends MobileAuthUpsertArgs>(args: SelectSubset<T, MobileAuthUpsertArgs<ExtArgs>>): Prisma__MobileAuthClient<$Result.GetResult<Prisma.$MobileAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MobileAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthCountArgs} args - Arguments to filter MobileAuths to count.
     * @example
     * // Count the number of MobileAuths
     * const count = await prisma.mobileAuth.count({
     *   where: {
     *     // ... the filter for the MobileAuths we want to count
     *   }
     * })
    **/
    count<T extends MobileAuthCountArgs>(
      args?: Subset<T, MobileAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MobileAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MobileAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MobileAuthAggregateArgs>(args: Subset<T, MobileAuthAggregateArgs>): Prisma.PrismaPromise<GetMobileAuthAggregateType<T>>

    /**
     * Group by MobileAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MobileAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MobileAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MobileAuthGroupByArgs['orderBy'] }
        : { orderBy?: MobileAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MobileAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMobileAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MobileAuth model
   */
  readonly fields: MobileAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MobileAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MobileAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MobileAuth model
   */
  interface MobileAuthFieldRefs {
    readonly mobile: FieldRef<"MobileAuth", 'String'>
    readonly password: FieldRef<"MobileAuth", 'String'>
    readonly verified: FieldRef<"MobileAuth", 'Boolean'>
    readonly isDeleted: FieldRef<"MobileAuth", 'Boolean'>
    readonly createdAt: FieldRef<"MobileAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"MobileAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"MobileAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MobileAuth findUnique
   */
  export type MobileAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth findUniqueOrThrow
   */
  export type MobileAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth findFirst
   */
  export type MobileAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileAuths.
     */
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth findFirstOrThrow
   */
  export type MobileAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuth to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MobileAuths.
     */
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth findMany
   */
  export type MobileAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter, which MobileAuths to fetch.
     */
    where?: MobileAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MobileAuths to fetch.
     */
    orderBy?: MobileAuthOrderByWithRelationInput | MobileAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MobileAuths.
     */
    cursor?: MobileAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MobileAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MobileAuths.
     */
    skip?: number
    distinct?: MobileAuthScalarFieldEnum | MobileAuthScalarFieldEnum[]
  }

  /**
   * MobileAuth create
   */
  export type MobileAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a MobileAuth.
     */
    data: XOR<MobileAuthCreateInput, MobileAuthUncheckedCreateInput>
  }

  /**
   * MobileAuth createMany
   */
  export type MobileAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MobileAuths.
     */
    data: MobileAuthCreateManyInput | MobileAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MobileAuth createManyAndReturn
   */
  export type MobileAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * The data used to create many MobileAuths.
     */
    data: MobileAuthCreateManyInput | MobileAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MobileAuth update
   */
  export type MobileAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a MobileAuth.
     */
    data: XOR<MobileAuthUpdateInput, MobileAuthUncheckedUpdateInput>
    /**
     * Choose, which MobileAuth to update.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth updateMany
   */
  export type MobileAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MobileAuths.
     */
    data: XOR<MobileAuthUpdateManyMutationInput, MobileAuthUncheckedUpdateManyInput>
    /**
     * Filter which MobileAuths to update
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to update.
     */
    limit?: number
  }

  /**
   * MobileAuth updateManyAndReturn
   */
  export type MobileAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * The data used to update MobileAuths.
     */
    data: XOR<MobileAuthUpdateManyMutationInput, MobileAuthUncheckedUpdateManyInput>
    /**
     * Filter which MobileAuths to update
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MobileAuth upsert
   */
  export type MobileAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the MobileAuth to update in case it exists.
     */
    where: MobileAuthWhereUniqueInput
    /**
     * In case the MobileAuth found by the `where` argument doesn't exist, create a new MobileAuth with this data.
     */
    create: XOR<MobileAuthCreateInput, MobileAuthUncheckedCreateInput>
    /**
     * In case the MobileAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MobileAuthUpdateInput, MobileAuthUncheckedUpdateInput>
  }

  /**
   * MobileAuth delete
   */
  export type MobileAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
    /**
     * Filter which MobileAuth to delete.
     */
    where: MobileAuthWhereUniqueInput
  }

  /**
   * MobileAuth deleteMany
   */
  export type MobileAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MobileAuths to delete
     */
    where?: MobileAuthWhereInput
    /**
     * Limit how many MobileAuths to delete.
     */
    limit?: number
  }

  /**
   * MobileAuth without action
   */
  export type MobileAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MobileAuth
     */
    select?: MobileAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MobileAuth
     */
    omit?: MobileAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MobileAuthInclude<ExtArgs> | null
  }


  /**
   * Model EmailAuth
   */

  export type AggregateEmailAuth = {
    _count: EmailAuthCountAggregateOutputType | null
    _min: EmailAuthMinAggregateOutputType | null
    _max: EmailAuthMaxAggregateOutputType | null
  }

  export type EmailAuthMinAggregateOutputType = {
    email: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmailAuthMaxAggregateOutputType = {
    email: string | null
    password: string | null
    verified: boolean | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type EmailAuthCountAggregateOutputType = {
    email: number
    password: number
    verified: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type EmailAuthMinAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmailAuthMaxAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type EmailAuthCountAggregateInputType = {
    email?: true
    password?: true
    verified?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type EmailAuthAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAuth to aggregate.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailAuths
    **/
    _count?: true | EmailAuthCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailAuthMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailAuthMaxAggregateInputType
  }

  export type GetEmailAuthAggregateType<T extends EmailAuthAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailAuth]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailAuth[P]>
      : GetScalarType<T[P], AggregateEmailAuth[P]>
  }




  export type EmailAuthGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailAuthWhereInput
    orderBy?: EmailAuthOrderByWithAggregationInput | EmailAuthOrderByWithAggregationInput[]
    by: EmailAuthScalarFieldEnum[] | EmailAuthScalarFieldEnum
    having?: EmailAuthScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailAuthCountAggregateInputType | true
    _min?: EmailAuthMinAggregateInputType
    _max?: EmailAuthMaxAggregateInputType
  }

  export type EmailAuthGroupByOutputType = {
    email: string
    password: string
    verified: boolean
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: EmailAuthCountAggregateOutputType | null
    _min: EmailAuthMinAggregateOutputType | null
    _max: EmailAuthMaxAggregateOutputType | null
  }

  type GetEmailAuthGroupByPayload<T extends EmailAuthGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailAuthGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailAuthGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailAuthGroupByOutputType[P]>
            : GetScalarType<T[P], EmailAuthGroupByOutputType[P]>
        }
      >
    >


  export type EmailAuthSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailAuth"]>

  export type EmailAuthSelectScalar = {
    email?: boolean
    password?: boolean
    verified?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type EmailAuthOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"email" | "password" | "verified" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["emailAuth"]>
  export type EmailAuthInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type EmailAuthIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type EmailAuthIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $EmailAuthPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailAuth"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      email: string
      password: string
      verified: boolean
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["emailAuth"]>
    composites: {}
  }

  type EmailAuthGetPayload<S extends boolean | null | undefined | EmailAuthDefaultArgs> = $Result.GetResult<Prisma.$EmailAuthPayload, S>

  type EmailAuthCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailAuthFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailAuthCountAggregateInputType | true
    }

  export interface EmailAuthDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailAuth'], meta: { name: 'EmailAuth' } }
    /**
     * Find zero or one EmailAuth that matches the filter.
     * @param {EmailAuthFindUniqueArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailAuthFindUniqueArgs>(args: SelectSubset<T, EmailAuthFindUniqueArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailAuth that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailAuthFindUniqueOrThrowArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailAuthFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailAuthFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAuth that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindFirstArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailAuthFindFirstArgs>(args?: SelectSubset<T, EmailAuthFindFirstArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailAuth that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindFirstOrThrowArgs} args - Arguments to find a EmailAuth
     * @example
     * // Get one EmailAuth
     * const emailAuth = await prisma.emailAuth.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailAuthFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailAuthFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailAuths that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailAuths
     * const emailAuths = await prisma.emailAuth.findMany()
     * 
     * // Get first 10 EmailAuths
     * const emailAuths = await prisma.emailAuth.findMany({ take: 10 })
     * 
     * // Only select the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.findMany({ select: { email: true } })
     * 
     */
    findMany<T extends EmailAuthFindManyArgs>(args?: SelectSubset<T, EmailAuthFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailAuth.
     * @param {EmailAuthCreateArgs} args - Arguments to create a EmailAuth.
     * @example
     * // Create one EmailAuth
     * const EmailAuth = await prisma.emailAuth.create({
     *   data: {
     *     // ... data to create a EmailAuth
     *   }
     * })
     * 
     */
    create<T extends EmailAuthCreateArgs>(args: SelectSubset<T, EmailAuthCreateArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailAuths.
     * @param {EmailAuthCreateManyArgs} args - Arguments to create many EmailAuths.
     * @example
     * // Create many EmailAuths
     * const emailAuth = await prisma.emailAuth.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailAuthCreateManyArgs>(args?: SelectSubset<T, EmailAuthCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailAuths and returns the data saved in the database.
     * @param {EmailAuthCreateManyAndReturnArgs} args - Arguments to create many EmailAuths.
     * @example
     * // Create many EmailAuths
     * const emailAuth = await prisma.emailAuth.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailAuths and only return the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.createManyAndReturn({
     *   select: { email: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailAuthCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailAuthCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailAuth.
     * @param {EmailAuthDeleteArgs} args - Arguments to delete one EmailAuth.
     * @example
     * // Delete one EmailAuth
     * const EmailAuth = await prisma.emailAuth.delete({
     *   where: {
     *     // ... filter to delete one EmailAuth
     *   }
     * })
     * 
     */
    delete<T extends EmailAuthDeleteArgs>(args: SelectSubset<T, EmailAuthDeleteArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailAuth.
     * @param {EmailAuthUpdateArgs} args - Arguments to update one EmailAuth.
     * @example
     * // Update one EmailAuth
     * const emailAuth = await prisma.emailAuth.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailAuthUpdateArgs>(args: SelectSubset<T, EmailAuthUpdateArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailAuths.
     * @param {EmailAuthDeleteManyArgs} args - Arguments to filter EmailAuths to delete.
     * @example
     * // Delete a few EmailAuths
     * const { count } = await prisma.emailAuth.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailAuthDeleteManyArgs>(args?: SelectSubset<T, EmailAuthDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailAuths
     * const emailAuth = await prisma.emailAuth.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailAuthUpdateManyArgs>(args: SelectSubset<T, EmailAuthUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailAuths and returns the data updated in the database.
     * @param {EmailAuthUpdateManyAndReturnArgs} args - Arguments to update many EmailAuths.
     * @example
     * // Update many EmailAuths
     * const emailAuth = await prisma.emailAuth.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailAuths and only return the `email`
     * const emailAuthWithEmailOnly = await prisma.emailAuth.updateManyAndReturn({
     *   select: { email: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailAuthUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailAuthUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailAuth.
     * @param {EmailAuthUpsertArgs} args - Arguments to update or create a EmailAuth.
     * @example
     * // Update or create a EmailAuth
     * const emailAuth = await prisma.emailAuth.upsert({
     *   create: {
     *     // ... data to create a EmailAuth
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailAuth we want to update
     *   }
     * })
     */
    upsert<T extends EmailAuthUpsertArgs>(args: SelectSubset<T, EmailAuthUpsertArgs<ExtArgs>>): Prisma__EmailAuthClient<$Result.GetResult<Prisma.$EmailAuthPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailAuths.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthCountArgs} args - Arguments to filter EmailAuths to count.
     * @example
     * // Count the number of EmailAuths
     * const count = await prisma.emailAuth.count({
     *   where: {
     *     // ... the filter for the EmailAuths we want to count
     *   }
     * })
    **/
    count<T extends EmailAuthCountArgs>(
      args?: Subset<T, EmailAuthCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailAuthCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailAuthAggregateArgs>(args: Subset<T, EmailAuthAggregateArgs>): Prisma.PrismaPromise<GetEmailAuthAggregateType<T>>

    /**
     * Group by EmailAuth.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailAuthGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailAuthGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailAuthGroupByArgs['orderBy'] }
        : { orderBy?: EmailAuthGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailAuthGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailAuthGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailAuth model
   */
  readonly fields: EmailAuthFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailAuth.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailAuthClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailAuth model
   */
  interface EmailAuthFieldRefs {
    readonly email: FieldRef<"EmailAuth", 'String'>
    readonly password: FieldRef<"EmailAuth", 'String'>
    readonly verified: FieldRef<"EmailAuth", 'Boolean'>
    readonly isDeleted: FieldRef<"EmailAuth", 'Boolean'>
    readonly createdAt: FieldRef<"EmailAuth", 'DateTime'>
    readonly updatedAt: FieldRef<"EmailAuth", 'DateTime'>
    readonly deletedAt: FieldRef<"EmailAuth", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailAuth findUnique
   */
  export type EmailAuthFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth findUniqueOrThrow
   */
  export type EmailAuthFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth findFirst
   */
  export type EmailAuthFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAuths.
     */
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth findFirstOrThrow
   */
  export type EmailAuthFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuth to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailAuths.
     */
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth findMany
   */
  export type EmailAuthFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter, which EmailAuths to fetch.
     */
    where?: EmailAuthWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailAuths to fetch.
     */
    orderBy?: EmailAuthOrderByWithRelationInput | EmailAuthOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailAuths.
     */
    cursor?: EmailAuthWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` EmailAuths from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailAuths.
     */
    skip?: number
    distinct?: EmailAuthScalarFieldEnum | EmailAuthScalarFieldEnum[]
  }

  /**
   * EmailAuth create
   */
  export type EmailAuthCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailAuth.
     */
    data: XOR<EmailAuthCreateInput, EmailAuthUncheckedCreateInput>
  }

  /**
   * EmailAuth createMany
   */
  export type EmailAuthCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailAuths.
     */
    data: EmailAuthCreateManyInput | EmailAuthCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailAuth createManyAndReturn
   */
  export type EmailAuthCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * The data used to create many EmailAuths.
     */
    data: EmailAuthCreateManyInput | EmailAuthCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAuth update
   */
  export type EmailAuthUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailAuth.
     */
    data: XOR<EmailAuthUpdateInput, EmailAuthUncheckedUpdateInput>
    /**
     * Choose, which EmailAuth to update.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth updateMany
   */
  export type EmailAuthUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailAuths.
     */
    data: XOR<EmailAuthUpdateManyMutationInput, EmailAuthUncheckedUpdateManyInput>
    /**
     * Filter which EmailAuths to update
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to update.
     */
    limit?: number
  }

  /**
   * EmailAuth updateManyAndReturn
   */
  export type EmailAuthUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * The data used to update EmailAuths.
     */
    data: XOR<EmailAuthUpdateManyMutationInput, EmailAuthUncheckedUpdateManyInput>
    /**
     * Filter which EmailAuths to update
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailAuth upsert
   */
  export type EmailAuthUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailAuth to update in case it exists.
     */
    where: EmailAuthWhereUniqueInput
    /**
     * In case the EmailAuth found by the `where` argument doesn't exist, create a new EmailAuth with this data.
     */
    create: XOR<EmailAuthCreateInput, EmailAuthUncheckedCreateInput>
    /**
     * In case the EmailAuth was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailAuthUpdateInput, EmailAuthUncheckedUpdateInput>
  }

  /**
   * EmailAuth delete
   */
  export type EmailAuthDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
    /**
     * Filter which EmailAuth to delete.
     */
    where: EmailAuthWhereUniqueInput
  }

  /**
   * EmailAuth deleteMany
   */
  export type EmailAuthDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailAuths to delete
     */
    where?: EmailAuthWhereInput
    /**
     * Limit how many EmailAuths to delete.
     */
    limit?: number
  }

  /**
   * EmailAuth without action
   */
  export type EmailAuthDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailAuth
     */
    select?: EmailAuthSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailAuth
     */
    omit?: EmailAuthOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailAuthInclude<ExtArgs> | null
  }


  /**
   * Model RiskDetectionRecord
   */

  export type AggregateRiskDetectionRecord = {
    _count: RiskDetectionRecordCountAggregateOutputType | null
    _avg: RiskDetectionRecordAvgAggregateOutputType | null
    _sum: RiskDetectionRecordSumAggregateOutputType | null
    _min: RiskDetectionRecordMinAggregateOutputType | null
    _max: RiskDetectionRecordMaxAggregateOutputType | null
  }

  export type RiskDetectionRecordAvgAggregateOutputType = {
    status: number | null
  }

  export type RiskDetectionRecordSumAggregateOutputType = {
    status: number | null
  }

  export type RiskDetectionRecordMinAggregateOutputType = {
    id: string | null
    action: string | null
    status: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RiskDetectionRecordMaxAggregateOutputType = {
    id: string | null
    action: string | null
    status: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type RiskDetectionRecordCountAggregateOutputType = {
    id: number
    action: number
    data: number
    status: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type RiskDetectionRecordAvgAggregateInputType = {
    status?: true
  }

  export type RiskDetectionRecordSumAggregateInputType = {
    status?: true
  }

  export type RiskDetectionRecordMinAggregateInputType = {
    id?: true
    action?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RiskDetectionRecordMaxAggregateInputType = {
    id?: true
    action?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type RiskDetectionRecordCountAggregateInputType = {
    id?: true
    action?: true
    data?: true
    status?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type RiskDetectionRecordAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDetectionRecord to aggregate.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RiskDetectionRecords
    **/
    _count?: true | RiskDetectionRecordCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RiskDetectionRecordAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RiskDetectionRecordSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RiskDetectionRecordMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RiskDetectionRecordMaxAggregateInputType
  }

  export type GetRiskDetectionRecordAggregateType<T extends RiskDetectionRecordAggregateArgs> = {
        [P in keyof T & keyof AggregateRiskDetectionRecord]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRiskDetectionRecord[P]>
      : GetScalarType<T[P], AggregateRiskDetectionRecord[P]>
  }




  export type RiskDetectionRecordGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RiskDetectionRecordWhereInput
    orderBy?: RiskDetectionRecordOrderByWithAggregationInput | RiskDetectionRecordOrderByWithAggregationInput[]
    by: RiskDetectionRecordScalarFieldEnum[] | RiskDetectionRecordScalarFieldEnum
    having?: RiskDetectionRecordScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RiskDetectionRecordCountAggregateInputType | true
    _avg?: RiskDetectionRecordAvgAggregateInputType
    _sum?: RiskDetectionRecordSumAggregateInputType
    _min?: RiskDetectionRecordMinAggregateInputType
    _max?: RiskDetectionRecordMaxAggregateInputType
  }

  export type RiskDetectionRecordGroupByOutputType = {
    id: string
    action: string
    data: JsonValue | null
    status: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: RiskDetectionRecordCountAggregateOutputType | null
    _avg: RiskDetectionRecordAvgAggregateOutputType | null
    _sum: RiskDetectionRecordSumAggregateOutputType | null
    _min: RiskDetectionRecordMinAggregateOutputType | null
    _max: RiskDetectionRecordMaxAggregateOutputType | null
  }

  type GetRiskDetectionRecordGroupByPayload<T extends RiskDetectionRecordGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RiskDetectionRecordGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RiskDetectionRecordGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RiskDetectionRecordGroupByOutputType[P]>
            : GetScalarType<T[P], RiskDetectionRecordGroupByOutputType[P]>
        }
      >
    >


  export type RiskDetectionRecordSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["riskDetectionRecord"]>

  export type RiskDetectionRecordSelectScalar = {
    id?: boolean
    action?: boolean
    data?: boolean
    status?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type RiskDetectionRecordOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "action" | "data" | "status" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["riskDetectionRecord"]>

  export type $RiskDetectionRecordPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RiskDetectionRecord"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      action: string
      data: Prisma.JsonValue | null
      status: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["riskDetectionRecord"]>
    composites: {}
  }

  type RiskDetectionRecordGetPayload<S extends boolean | null | undefined | RiskDetectionRecordDefaultArgs> = $Result.GetResult<Prisma.$RiskDetectionRecordPayload, S>

  type RiskDetectionRecordCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<RiskDetectionRecordFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: RiskDetectionRecordCountAggregateInputType | true
    }

  export interface RiskDetectionRecordDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RiskDetectionRecord'], meta: { name: 'RiskDetectionRecord' } }
    /**
     * Find zero or one RiskDetectionRecord that matches the filter.
     * @param {RiskDetectionRecordFindUniqueArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RiskDetectionRecordFindUniqueArgs>(args: SelectSubset<T, RiskDetectionRecordFindUniqueArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one RiskDetectionRecord that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {RiskDetectionRecordFindUniqueOrThrowArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RiskDetectionRecordFindUniqueOrThrowArgs>(args: SelectSubset<T, RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDetectionRecord that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindFirstArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RiskDetectionRecordFindFirstArgs>(args?: SelectSubset<T, RiskDetectionRecordFindFirstArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first RiskDetectionRecord that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindFirstOrThrowArgs} args - Arguments to find a RiskDetectionRecord
     * @example
     * // Get one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RiskDetectionRecordFindFirstOrThrowArgs>(args?: SelectSubset<T, RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more RiskDetectionRecords that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RiskDetectionRecords
     * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany()
     * 
     * // Get first 10 RiskDetectionRecords
     * const riskDetectionRecords = await prisma.riskDetectionRecord.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RiskDetectionRecordFindManyArgs>(args?: SelectSubset<T, RiskDetectionRecordFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a RiskDetectionRecord.
     * @param {RiskDetectionRecordCreateArgs} args - Arguments to create a RiskDetectionRecord.
     * @example
     * // Create one RiskDetectionRecord
     * const RiskDetectionRecord = await prisma.riskDetectionRecord.create({
     *   data: {
     *     // ... data to create a RiskDetectionRecord
     *   }
     * })
     * 
     */
    create<T extends RiskDetectionRecordCreateArgs>(args: SelectSubset<T, RiskDetectionRecordCreateArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many RiskDetectionRecords.
     * @param {RiskDetectionRecordCreateManyArgs} args - Arguments to create many RiskDetectionRecords.
     * @example
     * // Create many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RiskDetectionRecordCreateManyArgs>(args?: SelectSubset<T, RiskDetectionRecordCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RiskDetectionRecords and returns the data saved in the database.
     * @param {RiskDetectionRecordCreateManyAndReturnArgs} args - Arguments to create many RiskDetectionRecords.
     * @example
     * // Create many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RiskDetectionRecords and only return the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RiskDetectionRecordCreateManyAndReturnArgs>(args?: SelectSubset<T, RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a RiskDetectionRecord.
     * @param {RiskDetectionRecordDeleteArgs} args - Arguments to delete one RiskDetectionRecord.
     * @example
     * // Delete one RiskDetectionRecord
     * const RiskDetectionRecord = await prisma.riskDetectionRecord.delete({
     *   where: {
     *     // ... filter to delete one RiskDetectionRecord
     *   }
     * })
     * 
     */
    delete<T extends RiskDetectionRecordDeleteArgs>(args: SelectSubset<T, RiskDetectionRecordDeleteArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one RiskDetectionRecord.
     * @param {RiskDetectionRecordUpdateArgs} args - Arguments to update one RiskDetectionRecord.
     * @example
     * // Update one RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RiskDetectionRecordUpdateArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more RiskDetectionRecords.
     * @param {RiskDetectionRecordDeleteManyArgs} args - Arguments to filter RiskDetectionRecords to delete.
     * @example
     * // Delete a few RiskDetectionRecords
     * const { count } = await prisma.riskDetectionRecord.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RiskDetectionRecordDeleteManyArgs>(args?: SelectSubset<T, RiskDetectionRecordDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDetectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RiskDetectionRecordUpdateManyArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RiskDetectionRecords and returns the data updated in the database.
     * @param {RiskDetectionRecordUpdateManyAndReturnArgs} args - Arguments to update many RiskDetectionRecords.
     * @example
     * // Update many RiskDetectionRecords
     * const riskDetectionRecord = await prisma.riskDetectionRecord.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more RiskDetectionRecords and only return the `id`
     * const riskDetectionRecordWithIdOnly = await prisma.riskDetectionRecord.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends RiskDetectionRecordUpdateManyAndReturnArgs>(args: SelectSubset<T, RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one RiskDetectionRecord.
     * @param {RiskDetectionRecordUpsertArgs} args - Arguments to update or create a RiskDetectionRecord.
     * @example
     * // Update or create a RiskDetectionRecord
     * const riskDetectionRecord = await prisma.riskDetectionRecord.upsert({
     *   create: {
     *     // ... data to create a RiskDetectionRecord
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RiskDetectionRecord we want to update
     *   }
     * })
     */
    upsert<T extends RiskDetectionRecordUpsertArgs>(args: SelectSubset<T, RiskDetectionRecordUpsertArgs<ExtArgs>>): Prisma__RiskDetectionRecordClient<$Result.GetResult<Prisma.$RiskDetectionRecordPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of RiskDetectionRecords.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordCountArgs} args - Arguments to filter RiskDetectionRecords to count.
     * @example
     * // Count the number of RiskDetectionRecords
     * const count = await prisma.riskDetectionRecord.count({
     *   where: {
     *     // ... the filter for the RiskDetectionRecords we want to count
     *   }
     * })
    **/
    count<T extends RiskDetectionRecordCountArgs>(
      args?: Subset<T, RiskDetectionRecordCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RiskDetectionRecordCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RiskDetectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RiskDetectionRecordAggregateArgs>(args: Subset<T, RiskDetectionRecordAggregateArgs>): Prisma.PrismaPromise<GetRiskDetectionRecordAggregateType<T>>

    /**
     * Group by RiskDetectionRecord.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RiskDetectionRecordGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RiskDetectionRecordGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RiskDetectionRecordGroupByArgs['orderBy'] }
        : { orderBy?: RiskDetectionRecordGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RiskDetectionRecordGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRiskDetectionRecordGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RiskDetectionRecord model
   */
  readonly fields: RiskDetectionRecordFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RiskDetectionRecord.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RiskDetectionRecordClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RiskDetectionRecord model
   */
  interface RiskDetectionRecordFieldRefs {
    readonly id: FieldRef<"RiskDetectionRecord", 'String'>
    readonly action: FieldRef<"RiskDetectionRecord", 'String'>
    readonly data: FieldRef<"RiskDetectionRecord", 'Json'>
    readonly status: FieldRef<"RiskDetectionRecord", 'Int'>
    readonly isDeleted: FieldRef<"RiskDetectionRecord", 'Boolean'>
    readonly createdAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
    readonly updatedAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
    readonly deletedAt: FieldRef<"RiskDetectionRecord", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RiskDetectionRecord findUnique
   */
  export type RiskDetectionRecordFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord findUniqueOrThrow
   */
  export type RiskDetectionRecordFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord findFirst
   */
  export type RiskDetectionRecordFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDetectionRecords.
     */
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord findFirstOrThrow
   */
  export type RiskDetectionRecordFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecord to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RiskDetectionRecords.
     */
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord findMany
   */
  export type RiskDetectionRecordFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter, which RiskDetectionRecords to fetch.
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RiskDetectionRecords to fetch.
     */
    orderBy?: RiskDetectionRecordOrderByWithRelationInput | RiskDetectionRecordOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RiskDetectionRecords.
     */
    cursor?: RiskDetectionRecordWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` RiskDetectionRecords from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RiskDetectionRecords.
     */
    skip?: number
    distinct?: RiskDetectionRecordScalarFieldEnum | RiskDetectionRecordScalarFieldEnum[]
  }

  /**
   * RiskDetectionRecord create
   */
  export type RiskDetectionRecordCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data needed to create a RiskDetectionRecord.
     */
    data: XOR<RiskDetectionRecordCreateInput, RiskDetectionRecordUncheckedCreateInput>
  }

  /**
   * RiskDetectionRecord createMany
   */
  export type RiskDetectionRecordCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RiskDetectionRecords.
     */
    data: RiskDetectionRecordCreateManyInput | RiskDetectionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskDetectionRecord createManyAndReturn
   */
  export type RiskDetectionRecordCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data used to create many RiskDetectionRecords.
     */
    data: RiskDetectionRecordCreateManyInput | RiskDetectionRecordCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RiskDetectionRecord update
   */
  export type RiskDetectionRecordUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data needed to update a RiskDetectionRecord.
     */
    data: XOR<RiskDetectionRecordUpdateInput, RiskDetectionRecordUncheckedUpdateInput>
    /**
     * Choose, which RiskDetectionRecord to update.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord updateMany
   */
  export type RiskDetectionRecordUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RiskDetectionRecords.
     */
    data: XOR<RiskDetectionRecordUpdateManyMutationInput, RiskDetectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which RiskDetectionRecords to update
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to update.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord updateManyAndReturn
   */
  export type RiskDetectionRecordUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The data used to update RiskDetectionRecords.
     */
    data: XOR<RiskDetectionRecordUpdateManyMutationInput, RiskDetectionRecordUncheckedUpdateManyInput>
    /**
     * Filter which RiskDetectionRecords to update
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to update.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord upsert
   */
  export type RiskDetectionRecordUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * The filter to search for the RiskDetectionRecord to update in case it exists.
     */
    where: RiskDetectionRecordWhereUniqueInput
    /**
     * In case the RiskDetectionRecord found by the `where` argument doesn't exist, create a new RiskDetectionRecord with this data.
     */
    create: XOR<RiskDetectionRecordCreateInput, RiskDetectionRecordUncheckedCreateInput>
    /**
     * In case the RiskDetectionRecord was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RiskDetectionRecordUpdateInput, RiskDetectionRecordUncheckedUpdateInput>
  }

  /**
   * RiskDetectionRecord delete
   */
  export type RiskDetectionRecordDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
    /**
     * Filter which RiskDetectionRecord to delete.
     */
    where: RiskDetectionRecordWhereUniqueInput
  }

  /**
   * RiskDetectionRecord deleteMany
   */
  export type RiskDetectionRecordDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RiskDetectionRecords to delete
     */
    where?: RiskDetectionRecordWhereInput
    /**
     * Limit how many RiskDetectionRecords to delete.
     */
    limit?: number
  }

  /**
   * RiskDetectionRecord without action
   */
  export type RiskDetectionRecordDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RiskDetectionRecord
     */
    select?: RiskDetectionRecordSelect<ExtArgs> | null
    /**
     * Omit specific fields from the RiskDetectionRecord
     */
    omit?: RiskDetectionRecordOmit<ExtArgs> | null
  }


  /**
   * Model SystemTaskQueue
   */

  export type AggregateSystemTaskQueue = {
    _count: SystemTaskQueueCountAggregateOutputType | null
    _avg: SystemTaskQueueAvgAggregateOutputType | null
    _sum: SystemTaskQueueSumAggregateOutputType | null
    _min: SystemTaskQueueMinAggregateOutputType | null
    _max: SystemTaskQueueMaxAggregateOutputType | null
  }

  export type SystemTaskQueueAvgAggregateOutputType = {
    retryCount: number | null
  }

  export type SystemTaskQueueSumAggregateOutputType = {
    retryCount: number | null
  }

  export type SystemTaskQueueMinAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    recipient: string | null
    templateCode: string | null
    content: string | null
    subject: string | null
    retryCount: number | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemTaskQueueMaxAggregateOutputType = {
    id: string | null
    taskType: $Enums.TaskType | null
    status: $Enums.TaskStatus | null
    recipient: string | null
    templateCode: string | null
    content: string | null
    subject: string | null
    retryCount: number | null
    processedAt: Date | null
    errorMessage: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SystemTaskQueueCountAggregateOutputType = {
    id: number
    taskType: number
    status: number
    recipient: number
    templateCode: number
    templateData: number
    content: number
    subject: number
    retryCount: number
    processedAt: number
    errorMessage: number
    metadata: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SystemTaskQueueAvgAggregateInputType = {
    retryCount?: true
  }

  export type SystemTaskQueueSumAggregateInputType = {
    retryCount?: true
  }

  export type SystemTaskQueueMinAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemTaskQueueMaxAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SystemTaskQueueCountAggregateInputType = {
    id?: true
    taskType?: true
    status?: true
    recipient?: true
    templateCode?: true
    templateData?: true
    content?: true
    subject?: true
    retryCount?: true
    processedAt?: true
    errorMessage?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SystemTaskQueueAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemTaskQueue to aggregate.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemTaskQueues
    **/
    _count?: true | SystemTaskQueueCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SystemTaskQueueAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SystemTaskQueueSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemTaskQueueMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemTaskQueueMaxAggregateInputType
  }

  export type GetSystemTaskQueueAggregateType<T extends SystemTaskQueueAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemTaskQueue]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemTaskQueue[P]>
      : GetScalarType<T[P], AggregateSystemTaskQueue[P]>
  }




  export type SystemTaskQueueGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemTaskQueueWhereInput
    orderBy?: SystemTaskQueueOrderByWithAggregationInput | SystemTaskQueueOrderByWithAggregationInput[]
    by: SystemTaskQueueScalarFieldEnum[] | SystemTaskQueueScalarFieldEnum
    having?: SystemTaskQueueScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemTaskQueueCountAggregateInputType | true
    _avg?: SystemTaskQueueAvgAggregateInputType
    _sum?: SystemTaskQueueSumAggregateInputType
    _min?: SystemTaskQueueMinAggregateInputType
    _max?: SystemTaskQueueMaxAggregateInputType
  }

  export type SystemTaskQueueGroupByOutputType = {
    id: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode: string | null
    templateData: JsonValue | null
    content: string | null
    subject: string | null
    retryCount: number
    processedAt: Date
    errorMessage: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    _count: SystemTaskQueueCountAggregateOutputType | null
    _avg: SystemTaskQueueAvgAggregateOutputType | null
    _sum: SystemTaskQueueSumAggregateOutputType | null
    _min: SystemTaskQueueMinAggregateOutputType | null
    _max: SystemTaskQueueMaxAggregateOutputType | null
  }

  type GetSystemTaskQueueGroupByPayload<T extends SystemTaskQueueGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemTaskQueueGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemTaskQueueGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemTaskQueueGroupByOutputType[P]>
            : GetScalarType<T[P], SystemTaskQueueGroupByOutputType[P]>
        }
      >
    >


  export type SystemTaskQueueSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["systemTaskQueue"]>

  export type SystemTaskQueueSelectScalar = {
    id?: boolean
    taskType?: boolean
    status?: boolean
    recipient?: boolean
    templateCode?: boolean
    templateData?: boolean
    content?: boolean
    subject?: boolean
    retryCount?: boolean
    processedAt?: boolean
    errorMessage?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type SystemTaskQueueOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "taskType" | "status" | "recipient" | "templateCode" | "templateData" | "content" | "subject" | "retryCount" | "processedAt" | "errorMessage" | "metadata" | "createdAt" | "updatedAt", ExtArgs["result"]["systemTaskQueue"]>

  export type $SystemTaskQueuePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemTaskQueue"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      taskType: $Enums.TaskType
      status: $Enums.TaskStatus
      recipient: string
      templateCode: string | null
      templateData: Prisma.JsonValue | null
      content: string | null
      subject: string | null
      retryCount: number
      processedAt: Date
      errorMessage: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["systemTaskQueue"]>
    composites: {}
  }

  type SystemTaskQueueGetPayload<S extends boolean | null | undefined | SystemTaskQueueDefaultArgs> = $Result.GetResult<Prisma.$SystemTaskQueuePayload, S>

  type SystemTaskQueueCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemTaskQueueFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemTaskQueueCountAggregateInputType | true
    }

  export interface SystemTaskQueueDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemTaskQueue'], meta: { name: 'SystemTaskQueue' } }
    /**
     * Find zero or one SystemTaskQueue that matches the filter.
     * @param {SystemTaskQueueFindUniqueArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemTaskQueueFindUniqueArgs>(args: SelectSubset<T, SystemTaskQueueFindUniqueArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemTaskQueue that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemTaskQueueFindUniqueOrThrowArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemTaskQueueFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemTaskQueue that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindFirstArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemTaskQueueFindFirstArgs>(args?: SelectSubset<T, SystemTaskQueueFindFirstArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemTaskQueue that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindFirstOrThrowArgs} args - Arguments to find a SystemTaskQueue
     * @example
     * // Get one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemTaskQueueFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemTaskQueueFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemTaskQueues that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemTaskQueues
     * const systemTaskQueues = await prisma.systemTaskQueue.findMany()
     * 
     * // Get first 10 SystemTaskQueues
     * const systemTaskQueues = await prisma.systemTaskQueue.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemTaskQueueFindManyArgs>(args?: SelectSubset<T, SystemTaskQueueFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemTaskQueue.
     * @param {SystemTaskQueueCreateArgs} args - Arguments to create a SystemTaskQueue.
     * @example
     * // Create one SystemTaskQueue
     * const SystemTaskQueue = await prisma.systemTaskQueue.create({
     *   data: {
     *     // ... data to create a SystemTaskQueue
     *   }
     * })
     * 
     */
    create<T extends SystemTaskQueueCreateArgs>(args: SelectSubset<T, SystemTaskQueueCreateArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemTaskQueues.
     * @param {SystemTaskQueueCreateManyArgs} args - Arguments to create many SystemTaskQueues.
     * @example
     * // Create many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemTaskQueueCreateManyArgs>(args?: SelectSubset<T, SystemTaskQueueCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemTaskQueues and returns the data saved in the database.
     * @param {SystemTaskQueueCreateManyAndReturnArgs} args - Arguments to create many SystemTaskQueues.
     * @example
     * // Create many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemTaskQueues and only return the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemTaskQueueCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemTaskQueueCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemTaskQueue.
     * @param {SystemTaskQueueDeleteArgs} args - Arguments to delete one SystemTaskQueue.
     * @example
     * // Delete one SystemTaskQueue
     * const SystemTaskQueue = await prisma.systemTaskQueue.delete({
     *   where: {
     *     // ... filter to delete one SystemTaskQueue
     *   }
     * })
     * 
     */
    delete<T extends SystemTaskQueueDeleteArgs>(args: SelectSubset<T, SystemTaskQueueDeleteArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemTaskQueue.
     * @param {SystemTaskQueueUpdateArgs} args - Arguments to update one SystemTaskQueue.
     * @example
     * // Update one SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemTaskQueueUpdateArgs>(args: SelectSubset<T, SystemTaskQueueUpdateArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemTaskQueues.
     * @param {SystemTaskQueueDeleteManyArgs} args - Arguments to filter SystemTaskQueues to delete.
     * @example
     * // Delete a few SystemTaskQueues
     * const { count } = await prisma.systemTaskQueue.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemTaskQueueDeleteManyArgs>(args?: SelectSubset<T, SystemTaskQueueDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemTaskQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemTaskQueueUpdateManyArgs>(args: SelectSubset<T, SystemTaskQueueUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemTaskQueues and returns the data updated in the database.
     * @param {SystemTaskQueueUpdateManyAndReturnArgs} args - Arguments to update many SystemTaskQueues.
     * @example
     * // Update many SystemTaskQueues
     * const systemTaskQueue = await prisma.systemTaskQueue.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemTaskQueues and only return the `id`
     * const systemTaskQueueWithIdOnly = await prisma.systemTaskQueue.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemTaskQueueUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemTaskQueue.
     * @param {SystemTaskQueueUpsertArgs} args - Arguments to update or create a SystemTaskQueue.
     * @example
     * // Update or create a SystemTaskQueue
     * const systemTaskQueue = await prisma.systemTaskQueue.upsert({
     *   create: {
     *     // ... data to create a SystemTaskQueue
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemTaskQueue we want to update
     *   }
     * })
     */
    upsert<T extends SystemTaskQueueUpsertArgs>(args: SelectSubset<T, SystemTaskQueueUpsertArgs<ExtArgs>>): Prisma__SystemTaskQueueClient<$Result.GetResult<Prisma.$SystemTaskQueuePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemTaskQueues.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueCountArgs} args - Arguments to filter SystemTaskQueues to count.
     * @example
     * // Count the number of SystemTaskQueues
     * const count = await prisma.systemTaskQueue.count({
     *   where: {
     *     // ... the filter for the SystemTaskQueues we want to count
     *   }
     * })
    **/
    count<T extends SystemTaskQueueCountArgs>(
      args?: Subset<T, SystemTaskQueueCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemTaskQueueCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemTaskQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemTaskQueueAggregateArgs>(args: Subset<T, SystemTaskQueueAggregateArgs>): Prisma.PrismaPromise<GetSystemTaskQueueAggregateType<T>>

    /**
     * Group by SystemTaskQueue.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemTaskQueueGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemTaskQueueGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemTaskQueueGroupByArgs['orderBy'] }
        : { orderBy?: SystemTaskQueueGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemTaskQueueGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemTaskQueueGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemTaskQueue model
   */
  readonly fields: SystemTaskQueueFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemTaskQueue.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemTaskQueueClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemTaskQueue model
   */
  interface SystemTaskQueueFieldRefs {
    readonly id: FieldRef<"SystemTaskQueue", 'String'>
    readonly taskType: FieldRef<"SystemTaskQueue", 'TaskType'>
    readonly status: FieldRef<"SystemTaskQueue", 'TaskStatus'>
    readonly recipient: FieldRef<"SystemTaskQueue", 'String'>
    readonly templateCode: FieldRef<"SystemTaskQueue", 'String'>
    readonly templateData: FieldRef<"SystemTaskQueue", 'Json'>
    readonly content: FieldRef<"SystemTaskQueue", 'String'>
    readonly subject: FieldRef<"SystemTaskQueue", 'String'>
    readonly retryCount: FieldRef<"SystemTaskQueue", 'Int'>
    readonly processedAt: FieldRef<"SystemTaskQueue", 'DateTime'>
    readonly errorMessage: FieldRef<"SystemTaskQueue", 'String'>
    readonly metadata: FieldRef<"SystemTaskQueue", 'Json'>
    readonly createdAt: FieldRef<"SystemTaskQueue", 'DateTime'>
    readonly updatedAt: FieldRef<"SystemTaskQueue", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemTaskQueue findUnique
   */
  export type SystemTaskQueueFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue findUniqueOrThrow
   */
  export type SystemTaskQueueFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue findFirst
   */
  export type SystemTaskQueueFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTaskQueues.
     */
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue findFirstOrThrow
   */
  export type SystemTaskQueueFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueue to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemTaskQueues.
     */
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue findMany
   */
  export type SystemTaskQueueFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter, which SystemTaskQueues to fetch.
     */
    where?: SystemTaskQueueWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemTaskQueues to fetch.
     */
    orderBy?: SystemTaskQueueOrderByWithRelationInput | SystemTaskQueueOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemTaskQueues.
     */
    cursor?: SystemTaskQueueWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` SystemTaskQueues from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemTaskQueues.
     */
    skip?: number
    distinct?: SystemTaskQueueScalarFieldEnum | SystemTaskQueueScalarFieldEnum[]
  }

  /**
   * SystemTaskQueue create
   */
  export type SystemTaskQueueCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemTaskQueue.
     */
    data: XOR<SystemTaskQueueCreateInput, SystemTaskQueueUncheckedCreateInput>
  }

  /**
   * SystemTaskQueue createMany
   */
  export type SystemTaskQueueCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemTaskQueues.
     */
    data: SystemTaskQueueCreateManyInput | SystemTaskQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemTaskQueue createManyAndReturn
   */
  export type SystemTaskQueueCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data used to create many SystemTaskQueues.
     */
    data: SystemTaskQueueCreateManyInput | SystemTaskQueueCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemTaskQueue update
   */
  export type SystemTaskQueueUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemTaskQueue.
     */
    data: XOR<SystemTaskQueueUpdateInput, SystemTaskQueueUncheckedUpdateInput>
    /**
     * Choose, which SystemTaskQueue to update.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue updateMany
   */
  export type SystemTaskQueueUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemTaskQueues.
     */
    data: XOR<SystemTaskQueueUpdateManyMutationInput, SystemTaskQueueUncheckedUpdateManyInput>
    /**
     * Filter which SystemTaskQueues to update
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to update.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue updateManyAndReturn
   */
  export type SystemTaskQueueUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The data used to update SystemTaskQueues.
     */
    data: XOR<SystemTaskQueueUpdateManyMutationInput, SystemTaskQueueUncheckedUpdateManyInput>
    /**
     * Filter which SystemTaskQueues to update
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to update.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue upsert
   */
  export type SystemTaskQueueUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemTaskQueue to update in case it exists.
     */
    where: SystemTaskQueueWhereUniqueInput
    /**
     * In case the SystemTaskQueue found by the `where` argument doesn't exist, create a new SystemTaskQueue with this data.
     */
    create: XOR<SystemTaskQueueCreateInput, SystemTaskQueueUncheckedCreateInput>
    /**
     * In case the SystemTaskQueue was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemTaskQueueUpdateInput, SystemTaskQueueUncheckedUpdateInput>
  }

  /**
   * SystemTaskQueue delete
   */
  export type SystemTaskQueueDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
    /**
     * Filter which SystemTaskQueue to delete.
     */
    where: SystemTaskQueueWhereUniqueInput
  }

  /**
   * SystemTaskQueue deleteMany
   */
  export type SystemTaskQueueDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemTaskQueues to delete
     */
    where?: SystemTaskQueueWhereInput
    /**
     * Limit how many SystemTaskQueues to delete.
     */
    limit?: number
  }

  /**
   * SystemTaskQueue without action
   */
  export type SystemTaskQueueDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemTaskQueue
     */
    select?: SystemTaskQueueSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemTaskQueue
     */
    omit?: SystemTaskQueueOmit<ExtArgs> | null
  }


  /**
   * Model FileSource
   */

  export type AggregateFileSource = {
    _count: FileSourceCountAggregateOutputType | null
    _avg: FileSourceAvgAggregateOutputType | null
    _sum: FileSourceSumAggregateOutputType | null
    _min: FileSourceMinAggregateOutputType | null
    _max: FileSourceMaxAggregateOutputType | null
  }

  export type FileSourceAvgAggregateOutputType = {
    fsize: number | null
    type: number | null
    status: number | null
    parts: number | null
  }

  export type FileSourceSumAggregateOutputType = {
    fsize: number | null
    type: number | null
    status: number | null
    parts: number[]
  }

  export type FileSourceMinAggregateOutputType = {
    id: string | null
    isUploaded: boolean | null
    bucket: string | null
    key: string | null
    hash: string | null
    thumbImg: string | null
    fsize: number | null
    mimeType: string | null
    type: number | null
    endUser: string | null
    status: number | null
    sha256: string | null
    ext: string | null
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType | null
    vendor: $Enums.FileBucketVendor | null
    region: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileSourceMaxAggregateOutputType = {
    id: string | null
    isUploaded: boolean | null
    bucket: string | null
    key: string | null
    hash: string | null
    thumbImg: string | null
    fsize: number | null
    mimeType: string | null
    type: number | null
    endUser: string | null
    status: number | null
    sha256: string | null
    ext: string | null
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType | null
    vendor: $Enums.FileBucketVendor | null
    region: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type FileSourceCountAggregateOutputType = {
    id: number
    isUploaded: number
    bucket: number
    key: number
    hash: number
    thumbImg: number
    fsize: number
    mimeType: number
    type: number
    endUser: number
    status: number
    sha256: number
    parts: number
    ext: number
    expireAt: number
    transitionToIaAt: number
    transitionToArchiveAt: number
    transitionToDeepArchiveAt: number
    transitionToArchiveIRAt: number
    env: number
    vendor: number
    region: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type FileSourceAvgAggregateInputType = {
    fsize?: true
    type?: true
    status?: true
    parts?: true
  }

  export type FileSourceSumAggregateInputType = {
    fsize?: true
    type?: true
    status?: true
    parts?: true
  }

  export type FileSourceMinAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileSourceMaxAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type FileSourceCountAggregateInputType = {
    id?: true
    isUploaded?: true
    bucket?: true
    key?: true
    hash?: true
    thumbImg?: true
    fsize?: true
    mimeType?: true
    type?: true
    endUser?: true
    status?: true
    sha256?: true
    parts?: true
    ext?: true
    expireAt?: true
    transitionToIaAt?: true
    transitionToArchiveAt?: true
    transitionToDeepArchiveAt?: true
    transitionToArchiveIRAt?: true
    env?: true
    vendor?: true
    region?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type FileSourceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileSource to aggregate.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned FileSources
    **/
    _count?: true | FileSourceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileSourceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSourceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileSourceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileSourceMaxAggregateInputType
  }

  export type GetFileSourceAggregateType<T extends FileSourceAggregateArgs> = {
        [P in keyof T & keyof AggregateFileSource]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFileSource[P]>
      : GetScalarType<T[P], AggregateFileSource[P]>
  }




  export type FileSourceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileSourceWhereInput
    orderBy?: FileSourceOrderByWithAggregationInput | FileSourceOrderByWithAggregationInput[]
    by: FileSourceScalarFieldEnum[] | FileSourceScalarFieldEnum
    having?: FileSourceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileSourceCountAggregateInputType | true
    _avg?: FileSourceAvgAggregateInputType
    _sum?: FileSourceSumAggregateInputType
    _min?: FileSourceMinAggregateInputType
    _max?: FileSourceMaxAggregateInputType
  }

  export type FileSourceGroupByOutputType = {
    id: string
    isUploaded: boolean
    bucket: string
    key: string
    hash: string | null
    thumbImg: string | null
    fsize: number
    mimeType: string
    type: number
    endUser: string | null
    status: number
    sha256: string | null
    parts: number[]
    ext: string
    expireAt: Date | null
    transitionToIaAt: Date | null
    transitionToArchiveAt: Date | null
    transitionToDeepArchiveAt: Date | null
    transitionToArchiveIRAt: Date | null
    env: $Enums.FileEnvType
    vendor: $Enums.FileBucketVendor
    region: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: FileSourceCountAggregateOutputType | null
    _avg: FileSourceAvgAggregateOutputType | null
    _sum: FileSourceSumAggregateOutputType | null
    _min: FileSourceMinAggregateOutputType | null
    _max: FileSourceMaxAggregateOutputType | null
  }

  type GetFileSourceGroupByPayload<T extends FileSourceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileSourceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileSourceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileSourceGroupByOutputType[P]>
            : GetScalarType<T[P], FileSourceGroupByOutputType[P]>
        }
      >
    >


  export type FileSourceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    userAvatars?: boolean | FileSource$userAvatarsArgs<ExtArgs>
    personaTemplates?: boolean | FileSource$personaTemplatesArgs<ExtArgs>
    botAvatars?: boolean | FileSource$botAvatarsArgs<ExtArgs>
    _count?: boolean | FileSourceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["fileSource"]>

  export type FileSourceSelectScalar = {
    id?: boolean
    isUploaded?: boolean
    bucket?: boolean
    key?: boolean
    hash?: boolean
    thumbImg?: boolean
    fsize?: boolean
    mimeType?: boolean
    type?: boolean
    endUser?: boolean
    status?: boolean
    sha256?: boolean
    parts?: boolean
    ext?: boolean
    expireAt?: boolean
    transitionToIaAt?: boolean
    transitionToArchiveAt?: boolean
    transitionToDeepArchiveAt?: boolean
    transitionToArchiveIRAt?: boolean
    env?: boolean
    vendor?: boolean
    region?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type FileSourceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "isUploaded" | "bucket" | "key" | "hash" | "thumbImg" | "fsize" | "mimeType" | "type" | "endUser" | "status" | "sha256" | "parts" | "ext" | "expireAt" | "transitionToIaAt" | "transitionToArchiveAt" | "transitionToDeepArchiveAt" | "transitionToArchiveIRAt" | "env" | "vendor" | "region" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["fileSource"]>
  export type FileSourceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    userAvatars?: boolean | FileSource$userAvatarsArgs<ExtArgs>
    personaTemplates?: boolean | FileSource$personaTemplatesArgs<ExtArgs>
    botAvatars?: boolean | FileSource$botAvatarsArgs<ExtArgs>
    _count?: boolean | FileSourceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileSourceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type FileSourceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $FileSourcePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "FileSource"
    objects: {
      userAvatars: Prisma.$UserInfoPayload<ExtArgs>[]
      personaTemplates: Prisma.$PersonaTemplatePayload<ExtArgs>[]
      botAvatars: Prisma.$BotPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      isUploaded: boolean
      bucket: string
      key: string
      hash: string | null
      thumbImg: string | null
      fsize: number
      mimeType: string
      type: number
      endUser: string | null
      status: number
      sha256: string | null
      parts: number[]
      ext: string
      expireAt: Date | null
      transitionToIaAt: Date | null
      transitionToArchiveAt: Date | null
      transitionToDeepArchiveAt: Date | null
      transitionToArchiveIRAt: Date | null
      env: $Enums.FileEnvType
      vendor: $Enums.FileBucketVendor
      region: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["fileSource"]>
    composites: {}
  }

  type FileSourceGetPayload<S extends boolean | null | undefined | FileSourceDefaultArgs> = $Result.GetResult<Prisma.$FileSourcePayload, S>

  type FileSourceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileSourceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileSourceCountAggregateInputType | true
    }

  export interface FileSourceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['FileSource'], meta: { name: 'FileSource' } }
    /**
     * Find zero or one FileSource that matches the filter.
     * @param {FileSourceFindUniqueArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileSourceFindUniqueArgs>(args: SelectSubset<T, FileSourceFindUniqueArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one FileSource that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileSourceFindUniqueOrThrowArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileSourceFindUniqueOrThrowArgs>(args: SelectSubset<T, FileSourceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileSource that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindFirstArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileSourceFindFirstArgs>(args?: SelectSubset<T, FileSourceFindFirstArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first FileSource that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindFirstOrThrowArgs} args - Arguments to find a FileSource
     * @example
     * // Get one FileSource
     * const fileSource = await prisma.fileSource.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileSourceFindFirstOrThrowArgs>(args?: SelectSubset<T, FileSourceFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more FileSources that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all FileSources
     * const fileSources = await prisma.fileSource.findMany()
     * 
     * // Get first 10 FileSources
     * const fileSources = await prisma.fileSource.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileSourceFindManyArgs>(args?: SelectSubset<T, FileSourceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a FileSource.
     * @param {FileSourceCreateArgs} args - Arguments to create a FileSource.
     * @example
     * // Create one FileSource
     * const FileSource = await prisma.fileSource.create({
     *   data: {
     *     // ... data to create a FileSource
     *   }
     * })
     * 
     */
    create<T extends FileSourceCreateArgs>(args: SelectSubset<T, FileSourceCreateArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many FileSources.
     * @param {FileSourceCreateManyArgs} args - Arguments to create many FileSources.
     * @example
     * // Create many FileSources
     * const fileSource = await prisma.fileSource.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileSourceCreateManyArgs>(args?: SelectSubset<T, FileSourceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many FileSources and returns the data saved in the database.
     * @param {FileSourceCreateManyAndReturnArgs} args - Arguments to create many FileSources.
     * @example
     * // Create many FileSources
     * const fileSource = await prisma.fileSource.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many FileSources and only return the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileSourceCreateManyAndReturnArgs>(args?: SelectSubset<T, FileSourceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a FileSource.
     * @param {FileSourceDeleteArgs} args - Arguments to delete one FileSource.
     * @example
     * // Delete one FileSource
     * const FileSource = await prisma.fileSource.delete({
     *   where: {
     *     // ... filter to delete one FileSource
     *   }
     * })
     * 
     */
    delete<T extends FileSourceDeleteArgs>(args: SelectSubset<T, FileSourceDeleteArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one FileSource.
     * @param {FileSourceUpdateArgs} args - Arguments to update one FileSource.
     * @example
     * // Update one FileSource
     * const fileSource = await prisma.fileSource.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileSourceUpdateArgs>(args: SelectSubset<T, FileSourceUpdateArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more FileSources.
     * @param {FileSourceDeleteManyArgs} args - Arguments to filter FileSources to delete.
     * @example
     * // Delete a few FileSources
     * const { count } = await prisma.fileSource.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileSourceDeleteManyArgs>(args?: SelectSubset<T, FileSourceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many FileSources
     * const fileSource = await prisma.fileSource.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileSourceUpdateManyArgs>(args: SelectSubset<T, FileSourceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more FileSources and returns the data updated in the database.
     * @param {FileSourceUpdateManyAndReturnArgs} args - Arguments to update many FileSources.
     * @example
     * // Update many FileSources
     * const fileSource = await prisma.fileSource.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more FileSources and only return the `id`
     * const fileSourceWithIdOnly = await prisma.fileSource.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileSourceUpdateManyAndReturnArgs>(args: SelectSubset<T, FileSourceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one FileSource.
     * @param {FileSourceUpsertArgs} args - Arguments to update or create a FileSource.
     * @example
     * // Update or create a FileSource
     * const fileSource = await prisma.fileSource.upsert({
     *   create: {
     *     // ... data to create a FileSource
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the FileSource we want to update
     *   }
     * })
     */
    upsert<T extends FileSourceUpsertArgs>(args: SelectSubset<T, FileSourceUpsertArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of FileSources.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceCountArgs} args - Arguments to filter FileSources to count.
     * @example
     * // Count the number of FileSources
     * const count = await prisma.fileSource.count({
     *   where: {
     *     // ... the filter for the FileSources we want to count
     *   }
     * })
    **/
    count<T extends FileSourceCountArgs>(
      args?: Subset<T, FileSourceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileSourceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a FileSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileSourceAggregateArgs>(args: Subset<T, FileSourceAggregateArgs>): Prisma.PrismaPromise<GetFileSourceAggregateType<T>>

    /**
     * Group by FileSource.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileSourceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileSourceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileSourceGroupByArgs['orderBy'] }
        : { orderBy?: FileSourceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileSourceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileSourceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the FileSource model
   */
  readonly fields: FileSourceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for FileSource.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileSourceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    userAvatars<T extends FileSource$userAvatarsArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$userAvatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    personaTemplates<T extends FileSource$personaTemplatesArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$personaTemplatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    botAvatars<T extends FileSource$botAvatarsArgs<ExtArgs> = {}>(args?: Subset<T, FileSource$botAvatarsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the FileSource model
   */
  interface FileSourceFieldRefs {
    readonly id: FieldRef<"FileSource", 'String'>
    readonly isUploaded: FieldRef<"FileSource", 'Boolean'>
    readonly bucket: FieldRef<"FileSource", 'String'>
    readonly key: FieldRef<"FileSource", 'String'>
    readonly hash: FieldRef<"FileSource", 'String'>
    readonly thumbImg: FieldRef<"FileSource", 'String'>
    readonly fsize: FieldRef<"FileSource", 'Float'>
    readonly mimeType: FieldRef<"FileSource", 'String'>
    readonly type: FieldRef<"FileSource", 'Int'>
    readonly endUser: FieldRef<"FileSource", 'String'>
    readonly status: FieldRef<"FileSource", 'Int'>
    readonly sha256: FieldRef<"FileSource", 'String'>
    readonly parts: FieldRef<"FileSource", 'Int[]'>
    readonly ext: FieldRef<"FileSource", 'String'>
    readonly expireAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToIaAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToArchiveAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToDeepArchiveAt: FieldRef<"FileSource", 'DateTime'>
    readonly transitionToArchiveIRAt: FieldRef<"FileSource", 'DateTime'>
    readonly env: FieldRef<"FileSource", 'FileEnvType'>
    readonly vendor: FieldRef<"FileSource", 'FileBucketVendor'>
    readonly region: FieldRef<"FileSource", 'String'>
    readonly isDeleted: FieldRef<"FileSource", 'Boolean'>
    readonly createdAt: FieldRef<"FileSource", 'DateTime'>
    readonly updatedAt: FieldRef<"FileSource", 'DateTime'>
    readonly deletedAt: FieldRef<"FileSource", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * FileSource findUnique
   */
  export type FileSourceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource findUniqueOrThrow
   */
  export type FileSourceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource findFirst
   */
  export type FileSourceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileSources.
     */
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource findFirstOrThrow
   */
  export type FileSourceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSource to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of FileSources.
     */
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource findMany
   */
  export type FileSourceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter, which FileSources to fetch.
     */
    where?: FileSourceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of FileSources to fetch.
     */
    orderBy?: FileSourceOrderByWithRelationInput | FileSourceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing FileSources.
     */
    cursor?: FileSourceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` FileSources from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` FileSources.
     */
    skip?: number
    distinct?: FileSourceScalarFieldEnum | FileSourceScalarFieldEnum[]
  }

  /**
   * FileSource create
   */
  export type FileSourceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The data needed to create a FileSource.
     */
    data: XOR<FileSourceCreateInput, FileSourceUncheckedCreateInput>
  }

  /**
   * FileSource createMany
   */
  export type FileSourceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many FileSources.
     */
    data: FileSourceCreateManyInput | FileSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileSource createManyAndReturn
   */
  export type FileSourceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * The data used to create many FileSources.
     */
    data: FileSourceCreateManyInput | FileSourceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * FileSource update
   */
  export type FileSourceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The data needed to update a FileSource.
     */
    data: XOR<FileSourceUpdateInput, FileSourceUncheckedUpdateInput>
    /**
     * Choose, which FileSource to update.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource updateMany
   */
  export type FileSourceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update FileSources.
     */
    data: XOR<FileSourceUpdateManyMutationInput, FileSourceUncheckedUpdateManyInput>
    /**
     * Filter which FileSources to update
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to update.
     */
    limit?: number
  }

  /**
   * FileSource updateManyAndReturn
   */
  export type FileSourceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * The data used to update FileSources.
     */
    data: XOR<FileSourceUpdateManyMutationInput, FileSourceUncheckedUpdateManyInput>
    /**
     * Filter which FileSources to update
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to update.
     */
    limit?: number
  }

  /**
   * FileSource upsert
   */
  export type FileSourceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * The filter to search for the FileSource to update in case it exists.
     */
    where: FileSourceWhereUniqueInput
    /**
     * In case the FileSource found by the `where` argument doesn't exist, create a new FileSource with this data.
     */
    create: XOR<FileSourceCreateInput, FileSourceUncheckedCreateInput>
    /**
     * In case the FileSource was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileSourceUpdateInput, FileSourceUncheckedUpdateInput>
  }

  /**
   * FileSource delete
   */
  export type FileSourceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    /**
     * Filter which FileSource to delete.
     */
    where: FileSourceWhereUniqueInput
  }

  /**
   * FileSource deleteMany
   */
  export type FileSourceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which FileSources to delete
     */
    where?: FileSourceWhereInput
    /**
     * Limit how many FileSources to delete.
     */
    limit?: number
  }

  /**
   * FileSource.userAvatars
   */
  export type FileSource$userAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
    orderBy?: UserInfoOrderByWithRelationInput | UserInfoOrderByWithRelationInput[]
    cursor?: UserInfoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserInfoScalarFieldEnum | UserInfoScalarFieldEnum[]
  }

  /**
   * FileSource.personaTemplates
   */
  export type FileSource$personaTemplatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
    orderBy?: PersonaTemplateOrderByWithRelationInput | PersonaTemplateOrderByWithRelationInput[]
    cursor?: PersonaTemplateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PersonaTemplateScalarFieldEnum | PersonaTemplateScalarFieldEnum[]
  }

  /**
   * FileSource.botAvatars
   */
  export type FileSource$botAvatarsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    where?: BotWhereInput
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    cursor?: BotWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * FileSource without action
   */
  export type FileSourceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
  }


  /**
   * Model CountryCode
   */

  export type AggregateCountryCode = {
    _count: CountryCodeCountAggregateOutputType | null
    _min: CountryCodeMinAggregateOutputType | null
    _max: CountryCodeMaxAggregateOutputType | null
  }

  export type CountryCodeMinAggregateOutputType = {
    id: string | null
    continent: string | null
    code: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryCodeMaxAggregateOutputType = {
    id: string | null
    continent: string | null
    code: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type CountryCodeCountAggregateOutputType = {
    id: number
    continent: number
    code: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type CountryCodeMinAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryCodeMaxAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type CountryCodeCountAggregateInputType = {
    id?: true
    continent?: true
    code?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type CountryCodeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCode to aggregate.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CountryCodes
    **/
    _count?: true | CountryCodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CountryCodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CountryCodeMaxAggregateInputType
  }

  export type GetCountryCodeAggregateType<T extends CountryCodeAggregateArgs> = {
        [P in keyof T & keyof AggregateCountryCode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCountryCode[P]>
      : GetScalarType<T[P], AggregateCountryCode[P]>
  }




  export type CountryCodeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CountryCodeWhereInput
    orderBy?: CountryCodeOrderByWithAggregationInput | CountryCodeOrderByWithAggregationInput[]
    by: CountryCodeScalarFieldEnum[] | CountryCodeScalarFieldEnum
    having?: CountryCodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CountryCodeCountAggregateInputType | true
    _min?: CountryCodeMinAggregateInputType
    _max?: CountryCodeMaxAggregateInputType
  }

  export type CountryCodeGroupByOutputType = {
    id: string
    continent: string
    code: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: CountryCodeCountAggregateOutputType | null
    _min: CountryCodeMinAggregateOutputType | null
    _max: CountryCodeMaxAggregateOutputType | null
  }

  type GetCountryCodeGroupByPayload<T extends CountryCodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CountryCodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CountryCodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CountryCodeGroupByOutputType[P]>
            : GetScalarType<T[P], CountryCodeGroupByOutputType[P]>
        }
      >
    >


  export type CountryCodeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["countryCode"]>

  export type CountryCodeSelectScalar = {
    id?: boolean
    continent?: boolean
    code?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type CountryCodeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "continent" | "code" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["countryCode"]>

  export type $CountryCodePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CountryCode"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      continent: string
      code: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["countryCode"]>
    composites: {}
  }

  type CountryCodeGetPayload<S extends boolean | null | undefined | CountryCodeDefaultArgs> = $Result.GetResult<Prisma.$CountryCodePayload, S>

  type CountryCodeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<CountryCodeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CountryCodeCountAggregateInputType | true
    }

  export interface CountryCodeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CountryCode'], meta: { name: 'CountryCode' } }
    /**
     * Find zero or one CountryCode that matches the filter.
     * @param {CountryCodeFindUniqueArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CountryCodeFindUniqueArgs>(args: SelectSubset<T, CountryCodeFindUniqueArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one CountryCode that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {CountryCodeFindUniqueOrThrowArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CountryCodeFindUniqueOrThrowArgs>(args: SelectSubset<T, CountryCodeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindFirstArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CountryCodeFindFirstArgs>(args?: SelectSubset<T, CountryCodeFindFirstArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first CountryCode that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindFirstOrThrowArgs} args - Arguments to find a CountryCode
     * @example
     * // Get one CountryCode
     * const countryCode = await prisma.countryCode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CountryCodeFindFirstOrThrowArgs>(args?: SelectSubset<T, CountryCodeFindFirstOrThrowArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more CountryCodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CountryCodes
     * const countryCodes = await prisma.countryCode.findMany()
     * 
     * // Get first 10 CountryCodes
     * const countryCodes = await prisma.countryCode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CountryCodeFindManyArgs>(args?: SelectSubset<T, CountryCodeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a CountryCode.
     * @param {CountryCodeCreateArgs} args - Arguments to create a CountryCode.
     * @example
     * // Create one CountryCode
     * const CountryCode = await prisma.countryCode.create({
     *   data: {
     *     // ... data to create a CountryCode
     *   }
     * })
     * 
     */
    create<T extends CountryCodeCreateArgs>(args: SelectSubset<T, CountryCodeCreateArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many CountryCodes.
     * @param {CountryCodeCreateManyArgs} args - Arguments to create many CountryCodes.
     * @example
     * // Create many CountryCodes
     * const countryCode = await prisma.countryCode.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CountryCodeCreateManyArgs>(args?: SelectSubset<T, CountryCodeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CountryCodes and returns the data saved in the database.
     * @param {CountryCodeCreateManyAndReturnArgs} args - Arguments to create many CountryCodes.
     * @example
     * // Create many CountryCodes
     * const countryCode = await prisma.countryCode.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CountryCodes and only return the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CountryCodeCreateManyAndReturnArgs>(args?: SelectSubset<T, CountryCodeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a CountryCode.
     * @param {CountryCodeDeleteArgs} args - Arguments to delete one CountryCode.
     * @example
     * // Delete one CountryCode
     * const CountryCode = await prisma.countryCode.delete({
     *   where: {
     *     // ... filter to delete one CountryCode
     *   }
     * })
     * 
     */
    delete<T extends CountryCodeDeleteArgs>(args: SelectSubset<T, CountryCodeDeleteArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one CountryCode.
     * @param {CountryCodeUpdateArgs} args - Arguments to update one CountryCode.
     * @example
     * // Update one CountryCode
     * const countryCode = await prisma.countryCode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CountryCodeUpdateArgs>(args: SelectSubset<T, CountryCodeUpdateArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more CountryCodes.
     * @param {CountryCodeDeleteManyArgs} args - Arguments to filter CountryCodes to delete.
     * @example
     * // Delete a few CountryCodes
     * const { count } = await prisma.countryCode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CountryCodeDeleteManyArgs>(args?: SelectSubset<T, CountryCodeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CountryCodes
     * const countryCode = await prisma.countryCode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CountryCodeUpdateManyArgs>(args: SelectSubset<T, CountryCodeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CountryCodes and returns the data updated in the database.
     * @param {CountryCodeUpdateManyAndReturnArgs} args - Arguments to update many CountryCodes.
     * @example
     * // Update many CountryCodes
     * const countryCode = await prisma.countryCode.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more CountryCodes and only return the `id`
     * const countryCodeWithIdOnly = await prisma.countryCode.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends CountryCodeUpdateManyAndReturnArgs>(args: SelectSubset<T, CountryCodeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one CountryCode.
     * @param {CountryCodeUpsertArgs} args - Arguments to update or create a CountryCode.
     * @example
     * // Update or create a CountryCode
     * const countryCode = await prisma.countryCode.upsert({
     *   create: {
     *     // ... data to create a CountryCode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CountryCode we want to update
     *   }
     * })
     */
    upsert<T extends CountryCodeUpsertArgs>(args: SelectSubset<T, CountryCodeUpsertArgs<ExtArgs>>): Prisma__CountryCodeClient<$Result.GetResult<Prisma.$CountryCodePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of CountryCodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeCountArgs} args - Arguments to filter CountryCodes to count.
     * @example
     * // Count the number of CountryCodes
     * const count = await prisma.countryCode.count({
     *   where: {
     *     // ... the filter for the CountryCodes we want to count
     *   }
     * })
    **/
    count<T extends CountryCodeCountArgs>(
      args?: Subset<T, CountryCodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CountryCodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CountryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CountryCodeAggregateArgs>(args: Subset<T, CountryCodeAggregateArgs>): Prisma.PrismaPromise<GetCountryCodeAggregateType<T>>

    /**
     * Group by CountryCode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CountryCodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CountryCodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CountryCodeGroupByArgs['orderBy'] }
        : { orderBy?: CountryCodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CountryCodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCountryCodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CountryCode model
   */
  readonly fields: CountryCodeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CountryCode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CountryCodeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CountryCode model
   */
  interface CountryCodeFieldRefs {
    readonly id: FieldRef<"CountryCode", 'String'>
    readonly continent: FieldRef<"CountryCode", 'String'>
    readonly code: FieldRef<"CountryCode", 'String'>
    readonly isDeleted: FieldRef<"CountryCode", 'Boolean'>
    readonly createdAt: FieldRef<"CountryCode", 'DateTime'>
    readonly updatedAt: FieldRef<"CountryCode", 'DateTime'>
    readonly deletedAt: FieldRef<"CountryCode", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CountryCode findUnique
   */
  export type CountryCodeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode findUniqueOrThrow
   */
  export type CountryCodeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode findFirst
   */
  export type CountryCodeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCodes.
     */
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode findFirstOrThrow
   */
  export type CountryCodeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCode to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CountryCodes.
     */
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode findMany
   */
  export type CountryCodeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter, which CountryCodes to fetch.
     */
    where?: CountryCodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CountryCodes to fetch.
     */
    orderBy?: CountryCodeOrderByWithRelationInput | CountryCodeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CountryCodes.
     */
    cursor?: CountryCodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` CountryCodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CountryCodes.
     */
    skip?: number
    distinct?: CountryCodeScalarFieldEnum | CountryCodeScalarFieldEnum[]
  }

  /**
   * CountryCode create
   */
  export type CountryCodeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data needed to create a CountryCode.
     */
    data: XOR<CountryCodeCreateInput, CountryCodeUncheckedCreateInput>
  }

  /**
   * CountryCode createMany
   */
  export type CountryCodeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CountryCodes.
     */
    data: CountryCodeCreateManyInput | CountryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCode createManyAndReturn
   */
  export type CountryCodeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data used to create many CountryCodes.
     */
    data: CountryCodeCreateManyInput | CountryCodeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CountryCode update
   */
  export type CountryCodeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data needed to update a CountryCode.
     */
    data: XOR<CountryCodeUpdateInput, CountryCodeUncheckedUpdateInput>
    /**
     * Choose, which CountryCode to update.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode updateMany
   */
  export type CountryCodeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CountryCodes.
     */
    data: XOR<CountryCodeUpdateManyMutationInput, CountryCodeUncheckedUpdateManyInput>
    /**
     * Filter which CountryCodes to update
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to update.
     */
    limit?: number
  }

  /**
   * CountryCode updateManyAndReturn
   */
  export type CountryCodeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The data used to update CountryCodes.
     */
    data: XOR<CountryCodeUpdateManyMutationInput, CountryCodeUncheckedUpdateManyInput>
    /**
     * Filter which CountryCodes to update
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to update.
     */
    limit?: number
  }

  /**
   * CountryCode upsert
   */
  export type CountryCodeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * The filter to search for the CountryCode to update in case it exists.
     */
    where: CountryCodeWhereUniqueInput
    /**
     * In case the CountryCode found by the `where` argument doesn't exist, create a new CountryCode with this data.
     */
    create: XOR<CountryCodeCreateInput, CountryCodeUncheckedCreateInput>
    /**
     * In case the CountryCode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CountryCodeUpdateInput, CountryCodeUncheckedUpdateInput>
  }

  /**
   * CountryCode delete
   */
  export type CountryCodeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
    /**
     * Filter which CountryCode to delete.
     */
    where: CountryCodeWhereUniqueInput
  }

  /**
   * CountryCode deleteMany
   */
  export type CountryCodeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CountryCodes to delete
     */
    where?: CountryCodeWhereInput
    /**
     * Limit how many CountryCodes to delete.
     */
    limit?: number
  }

  /**
   * CountryCode without action
   */
  export type CountryCodeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CountryCode
     */
    select?: CountryCodeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the CountryCode
     */
    omit?: CountryCodeOmit<ExtArgs> | null
  }


  /**
   * Model Bot
   */

  export type AggregateBot = {
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  export type BotAvgAggregateOutputType = {
    port: number | null
  }

  export type BotSumAggregateOutputType = {
    port: number | null
  }

  export type BotMinAggregateOutputType = {
    id: string | null
    name: string | null
    hostname: string | null
    aiProvider: string | null
    model: string | null
    channelType: string | null
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    status: $Enums.BotStatus | null
    createdById: string | null
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotMaxAggregateOutputType = {
    id: string | null
    name: string | null
    hostname: string | null
    aiProvider: string | null
    model: string | null
    channelType: string | null
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    status: $Enums.BotStatus | null
    createdById: string | null
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type BotCountAggregateOutputType = {
    id: number
    name: number
    hostname: number
    aiProvider: number
    model: number
    channelType: number
    containerId: number
    port: number
    gatewayToken: number
    proxyTokenHash: number
    tags: number
    status: number
    createdById: number
    personaTemplateId: number
    emoji: number
    avatarFileId: number
    soulMarkdown: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type BotAvgAggregateInputType = {
    port?: true
  }

  export type BotSumAggregateInputType = {
    port?: true
  }

  export type BotMinAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    aiProvider?: true
    model?: true
    channelType?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotMaxAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    aiProvider?: true
    model?: true
    channelType?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type BotCountAggregateInputType = {
    id?: true
    name?: true
    hostname?: true
    aiProvider?: true
    model?: true
    channelType?: true
    containerId?: true
    port?: true
    gatewayToken?: true
    proxyTokenHash?: true
    tags?: true
    status?: true
    createdById?: true
    personaTemplateId?: true
    emoji?: true
    avatarFileId?: true
    soulMarkdown?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type BotAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bot to aggregate.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Bots
    **/
    _count?: true | BotCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotMaxAggregateInputType
  }

  export type GetBotAggregateType<T extends BotAggregateArgs> = {
        [P in keyof T & keyof AggregateBot]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBot[P]>
      : GetScalarType<T[P], AggregateBot[P]>
  }




  export type BotGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotWhereInput
    orderBy?: BotOrderByWithAggregationInput | BotOrderByWithAggregationInput[]
    by: BotScalarFieldEnum[] | BotScalarFieldEnum
    having?: BotScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotCountAggregateInputType | true
    _avg?: BotAvgAggregateInputType
    _sum?: BotSumAggregateInputType
    _min?: BotMinAggregateInputType
    _max?: BotMaxAggregateInputType
  }

  export type BotGroupByOutputType = {
    id: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId: string | null
    port: number | null
    gatewayToken: string | null
    proxyTokenHash: string | null
    tags: string[]
    status: $Enums.BotStatus
    createdById: string
    personaTemplateId: string | null
    emoji: string | null
    avatarFileId: string | null
    soulMarkdown: string | null
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: BotCountAggregateOutputType | null
    _avg: BotAvgAggregateOutputType | null
    _sum: BotSumAggregateOutputType | null
    _min: BotMinAggregateOutputType | null
    _max: BotMaxAggregateOutputType | null
  }

  type GetBotGroupByPayload<T extends BotGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotGroupByOutputType[P]>
            : GetScalarType<T[P], BotGroupByOutputType[P]>
        }
      >
    >


  export type BotSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    aiProvider?: boolean
    model?: boolean
    channelType?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
    providerKeys?: boolean | Bot$providerKeysArgs<ExtArgs>
    usageLogs?: boolean | Bot$usageLogsArgs<ExtArgs>
    proxyToken?: boolean | Bot$proxyTokenArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    aiProvider?: boolean
    model?: boolean
    channelType?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    hostname?: boolean
    aiProvider?: boolean
    model?: boolean
    channelType?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }, ExtArgs["result"]["bot"]>

  export type BotSelectScalar = {
    id?: boolean
    name?: boolean
    hostname?: boolean
    aiProvider?: boolean
    model?: boolean
    channelType?: boolean
    containerId?: boolean
    port?: boolean
    gatewayToken?: boolean
    proxyTokenHash?: boolean
    tags?: boolean
    status?: boolean
    createdById?: boolean
    personaTemplateId?: boolean
    emoji?: boolean
    avatarFileId?: boolean
    soulMarkdown?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type BotOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "hostname" | "aiProvider" | "model" | "channelType" | "containerId" | "port" | "gatewayToken" | "proxyTokenHash" | "tags" | "status" | "createdById" | "personaTemplateId" | "emoji" | "avatarFileId" | "soulMarkdown" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["bot"]>
  export type BotInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
    providerKeys?: boolean | Bot$providerKeysArgs<ExtArgs>
    usageLogs?: boolean | Bot$usageLogsArgs<ExtArgs>
    proxyToken?: boolean | Bot$proxyTokenArgs<ExtArgs>
    _count?: boolean | BotCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BotIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }
  export type BotIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    personaTemplate?: boolean | Bot$personaTemplateArgs<ExtArgs>
    avatarFile?: boolean | Bot$avatarFileArgs<ExtArgs>
  }

  export type $BotPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Bot"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs>
      personaTemplate: Prisma.$PersonaTemplatePayload<ExtArgs> | null
      avatarFile: Prisma.$FileSourcePayload<ExtArgs> | null
      providerKeys: Prisma.$BotProviderKeyPayload<ExtArgs>[]
      usageLogs: Prisma.$BotUsageLogPayload<ExtArgs>[]
      proxyToken: Prisma.$ProxyTokenPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      hostname: string
      aiProvider: string
      model: string
      channelType: string
      containerId: string | null
      port: number | null
      gatewayToken: string | null
      proxyTokenHash: string | null
      tags: string[]
      status: $Enums.BotStatus
      createdById: string
      personaTemplateId: string | null
      emoji: string | null
      avatarFileId: string | null
      soulMarkdown: string | null
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["bot"]>
    composites: {}
  }

  type BotGetPayload<S extends boolean | null | undefined | BotDefaultArgs> = $Result.GetResult<Prisma.$BotPayload, S>

  type BotCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotCountAggregateInputType | true
    }

  export interface BotDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Bot'], meta: { name: 'Bot' } }
    /**
     * Find zero or one Bot that matches the filter.
     * @param {BotFindUniqueArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotFindUniqueArgs>(args: SelectSubset<T, BotFindUniqueArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bot that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotFindUniqueOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotFindUniqueOrThrowArgs>(args: SelectSubset<T, BotFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotFindFirstArgs>(args?: SelectSubset<T, BotFindFirstArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bot that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindFirstOrThrowArgs} args - Arguments to find a Bot
     * @example
     * // Get one Bot
     * const bot = await prisma.bot.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotFindFirstOrThrowArgs>(args?: SelectSubset<T, BotFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bots that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bots
     * const bots = await prisma.bot.findMany()
     * 
     * // Get first 10 Bots
     * const bots = await prisma.bot.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botWithIdOnly = await prisma.bot.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotFindManyArgs>(args?: SelectSubset<T, BotFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bot.
     * @param {BotCreateArgs} args - Arguments to create a Bot.
     * @example
     * // Create one Bot
     * const Bot = await prisma.bot.create({
     *   data: {
     *     // ... data to create a Bot
     *   }
     * })
     * 
     */
    create<T extends BotCreateArgs>(args: SelectSubset<T, BotCreateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bots.
     * @param {BotCreateManyArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotCreateManyArgs>(args?: SelectSubset<T, BotCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Bots and returns the data saved in the database.
     * @param {BotCreateManyAndReturnArgs} args - Arguments to create many Bots.
     * @example
     * // Create many Bots
     * const bot = await prisma.bot.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotCreateManyAndReturnArgs>(args?: SelectSubset<T, BotCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Bot.
     * @param {BotDeleteArgs} args - Arguments to delete one Bot.
     * @example
     * // Delete one Bot
     * const Bot = await prisma.bot.delete({
     *   where: {
     *     // ... filter to delete one Bot
     *   }
     * })
     * 
     */
    delete<T extends BotDeleteArgs>(args: SelectSubset<T, BotDeleteArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bot.
     * @param {BotUpdateArgs} args - Arguments to update one Bot.
     * @example
     * // Update one Bot
     * const bot = await prisma.bot.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotUpdateArgs>(args: SelectSubset<T, BotUpdateArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bots.
     * @param {BotDeleteManyArgs} args - Arguments to filter Bots to delete.
     * @example
     * // Delete a few Bots
     * const { count } = await prisma.bot.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotDeleteManyArgs>(args?: SelectSubset<T, BotDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotUpdateManyArgs>(args: SelectSubset<T, BotUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bots and returns the data updated in the database.
     * @param {BotUpdateManyAndReturnArgs} args - Arguments to update many Bots.
     * @example
     * // Update many Bots
     * const bot = await prisma.bot.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Bots and only return the `id`
     * const botWithIdOnly = await prisma.bot.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotUpdateManyAndReturnArgs>(args: SelectSubset<T, BotUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Bot.
     * @param {BotUpsertArgs} args - Arguments to update or create a Bot.
     * @example
     * // Update or create a Bot
     * const bot = await prisma.bot.upsert({
     *   create: {
     *     // ... data to create a Bot
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bot we want to update
     *   }
     * })
     */
    upsert<T extends BotUpsertArgs>(args: SelectSubset<T, BotUpsertArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Bots.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotCountArgs} args - Arguments to filter Bots to count.
     * @example
     * // Count the number of Bots
     * const count = await prisma.bot.count({
     *   where: {
     *     // ... the filter for the Bots we want to count
     *   }
     * })
    **/
    count<T extends BotCountArgs>(
      args?: Subset<T, BotCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotAggregateArgs>(args: Subset<T, BotAggregateArgs>): Prisma.PrismaPromise<GetBotAggregateType<T>>

    /**
     * Group by Bot.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotGroupByArgs['orderBy'] }
        : { orderBy?: BotGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Bot model
   */
  readonly fields: BotFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Bot.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    personaTemplate<T extends Bot$personaTemplateArgs<ExtArgs> = {}>(args?: Subset<T, Bot$personaTemplateArgs<ExtArgs>>): Prisma__PersonaTemplateClient<$Result.GetResult<Prisma.$PersonaTemplatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    avatarFile<T extends Bot$avatarFileArgs<ExtArgs> = {}>(args?: Subset<T, Bot$avatarFileArgs<ExtArgs>>): Prisma__FileSourceClient<$Result.GetResult<Prisma.$FileSourcePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    providerKeys<T extends Bot$providerKeysArgs<ExtArgs> = {}>(args?: Subset<T, Bot$providerKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends Bot$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, Bot$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyToken<T extends Bot$proxyTokenArgs<ExtArgs> = {}>(args?: Subset<T, Bot$proxyTokenArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Bot model
   */
  interface BotFieldRefs {
    readonly id: FieldRef<"Bot", 'String'>
    readonly name: FieldRef<"Bot", 'String'>
    readonly hostname: FieldRef<"Bot", 'String'>
    readonly aiProvider: FieldRef<"Bot", 'String'>
    readonly model: FieldRef<"Bot", 'String'>
    readonly channelType: FieldRef<"Bot", 'String'>
    readonly containerId: FieldRef<"Bot", 'String'>
    readonly port: FieldRef<"Bot", 'Int'>
    readonly gatewayToken: FieldRef<"Bot", 'String'>
    readonly proxyTokenHash: FieldRef<"Bot", 'String'>
    readonly tags: FieldRef<"Bot", 'String[]'>
    readonly status: FieldRef<"Bot", 'BotStatus'>
    readonly createdById: FieldRef<"Bot", 'String'>
    readonly personaTemplateId: FieldRef<"Bot", 'String'>
    readonly emoji: FieldRef<"Bot", 'String'>
    readonly avatarFileId: FieldRef<"Bot", 'String'>
    readonly soulMarkdown: FieldRef<"Bot", 'String'>
    readonly isDeleted: FieldRef<"Bot", 'Boolean'>
    readonly createdAt: FieldRef<"Bot", 'DateTime'>
    readonly updatedAt: FieldRef<"Bot", 'DateTime'>
    readonly deletedAt: FieldRef<"Bot", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Bot findUnique
   */
  export type BotFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findUniqueOrThrow
   */
  export type BotFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot findFirst
   */
  export type BotFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findFirstOrThrow
   */
  export type BotFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bot to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Bots.
     */
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot findMany
   */
  export type BotFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter, which Bots to fetch.
     */
    where?: BotWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Bots to fetch.
     */
    orderBy?: BotOrderByWithRelationInput | BotOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Bots.
     */
    cursor?: BotWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Bots from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Bots.
     */
    skip?: number
    distinct?: BotScalarFieldEnum | BotScalarFieldEnum[]
  }

  /**
   * Bot create
   */
  export type BotCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to create a Bot.
     */
    data: XOR<BotCreateInput, BotUncheckedCreateInput>
  }

  /**
   * Bot createMany
   */
  export type BotCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Bot createManyAndReturn
   */
  export type BotCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to create many Bots.
     */
    data: BotCreateManyInput | BotCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot update
   */
  export type BotUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The data needed to update a Bot.
     */
    data: XOR<BotUpdateInput, BotUncheckedUpdateInput>
    /**
     * Choose, which Bot to update.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot updateMany
   */
  export type BotUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
  }

  /**
   * Bot updateManyAndReturn
   */
  export type BotUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * The data used to update Bots.
     */
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyInput>
    /**
     * Filter which Bots to update
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Bot upsert
   */
  export type BotUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * The filter to search for the Bot to update in case it exists.
     */
    where: BotWhereUniqueInput
    /**
     * In case the Bot found by the `where` argument doesn't exist, create a new Bot with this data.
     */
    create: XOR<BotCreateInput, BotUncheckedCreateInput>
    /**
     * In case the Bot was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUpdateInput, BotUncheckedUpdateInput>
  }

  /**
   * Bot delete
   */
  export type BotDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
    /**
     * Filter which Bot to delete.
     */
    where: BotWhereUniqueInput
  }

  /**
   * Bot deleteMany
   */
  export type BotDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Bots to delete
     */
    where?: BotWhereInput
    /**
     * Limit how many Bots to delete.
     */
    limit?: number
  }

  /**
   * Bot.personaTemplate
   */
  export type Bot$personaTemplateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PersonaTemplate
     */
    select?: PersonaTemplateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PersonaTemplate
     */
    omit?: PersonaTemplateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PersonaTemplateInclude<ExtArgs> | null
    where?: PersonaTemplateWhereInput
  }

  /**
   * Bot.avatarFile
   */
  export type Bot$avatarFileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileSource
     */
    select?: FileSourceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the FileSource
     */
    omit?: FileSourceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileSourceInclude<ExtArgs> | null
    where?: FileSourceWhereInput
  }

  /**
   * Bot.providerKeys
   */
  export type Bot$providerKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    cursor?: BotProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * Bot.usageLogs
   */
  export type Bot$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    cursor?: BotUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * Bot.proxyToken
   */
  export type Bot$proxyTokenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    where?: ProxyTokenWhereInput
  }

  /**
   * Bot without action
   */
  export type BotDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Bot
     */
    select?: BotSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Bot
     */
    omit?: BotOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotInclude<ExtArgs> | null
  }


  /**
   * Model ProviderKey
   */

  export type AggregateProviderKey = {
    _count: ProviderKeyCountAggregateOutputType | null
    _min: ProviderKeyMinAggregateOutputType | null
    _max: ProviderKeyMaxAggregateOutputType | null
  }

  export type ProviderKeyMinAggregateOutputType = {
    id: string | null
    vendor: string | null
    apiType: string | null
    secretEncrypted: Bytes | null
    label: string | null
    tag: string | null
    baseUrl: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProviderKeyMaxAggregateOutputType = {
    id: string | null
    vendor: string | null
    apiType: string | null
    secretEncrypted: Bytes | null
    label: string | null
    tag: string | null
    baseUrl: string | null
    createdById: string | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ProviderKeyCountAggregateOutputType = {
    id: number
    vendor: number
    apiType: number
    secretEncrypted: number
    label: number
    tag: number
    baseUrl: number
    createdById: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ProviderKeyMinAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProviderKeyMaxAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ProviderKeyCountAggregateInputType = {
    id?: true
    vendor?: true
    apiType?: true
    secretEncrypted?: true
    label?: true
    tag?: true
    baseUrl?: true
    createdById?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ProviderKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderKey to aggregate.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProviderKeys
    **/
    _count?: true | ProviderKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProviderKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProviderKeyMaxAggregateInputType
  }

  export type GetProviderKeyAggregateType<T extends ProviderKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateProviderKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviderKey[P]>
      : GetScalarType<T[P], AggregateProviderKey[P]>
  }




  export type ProviderKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProviderKeyWhereInput
    orderBy?: ProviderKeyOrderByWithAggregationInput | ProviderKeyOrderByWithAggregationInput[]
    by: ProviderKeyScalarFieldEnum[] | ProviderKeyScalarFieldEnum
    having?: ProviderKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProviderKeyCountAggregateInputType | true
    _min?: ProviderKeyMinAggregateInputType
    _max?: ProviderKeyMaxAggregateInputType
  }

  export type ProviderKeyGroupByOutputType = {
    id: string
    vendor: string
    apiType: string | null
    secretEncrypted: Bytes
    label: string
    tag: string | null
    baseUrl: string | null
    createdById: string
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ProviderKeyCountAggregateOutputType | null
    _min: ProviderKeyMinAggregateOutputType | null
    _max: ProviderKeyMaxAggregateOutputType | null
  }

  type GetProviderKeyGroupByPayload<T extends ProviderKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProviderKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProviderKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProviderKeyGroupByOutputType[P]>
            : GetScalarType<T[P], ProviderKeyGroupByOutputType[P]>
        }
      >
    >


  export type ProviderKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    botProviderKeys?: boolean | ProviderKey$botProviderKeysArgs<ExtArgs>
    usageLogs?: boolean | ProviderKey$usageLogsArgs<ExtArgs>
    proxyTokens?: boolean | ProviderKey$proxyTokensArgs<ExtArgs>
    _count?: boolean | ProviderKeyCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providerKey"]>

  export type ProviderKeySelectScalar = {
    id?: boolean
    vendor?: boolean
    apiType?: boolean
    secretEncrypted?: boolean
    label?: boolean
    tag?: boolean
    baseUrl?: boolean
    createdById?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ProviderKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor" | "apiType" | "secretEncrypted" | "label" | "tag" | "baseUrl" | "createdById" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["providerKey"]>
  export type ProviderKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
    botProviderKeys?: boolean | ProviderKey$botProviderKeysArgs<ExtArgs>
    usageLogs?: boolean | ProviderKey$usageLogsArgs<ExtArgs>
    proxyTokens?: boolean | ProviderKey$proxyTokensArgs<ExtArgs>
    _count?: boolean | ProviderKeyCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProviderKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type ProviderKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    createdBy?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $ProviderKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProviderKey"
    objects: {
      createdBy: Prisma.$UserInfoPayload<ExtArgs>
      botProviderKeys: Prisma.$BotProviderKeyPayload<ExtArgs>[]
      usageLogs: Prisma.$BotUsageLogPayload<ExtArgs>[]
      proxyTokens: Prisma.$ProxyTokenPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      /**
       * ‰∏ªÈîÆ UUID
       */
      id: string
      /**
       * ÊúçÂä°ÂïÜÊ†áËØÜÔºöopenai, anthropic, google, venice, deepseek, groq, custom Á≠â
       */
      vendor: string
      /**
       * API ÂçèËÆÆÁ±ªÂûãÔºöopenai, anthropic, gemini, azure-openai, aws-bedrock, vertexai, ollama, new-api, gateway Á≠â
       * Áî®‰∫éÁ°ÆÂÆö API Ë∞ÉÁî®ÊñπÂºèÔºåcustom ÊúçÂä°ÂïÜÂøÖÂ°´
       */
      apiType: string | null
      /**
       * Âä†ÂØÜÂ≠òÂÇ®ÁöÑ API ÂØÜÈí•ÔºàAES-256-GCM Âä†ÂØÜÔºâ
       */
      secretEncrypted: Prisma.Bytes
      /**
       * ÂØÜÈí•ÂêçÁß∞ÔºàÂøÖÂ°´ÔºâÔºåÁî®‰∫éÁî®Êà∑ËØÜÂà´‰∏çÂêåÂØÜÈí•ÔºåÂêå‰∏ÄÁî®Êà∑‰∏ãÂîØ‰∏Ä
       */
      label: string
      /**
       * Ë∑ØÁî±Ê†áÁ≠æÔºåÁî®‰∫éÂú®Â§öÂØÜÈí•Âú∫ÊôØ‰∏ãËøõË°åÊµÅÈáèÂàÜÈÖç
       */
      tag: string | null
      /**
       * Ëá™ÂÆö‰πâ API Âú∞ÂùÄÔºåÁî®‰∫éÁßÅÊúâÈÉ®ÁΩ≤Êàñ‰ª£ÁêÜÊúçÂä°
       */
      baseUrl: string | null
      /**
       * ÂàõÂª∫ËÄÖÁî®Êà∑ ID
       */
      createdById: string
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["providerKey"]>
    composites: {}
  }

  type ProviderKeyGetPayload<S extends boolean | null | undefined | ProviderKeyDefaultArgs> = $Result.GetResult<Prisma.$ProviderKeyPayload, S>

  type ProviderKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProviderKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProviderKeyCountAggregateInputType | true
    }

  export interface ProviderKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProviderKey'], meta: { name: 'ProviderKey' } }
    /**
     * Find zero or one ProviderKey that matches the filter.
     * @param {ProviderKeyFindUniqueArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProviderKeyFindUniqueArgs>(args: SelectSubset<T, ProviderKeyFindUniqueArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProviderKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProviderKeyFindUniqueOrThrowArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProviderKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, ProviderKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindFirstArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProviderKeyFindFirstArgs>(args?: SelectSubset<T, ProviderKeyFindFirstArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProviderKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindFirstOrThrowArgs} args - Arguments to find a ProviderKey
     * @example
     * // Get one ProviderKey
     * const providerKey = await prisma.providerKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProviderKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, ProviderKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProviderKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProviderKeys
     * const providerKeys = await prisma.providerKey.findMany()
     * 
     * // Get first 10 ProviderKeys
     * const providerKeys = await prisma.providerKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProviderKeyFindManyArgs>(args?: SelectSubset<T, ProviderKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProviderKey.
     * @param {ProviderKeyCreateArgs} args - Arguments to create a ProviderKey.
     * @example
     * // Create one ProviderKey
     * const ProviderKey = await prisma.providerKey.create({
     *   data: {
     *     // ... data to create a ProviderKey
     *   }
     * })
     * 
     */
    create<T extends ProviderKeyCreateArgs>(args: SelectSubset<T, ProviderKeyCreateArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProviderKeys.
     * @param {ProviderKeyCreateManyArgs} args - Arguments to create many ProviderKeys.
     * @example
     * // Create many ProviderKeys
     * const providerKey = await prisma.providerKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProviderKeyCreateManyArgs>(args?: SelectSubset<T, ProviderKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProviderKeys and returns the data saved in the database.
     * @param {ProviderKeyCreateManyAndReturnArgs} args - Arguments to create many ProviderKeys.
     * @example
     * // Create many ProviderKeys
     * const providerKey = await prisma.providerKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProviderKeys and only return the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProviderKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, ProviderKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProviderKey.
     * @param {ProviderKeyDeleteArgs} args - Arguments to delete one ProviderKey.
     * @example
     * // Delete one ProviderKey
     * const ProviderKey = await prisma.providerKey.delete({
     *   where: {
     *     // ... filter to delete one ProviderKey
     *   }
     * })
     * 
     */
    delete<T extends ProviderKeyDeleteArgs>(args: SelectSubset<T, ProviderKeyDeleteArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProviderKey.
     * @param {ProviderKeyUpdateArgs} args - Arguments to update one ProviderKey.
     * @example
     * // Update one ProviderKey
     * const providerKey = await prisma.providerKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProviderKeyUpdateArgs>(args: SelectSubset<T, ProviderKeyUpdateArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProviderKeys.
     * @param {ProviderKeyDeleteManyArgs} args - Arguments to filter ProviderKeys to delete.
     * @example
     * // Delete a few ProviderKeys
     * const { count } = await prisma.providerKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProviderKeyDeleteManyArgs>(args?: SelectSubset<T, ProviderKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProviderKeys
     * const providerKey = await prisma.providerKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProviderKeyUpdateManyArgs>(args: SelectSubset<T, ProviderKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProviderKeys and returns the data updated in the database.
     * @param {ProviderKeyUpdateManyAndReturnArgs} args - Arguments to update many ProviderKeys.
     * @example
     * // Update many ProviderKeys
     * const providerKey = await prisma.providerKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProviderKeys and only return the `id`
     * const providerKeyWithIdOnly = await prisma.providerKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProviderKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, ProviderKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProviderKey.
     * @param {ProviderKeyUpsertArgs} args - Arguments to update or create a ProviderKey.
     * @example
     * // Update or create a ProviderKey
     * const providerKey = await prisma.providerKey.upsert({
     *   create: {
     *     // ... data to create a ProviderKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProviderKey we want to update
     *   }
     * })
     */
    upsert<T extends ProviderKeyUpsertArgs>(args: SelectSubset<T, ProviderKeyUpsertArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyCountArgs} args - Arguments to filter ProviderKeys to count.
     * @example
     * // Count the number of ProviderKeys
     * const count = await prisma.providerKey.count({
     *   where: {
     *     // ... the filter for the ProviderKeys we want to count
     *   }
     * })
    **/
    count<T extends ProviderKeyCountArgs>(
      args?: Subset<T, ProviderKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProviderKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProviderKeyAggregateArgs>(args: Subset<T, ProviderKeyAggregateArgs>): Prisma.PrismaPromise<GetProviderKeyAggregateType<T>>

    /**
     * Group by ProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProviderKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProviderKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProviderKeyGroupByArgs['orderBy'] }
        : { orderBy?: ProviderKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProviderKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProviderKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProviderKey model
   */
  readonly fields: ProviderKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProviderKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProviderKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    createdBy<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    botProviderKeys<T extends ProviderKey$botProviderKeysArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$botProviderKeysArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    usageLogs<T extends ProviderKey$usageLogsArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$usageLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    proxyTokens<T extends ProviderKey$proxyTokensArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKey$proxyTokensArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProviderKey model
   */
  interface ProviderKeyFieldRefs {
    readonly id: FieldRef<"ProviderKey", 'String'>
    readonly vendor: FieldRef<"ProviderKey", 'String'>
    readonly apiType: FieldRef<"ProviderKey", 'String'>
    readonly secretEncrypted: FieldRef<"ProviderKey", 'Bytes'>
    readonly label: FieldRef<"ProviderKey", 'String'>
    readonly tag: FieldRef<"ProviderKey", 'String'>
    readonly baseUrl: FieldRef<"ProviderKey", 'String'>
    readonly createdById: FieldRef<"ProviderKey", 'String'>
    readonly isDeleted: FieldRef<"ProviderKey", 'Boolean'>
    readonly createdAt: FieldRef<"ProviderKey", 'DateTime'>
    readonly updatedAt: FieldRef<"ProviderKey", 'DateTime'>
    readonly deletedAt: FieldRef<"ProviderKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProviderKey findUnique
   */
  export type ProviderKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey findUniqueOrThrow
   */
  export type ProviderKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey findFirst
   */
  export type ProviderKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderKeys.
     */
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey findFirstOrThrow
   */
  export type ProviderKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKey to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProviderKeys.
     */
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey findMany
   */
  export type ProviderKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which ProviderKeys to fetch.
     */
    where?: ProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProviderKeys to fetch.
     */
    orderBy?: ProviderKeyOrderByWithRelationInput | ProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProviderKeys.
     */
    cursor?: ProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProviderKeys.
     */
    skip?: number
    distinct?: ProviderKeyScalarFieldEnum | ProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey create
   */
  export type ProviderKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a ProviderKey.
     */
    data: XOR<ProviderKeyCreateInput, ProviderKeyUncheckedCreateInput>
  }

  /**
   * ProviderKey createMany
   */
  export type ProviderKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProviderKeys.
     */
    data: ProviderKeyCreateManyInput | ProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProviderKey createManyAndReturn
   */
  export type ProviderKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to create many ProviderKeys.
     */
    data: ProviderKeyCreateManyInput | ProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderKey update
   */
  export type ProviderKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a ProviderKey.
     */
    data: XOR<ProviderKeyUpdateInput, ProviderKeyUncheckedUpdateInput>
    /**
     * Choose, which ProviderKey to update.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey updateMany
   */
  export type ProviderKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProviderKeys.
     */
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderKeys to update
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to update.
     */
    limit?: number
  }

  /**
   * ProviderKey updateManyAndReturn
   */
  export type ProviderKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to update ProviderKeys.
     */
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which ProviderKeys to update
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProviderKey upsert
   */
  export type ProviderKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the ProviderKey to update in case it exists.
     */
    where: ProviderKeyWhereUniqueInput
    /**
     * In case the ProviderKey found by the `where` argument doesn't exist, create a new ProviderKey with this data.
     */
    create: XOR<ProviderKeyCreateInput, ProviderKeyUncheckedCreateInput>
    /**
     * In case the ProviderKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProviderKeyUpdateInput, ProviderKeyUncheckedUpdateInput>
  }

  /**
   * ProviderKey delete
   */
  export type ProviderKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    /**
     * Filter which ProviderKey to delete.
     */
    where: ProviderKeyWhereUniqueInput
  }

  /**
   * ProviderKey deleteMany
   */
  export type ProviderKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProviderKeys to delete
     */
    where?: ProviderKeyWhereInput
    /**
     * Limit how many ProviderKeys to delete.
     */
    limit?: number
  }

  /**
   * ProviderKey.botProviderKeys
   */
  export type ProviderKey$botProviderKeysArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    cursor?: BotProviderKeyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * ProviderKey.usageLogs
   */
  export type ProviderKey$usageLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    cursor?: BotUsageLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * ProviderKey.proxyTokens
   */
  export type ProviderKey$proxyTokensArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    where?: ProxyTokenWhereInput
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    cursor?: ProxyTokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProviderKey without action
   */
  export type ProviderKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
  }


  /**
   * Model BotProviderKey
   */

  export type AggregateBotProviderKey = {
    _count: BotProviderKeyCountAggregateOutputType | null
    _min: BotProviderKeyMinAggregateOutputType | null
    _max: BotProviderKeyMaxAggregateOutputType | null
  }

  export type BotProviderKeyMinAggregateOutputType = {
    id: string | null
    botId: string | null
    providerKeyId: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type BotProviderKeyMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    providerKeyId: string | null
    isPrimary: boolean | null
    createdAt: Date | null
  }

  export type BotProviderKeyCountAggregateOutputType = {
    id: number
    botId: number
    providerKeyId: number
    isPrimary: number
    createdAt: number
    _all: number
  }


  export type BotProviderKeyMinAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    createdAt?: true
  }

  export type BotProviderKeyMaxAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    createdAt?: true
  }

  export type BotProviderKeyCountAggregateInputType = {
    id?: true
    botId?: true
    providerKeyId?: true
    isPrimary?: true
    createdAt?: true
    _all?: true
  }

  export type BotProviderKeyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotProviderKey to aggregate.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotProviderKeys
    **/
    _count?: true | BotProviderKeyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotProviderKeyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotProviderKeyMaxAggregateInputType
  }

  export type GetBotProviderKeyAggregateType<T extends BotProviderKeyAggregateArgs> = {
        [P in keyof T & keyof AggregateBotProviderKey]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotProviderKey[P]>
      : GetScalarType<T[P], AggregateBotProviderKey[P]>
  }




  export type BotProviderKeyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotProviderKeyWhereInput
    orderBy?: BotProviderKeyOrderByWithAggregationInput | BotProviderKeyOrderByWithAggregationInput[]
    by: BotProviderKeyScalarFieldEnum[] | BotProviderKeyScalarFieldEnum
    having?: BotProviderKeyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotProviderKeyCountAggregateInputType | true
    _min?: BotProviderKeyMinAggregateInputType
    _max?: BotProviderKeyMaxAggregateInputType
  }

  export type BotProviderKeyGroupByOutputType = {
    id: string
    botId: string
    providerKeyId: string
    isPrimary: boolean
    createdAt: Date
    _count: BotProviderKeyCountAggregateOutputType | null
    _min: BotProviderKeyMinAggregateOutputType | null
    _max: BotProviderKeyMaxAggregateOutputType | null
  }

  type GetBotProviderKeyGroupByPayload<T extends BotProviderKeyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotProviderKeyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotProviderKeyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotProviderKeyGroupByOutputType[P]>
            : GetScalarType<T[P], BotProviderKeyGroupByOutputType[P]>
        }
      >
    >


  export type BotProviderKeySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["botProviderKey"]>

  export type BotProviderKeySelectScalar = {
    id?: boolean
    botId?: boolean
    providerKeyId?: boolean
    isPrimary?: boolean
    createdAt?: boolean
  }

  export type BotProviderKeyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "providerKeyId" | "isPrimary" | "createdAt", ExtArgs["result"]["botProviderKey"]>
  export type BotProviderKeyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type BotProviderKeyIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type BotProviderKeyIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }

  export type $BotProviderKeyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotProviderKey"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      providerKeyId: string
      isPrimary: boolean
      createdAt: Date
    }, ExtArgs["result"]["botProviderKey"]>
    composites: {}
  }

  type BotProviderKeyGetPayload<S extends boolean | null | undefined | BotProviderKeyDefaultArgs> = $Result.GetResult<Prisma.$BotProviderKeyPayload, S>

  type BotProviderKeyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotProviderKeyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotProviderKeyCountAggregateInputType | true
    }

  export interface BotProviderKeyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotProviderKey'], meta: { name: 'BotProviderKey' } }
    /**
     * Find zero or one BotProviderKey that matches the filter.
     * @param {BotProviderKeyFindUniqueArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotProviderKeyFindUniqueArgs>(args: SelectSubset<T, BotProviderKeyFindUniqueArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotProviderKey that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotProviderKeyFindUniqueOrThrowArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotProviderKeyFindUniqueOrThrowArgs>(args: SelectSubset<T, BotProviderKeyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotProviderKey that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindFirstArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotProviderKeyFindFirstArgs>(args?: SelectSubset<T, BotProviderKeyFindFirstArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotProviderKey that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindFirstOrThrowArgs} args - Arguments to find a BotProviderKey
     * @example
     * // Get one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotProviderKeyFindFirstOrThrowArgs>(args?: SelectSubset<T, BotProviderKeyFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotProviderKeys that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotProviderKeys
     * const botProviderKeys = await prisma.botProviderKey.findMany()
     * 
     * // Get first 10 BotProviderKeys
     * const botProviderKeys = await prisma.botProviderKey.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotProviderKeyFindManyArgs>(args?: SelectSubset<T, BotProviderKeyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotProviderKey.
     * @param {BotProviderKeyCreateArgs} args - Arguments to create a BotProviderKey.
     * @example
     * // Create one BotProviderKey
     * const BotProviderKey = await prisma.botProviderKey.create({
     *   data: {
     *     // ... data to create a BotProviderKey
     *   }
     * })
     * 
     */
    create<T extends BotProviderKeyCreateArgs>(args: SelectSubset<T, BotProviderKeyCreateArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotProviderKeys.
     * @param {BotProviderKeyCreateManyArgs} args - Arguments to create many BotProviderKeys.
     * @example
     * // Create many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotProviderKeyCreateManyArgs>(args?: SelectSubset<T, BotProviderKeyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotProviderKeys and returns the data saved in the database.
     * @param {BotProviderKeyCreateManyAndReturnArgs} args - Arguments to create many BotProviderKeys.
     * @example
     * // Create many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotProviderKeys and only return the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotProviderKeyCreateManyAndReturnArgs>(args?: SelectSubset<T, BotProviderKeyCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotProviderKey.
     * @param {BotProviderKeyDeleteArgs} args - Arguments to delete one BotProviderKey.
     * @example
     * // Delete one BotProviderKey
     * const BotProviderKey = await prisma.botProviderKey.delete({
     *   where: {
     *     // ... filter to delete one BotProviderKey
     *   }
     * })
     * 
     */
    delete<T extends BotProviderKeyDeleteArgs>(args: SelectSubset<T, BotProviderKeyDeleteArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotProviderKey.
     * @param {BotProviderKeyUpdateArgs} args - Arguments to update one BotProviderKey.
     * @example
     * // Update one BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotProviderKeyUpdateArgs>(args: SelectSubset<T, BotProviderKeyUpdateArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotProviderKeys.
     * @param {BotProviderKeyDeleteManyArgs} args - Arguments to filter BotProviderKeys to delete.
     * @example
     * // Delete a few BotProviderKeys
     * const { count } = await prisma.botProviderKey.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotProviderKeyDeleteManyArgs>(args?: SelectSubset<T, BotProviderKeyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotProviderKeyUpdateManyArgs>(args: SelectSubset<T, BotProviderKeyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotProviderKeys and returns the data updated in the database.
     * @param {BotProviderKeyUpdateManyAndReturnArgs} args - Arguments to update many BotProviderKeys.
     * @example
     * // Update many BotProviderKeys
     * const botProviderKey = await prisma.botProviderKey.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotProviderKeys and only return the `id`
     * const botProviderKeyWithIdOnly = await prisma.botProviderKey.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotProviderKeyUpdateManyAndReturnArgs>(args: SelectSubset<T, BotProviderKeyUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotProviderKey.
     * @param {BotProviderKeyUpsertArgs} args - Arguments to update or create a BotProviderKey.
     * @example
     * // Update or create a BotProviderKey
     * const botProviderKey = await prisma.botProviderKey.upsert({
     *   create: {
     *     // ... data to create a BotProviderKey
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotProviderKey we want to update
     *   }
     * })
     */
    upsert<T extends BotProviderKeyUpsertArgs>(args: SelectSubset<T, BotProviderKeyUpsertArgs<ExtArgs>>): Prisma__BotProviderKeyClient<$Result.GetResult<Prisma.$BotProviderKeyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotProviderKeys.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyCountArgs} args - Arguments to filter BotProviderKeys to count.
     * @example
     * // Count the number of BotProviderKeys
     * const count = await prisma.botProviderKey.count({
     *   where: {
     *     // ... the filter for the BotProviderKeys we want to count
     *   }
     * })
    **/
    count<T extends BotProviderKeyCountArgs>(
      args?: Subset<T, BotProviderKeyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotProviderKeyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotProviderKeyAggregateArgs>(args: Subset<T, BotProviderKeyAggregateArgs>): Prisma.PrismaPromise<GetBotProviderKeyAggregateType<T>>

    /**
     * Group by BotProviderKey.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotProviderKeyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotProviderKeyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotProviderKeyGroupByArgs['orderBy'] }
        : { orderBy?: BotProviderKeyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotProviderKeyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotProviderKeyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotProviderKey model
   */
  readonly fields: BotProviderKeyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotProviderKey.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotProviderKeyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends ProviderKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKeyDefaultArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotProviderKey model
   */
  interface BotProviderKeyFieldRefs {
    readonly id: FieldRef<"BotProviderKey", 'String'>
    readonly botId: FieldRef<"BotProviderKey", 'String'>
    readonly providerKeyId: FieldRef<"BotProviderKey", 'String'>
    readonly isPrimary: FieldRef<"BotProviderKey", 'Boolean'>
    readonly createdAt: FieldRef<"BotProviderKey", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotProviderKey findUnique
   */
  export type BotProviderKeyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey findUniqueOrThrow
   */
  export type BotProviderKeyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey findFirst
   */
  export type BotProviderKeyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotProviderKeys.
     */
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey findFirstOrThrow
   */
  export type BotProviderKeyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKey to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotProviderKeys.
     */
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey findMany
   */
  export type BotProviderKeyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter, which BotProviderKeys to fetch.
     */
    where?: BotProviderKeyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotProviderKeys to fetch.
     */
    orderBy?: BotProviderKeyOrderByWithRelationInput | BotProviderKeyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotProviderKeys.
     */
    cursor?: BotProviderKeyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotProviderKeys from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotProviderKeys.
     */
    skip?: number
    distinct?: BotProviderKeyScalarFieldEnum | BotProviderKeyScalarFieldEnum[]
  }

  /**
   * BotProviderKey create
   */
  export type BotProviderKeyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to create a BotProviderKey.
     */
    data: XOR<BotProviderKeyCreateInput, BotProviderKeyUncheckedCreateInput>
  }

  /**
   * BotProviderKey createMany
   */
  export type BotProviderKeyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotProviderKeys.
     */
    data: BotProviderKeyCreateManyInput | BotProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotProviderKey createManyAndReturn
   */
  export type BotProviderKeyCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to create many BotProviderKeys.
     */
    data: BotProviderKeyCreateManyInput | BotProviderKeyCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotProviderKey update
   */
  export type BotProviderKeyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The data needed to update a BotProviderKey.
     */
    data: XOR<BotProviderKeyUpdateInput, BotProviderKeyUncheckedUpdateInput>
    /**
     * Choose, which BotProviderKey to update.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey updateMany
   */
  export type BotProviderKeyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotProviderKeys.
     */
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which BotProviderKeys to update
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to update.
     */
    limit?: number
  }

  /**
   * BotProviderKey updateManyAndReturn
   */
  export type BotProviderKeyUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * The data used to update BotProviderKeys.
     */
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyInput>
    /**
     * Filter which BotProviderKeys to update
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotProviderKey upsert
   */
  export type BotProviderKeyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * The filter to search for the BotProviderKey to update in case it exists.
     */
    where: BotProviderKeyWhereUniqueInput
    /**
     * In case the BotProviderKey found by the `where` argument doesn't exist, create a new BotProviderKey with this data.
     */
    create: XOR<BotProviderKeyCreateInput, BotProviderKeyUncheckedCreateInput>
    /**
     * In case the BotProviderKey was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotProviderKeyUpdateInput, BotProviderKeyUncheckedUpdateInput>
  }

  /**
   * BotProviderKey delete
   */
  export type BotProviderKeyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
    /**
     * Filter which BotProviderKey to delete.
     */
    where: BotProviderKeyWhereUniqueInput
  }

  /**
   * BotProviderKey deleteMany
   */
  export type BotProviderKeyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotProviderKeys to delete
     */
    where?: BotProviderKeyWhereInput
    /**
     * Limit how many BotProviderKeys to delete.
     */
    limit?: number
  }

  /**
   * BotProviderKey without action
   */
  export type BotProviderKeyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotProviderKey
     */
    select?: BotProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotProviderKey
     */
    omit?: BotProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotProviderKeyInclude<ExtArgs> | null
  }


  /**
   * Model BotUsageLog
   */

  export type AggregateBotUsageLog = {
    _count: BotUsageLogCountAggregateOutputType | null
    _avg: BotUsageLogAvgAggregateOutputType | null
    _sum: BotUsageLogSumAggregateOutputType | null
    _min: BotUsageLogMinAggregateOutputType | null
    _max: BotUsageLogMaxAggregateOutputType | null
  }

  export type BotUsageLogAvgAggregateOutputType = {
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
  }

  export type BotUsageLogSumAggregateOutputType = {
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
  }

  export type BotUsageLogMinAggregateOutputType = {
    id: string | null
    botId: string | null
    vendor: string | null
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date | null
  }

  export type BotUsageLogMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    vendor: string | null
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date | null
  }

  export type BotUsageLogCountAggregateOutputType = {
    id: number
    botId: number
    vendor: number
    providerKeyId: number
    statusCode: number
    requestTokens: number
    responseTokens: number
    createdAt: number
    _all: number
  }


  export type BotUsageLogAvgAggregateInputType = {
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
  }

  export type BotUsageLogSumAggregateInputType = {
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
  }

  export type BotUsageLogMinAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
  }

  export type BotUsageLogMaxAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
  }

  export type BotUsageLogCountAggregateInputType = {
    id?: true
    botId?: true
    vendor?: true
    providerKeyId?: true
    statusCode?: true
    requestTokens?: true
    responseTokens?: true
    createdAt?: true
    _all?: true
  }

  export type BotUsageLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUsageLog to aggregate.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BotUsageLogs
    **/
    _count?: true | BotUsageLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BotUsageLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BotUsageLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BotUsageLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BotUsageLogMaxAggregateInputType
  }

  export type GetBotUsageLogAggregateType<T extends BotUsageLogAggregateArgs> = {
        [P in keyof T & keyof AggregateBotUsageLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBotUsageLog[P]>
      : GetScalarType<T[P], AggregateBotUsageLog[P]>
  }




  export type BotUsageLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BotUsageLogWhereInput
    orderBy?: BotUsageLogOrderByWithAggregationInput | BotUsageLogOrderByWithAggregationInput[]
    by: BotUsageLogScalarFieldEnum[] | BotUsageLogScalarFieldEnum
    having?: BotUsageLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BotUsageLogCountAggregateInputType | true
    _avg?: BotUsageLogAvgAggregateInputType
    _sum?: BotUsageLogSumAggregateInputType
    _min?: BotUsageLogMinAggregateInputType
    _max?: BotUsageLogMaxAggregateInputType
  }

  export type BotUsageLogGroupByOutputType = {
    id: string
    botId: string
    vendor: string
    providerKeyId: string | null
    statusCode: number | null
    requestTokens: number | null
    responseTokens: number | null
    createdAt: Date
    _count: BotUsageLogCountAggregateOutputType | null
    _avg: BotUsageLogAvgAggregateOutputType | null
    _sum: BotUsageLogSumAggregateOutputType | null
    _min: BotUsageLogMinAggregateOutputType | null
    _max: BotUsageLogMaxAggregateOutputType | null
  }

  type GetBotUsageLogGroupByPayload<T extends BotUsageLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BotUsageLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BotUsageLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BotUsageLogGroupByOutputType[P]>
            : GetScalarType<T[P], BotUsageLogGroupByOutputType[P]>
        }
      >
    >


  export type BotUsageLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }, ExtArgs["result"]["botUsageLog"]>

  export type BotUsageLogSelectScalar = {
    id?: boolean
    botId?: boolean
    vendor?: boolean
    providerKeyId?: boolean
    statusCode?: boolean
    requestTokens?: boolean
    responseTokens?: boolean
    createdAt?: boolean
  }

  export type BotUsageLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "vendor" | "providerKeyId" | "statusCode" | "requestTokens" | "responseTokens" | "createdAt", ExtArgs["result"]["botUsageLog"]>
  export type BotUsageLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }
  export type BotUsageLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }
  export type BotUsageLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | BotUsageLog$providerKeyArgs<ExtArgs>
  }

  export type $BotUsageLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BotUsageLog"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      botId: string
      vendor: string
      providerKeyId: string | null
      statusCode: number | null
      requestTokens: number | null
      responseTokens: number | null
      createdAt: Date
    }, ExtArgs["result"]["botUsageLog"]>
    composites: {}
  }

  type BotUsageLogGetPayload<S extends boolean | null | undefined | BotUsageLogDefaultArgs> = $Result.GetResult<Prisma.$BotUsageLogPayload, S>

  type BotUsageLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BotUsageLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BotUsageLogCountAggregateInputType | true
    }

  export interface BotUsageLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BotUsageLog'], meta: { name: 'BotUsageLog' } }
    /**
     * Find zero or one BotUsageLog that matches the filter.
     * @param {BotUsageLogFindUniqueArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BotUsageLogFindUniqueArgs>(args: SelectSubset<T, BotUsageLogFindUniqueArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BotUsageLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BotUsageLogFindUniqueOrThrowArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BotUsageLogFindUniqueOrThrowArgs>(args: SelectSubset<T, BotUsageLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotUsageLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindFirstArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BotUsageLogFindFirstArgs>(args?: SelectSubset<T, BotUsageLogFindFirstArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BotUsageLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindFirstOrThrowArgs} args - Arguments to find a BotUsageLog
     * @example
     * // Get one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BotUsageLogFindFirstOrThrowArgs>(args?: SelectSubset<T, BotUsageLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BotUsageLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BotUsageLogs
     * const botUsageLogs = await prisma.botUsageLog.findMany()
     * 
     * // Get first 10 BotUsageLogs
     * const botUsageLogs = await prisma.botUsageLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BotUsageLogFindManyArgs>(args?: SelectSubset<T, BotUsageLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BotUsageLog.
     * @param {BotUsageLogCreateArgs} args - Arguments to create a BotUsageLog.
     * @example
     * // Create one BotUsageLog
     * const BotUsageLog = await prisma.botUsageLog.create({
     *   data: {
     *     // ... data to create a BotUsageLog
     *   }
     * })
     * 
     */
    create<T extends BotUsageLogCreateArgs>(args: SelectSubset<T, BotUsageLogCreateArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BotUsageLogs.
     * @param {BotUsageLogCreateManyArgs} args - Arguments to create many BotUsageLogs.
     * @example
     * // Create many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BotUsageLogCreateManyArgs>(args?: SelectSubset<T, BotUsageLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BotUsageLogs and returns the data saved in the database.
     * @param {BotUsageLogCreateManyAndReturnArgs} args - Arguments to create many BotUsageLogs.
     * @example
     * // Create many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BotUsageLogs and only return the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BotUsageLogCreateManyAndReturnArgs>(args?: SelectSubset<T, BotUsageLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BotUsageLog.
     * @param {BotUsageLogDeleteArgs} args - Arguments to delete one BotUsageLog.
     * @example
     * // Delete one BotUsageLog
     * const BotUsageLog = await prisma.botUsageLog.delete({
     *   where: {
     *     // ... filter to delete one BotUsageLog
     *   }
     * })
     * 
     */
    delete<T extends BotUsageLogDeleteArgs>(args: SelectSubset<T, BotUsageLogDeleteArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BotUsageLog.
     * @param {BotUsageLogUpdateArgs} args - Arguments to update one BotUsageLog.
     * @example
     * // Update one BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BotUsageLogUpdateArgs>(args: SelectSubset<T, BotUsageLogUpdateArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BotUsageLogs.
     * @param {BotUsageLogDeleteManyArgs} args - Arguments to filter BotUsageLogs to delete.
     * @example
     * // Delete a few BotUsageLogs
     * const { count } = await prisma.botUsageLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BotUsageLogDeleteManyArgs>(args?: SelectSubset<T, BotUsageLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BotUsageLogUpdateManyArgs>(args: SelectSubset<T, BotUsageLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BotUsageLogs and returns the data updated in the database.
     * @param {BotUsageLogUpdateManyAndReturnArgs} args - Arguments to update many BotUsageLogs.
     * @example
     * // Update many BotUsageLogs
     * const botUsageLog = await prisma.botUsageLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BotUsageLogs and only return the `id`
     * const botUsageLogWithIdOnly = await prisma.botUsageLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BotUsageLogUpdateManyAndReturnArgs>(args: SelectSubset<T, BotUsageLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BotUsageLog.
     * @param {BotUsageLogUpsertArgs} args - Arguments to update or create a BotUsageLog.
     * @example
     * // Update or create a BotUsageLog
     * const botUsageLog = await prisma.botUsageLog.upsert({
     *   create: {
     *     // ... data to create a BotUsageLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BotUsageLog we want to update
     *   }
     * })
     */
    upsert<T extends BotUsageLogUpsertArgs>(args: SelectSubset<T, BotUsageLogUpsertArgs<ExtArgs>>): Prisma__BotUsageLogClient<$Result.GetResult<Prisma.$BotUsageLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BotUsageLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogCountArgs} args - Arguments to filter BotUsageLogs to count.
     * @example
     * // Count the number of BotUsageLogs
     * const count = await prisma.botUsageLog.count({
     *   where: {
     *     // ... the filter for the BotUsageLogs we want to count
     *   }
     * })
    **/
    count<T extends BotUsageLogCountArgs>(
      args?: Subset<T, BotUsageLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BotUsageLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BotUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BotUsageLogAggregateArgs>(args: Subset<T, BotUsageLogAggregateArgs>): Prisma.PrismaPromise<GetBotUsageLogAggregateType<T>>

    /**
     * Group by BotUsageLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BotUsageLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BotUsageLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BotUsageLogGroupByArgs['orderBy'] }
        : { orderBy?: BotUsageLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BotUsageLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBotUsageLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BotUsageLog model
   */
  readonly fields: BotUsageLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BotUsageLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BotUsageLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends BotUsageLog$providerKeyArgs<ExtArgs> = {}>(args?: Subset<T, BotUsageLog$providerKeyArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BotUsageLog model
   */
  interface BotUsageLogFieldRefs {
    readonly id: FieldRef<"BotUsageLog", 'String'>
    readonly botId: FieldRef<"BotUsageLog", 'String'>
    readonly vendor: FieldRef<"BotUsageLog", 'String'>
    readonly providerKeyId: FieldRef<"BotUsageLog", 'String'>
    readonly statusCode: FieldRef<"BotUsageLog", 'Int'>
    readonly requestTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly responseTokens: FieldRef<"BotUsageLog", 'Int'>
    readonly createdAt: FieldRef<"BotUsageLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BotUsageLog findUnique
   */
  export type BotUsageLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog findUniqueOrThrow
   */
  export type BotUsageLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog findFirst
   */
  export type BotUsageLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsageLogs.
     */
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog findFirstOrThrow
   */
  export type BotUsageLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLog to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BotUsageLogs.
     */
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog findMany
   */
  export type BotUsageLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter, which BotUsageLogs to fetch.
     */
    where?: BotUsageLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BotUsageLogs to fetch.
     */
    orderBy?: BotUsageLogOrderByWithRelationInput | BotUsageLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BotUsageLogs.
     */
    cursor?: BotUsageLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` BotUsageLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BotUsageLogs.
     */
    skip?: number
    distinct?: BotUsageLogScalarFieldEnum | BotUsageLogScalarFieldEnum[]
  }

  /**
   * BotUsageLog create
   */
  export type BotUsageLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to create a BotUsageLog.
     */
    data: XOR<BotUsageLogCreateInput, BotUsageLogUncheckedCreateInput>
  }

  /**
   * BotUsageLog createMany
   */
  export type BotUsageLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BotUsageLogs.
     */
    data: BotUsageLogCreateManyInput | BotUsageLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BotUsageLog createManyAndReturn
   */
  export type BotUsageLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * The data used to create many BotUsageLogs.
     */
    data: BotUsageLogCreateManyInput | BotUsageLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotUsageLog update
   */
  export type BotUsageLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The data needed to update a BotUsageLog.
     */
    data: XOR<BotUsageLogUpdateInput, BotUsageLogUncheckedUpdateInput>
    /**
     * Choose, which BotUsageLog to update.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog updateMany
   */
  export type BotUsageLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BotUsageLogs.
     */
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which BotUsageLogs to update
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to update.
     */
    limit?: number
  }

  /**
   * BotUsageLog updateManyAndReturn
   */
  export type BotUsageLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * The data used to update BotUsageLogs.
     */
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyInput>
    /**
     * Filter which BotUsageLogs to update
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BotUsageLog upsert
   */
  export type BotUsageLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * The filter to search for the BotUsageLog to update in case it exists.
     */
    where: BotUsageLogWhereUniqueInput
    /**
     * In case the BotUsageLog found by the `where` argument doesn't exist, create a new BotUsageLog with this data.
     */
    create: XOR<BotUsageLogCreateInput, BotUsageLogUncheckedCreateInput>
    /**
     * In case the BotUsageLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BotUsageLogUpdateInput, BotUsageLogUncheckedUpdateInput>
  }

  /**
   * BotUsageLog delete
   */
  export type BotUsageLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
    /**
     * Filter which BotUsageLog to delete.
     */
    where: BotUsageLogWhereUniqueInput
  }

  /**
   * BotUsageLog deleteMany
   */
  export type BotUsageLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BotUsageLogs to delete
     */
    where?: BotUsageLogWhereInput
    /**
     * Limit how many BotUsageLogs to delete.
     */
    limit?: number
  }

  /**
   * BotUsageLog.providerKey
   */
  export type BotUsageLog$providerKeyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProviderKey
     */
    select?: ProviderKeySelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProviderKey
     */
    omit?: ProviderKeyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProviderKeyInclude<ExtArgs> | null
    where?: ProviderKeyWhereInput
  }

  /**
   * BotUsageLog without action
   */
  export type BotUsageLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BotUsageLog
     */
    select?: BotUsageLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BotUsageLog
     */
    omit?: BotUsageLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BotUsageLogInclude<ExtArgs> | null
  }


  /**
   * Model ProxyToken
   */

  export type AggregateProxyToken = {
    _count: ProxyTokenCountAggregateOutputType | null
    _avg: ProxyTokenAvgAggregateOutputType | null
    _sum: ProxyTokenSumAggregateOutputType | null
    _min: ProxyTokenMinAggregateOutputType | null
    _max: ProxyTokenMaxAggregateOutputType | null
  }

  export type ProxyTokenAvgAggregateOutputType = {
    requestCount: number | null
  }

  export type ProxyTokenSumAggregateOutputType = {
    requestCount: number | null
  }

  export type ProxyTokenMinAggregateOutputType = {
    id: string | null
    botId: string | null
    tokenHash: string | null
    vendor: string | null
    keyId: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyTokenMaxAggregateOutputType = {
    id: string | null
    botId: string | null
    tokenHash: string | null
    vendor: string | null
    keyId: string | null
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProxyTokenCountAggregateOutputType = {
    id: number
    botId: number
    tokenHash: number
    vendor: number
    keyId: number
    tags: number
    expiresAt: number
    revokedAt: number
    lastUsedAt: number
    requestCount: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProxyTokenAvgAggregateInputType = {
    requestCount?: true
  }

  export type ProxyTokenSumAggregateInputType = {
    requestCount?: true
  }

  export type ProxyTokenMinAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyTokenMaxAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProxyTokenCountAggregateInputType = {
    id?: true
    botId?: true
    tokenHash?: true
    vendor?: true
    keyId?: true
    tags?: true
    expiresAt?: true
    revokedAt?: true
    lastUsedAt?: true
    requestCount?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProxyTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyToken to aggregate.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProxyTokens
    **/
    _count?: true | ProxyTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProxyTokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProxyTokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProxyTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProxyTokenMaxAggregateInputType
  }

  export type GetProxyTokenAggregateType<T extends ProxyTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateProxyToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProxyToken[P]>
      : GetScalarType<T[P], AggregateProxyToken[P]>
  }




  export type ProxyTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProxyTokenWhereInput
    orderBy?: ProxyTokenOrderByWithAggregationInput | ProxyTokenOrderByWithAggregationInput[]
    by: ProxyTokenScalarFieldEnum[] | ProxyTokenScalarFieldEnum
    having?: ProxyTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProxyTokenCountAggregateInputType | true
    _avg?: ProxyTokenAvgAggregateInputType
    _sum?: ProxyTokenSumAggregateInputType
    _min?: ProxyTokenMinAggregateInputType
    _max?: ProxyTokenMaxAggregateInputType
  }

  export type ProxyTokenGroupByOutputType = {
    id: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags: string[]
    expiresAt: Date | null
    revokedAt: Date | null
    lastUsedAt: Date | null
    requestCount: number
    createdAt: Date
    updatedAt: Date
    _count: ProxyTokenCountAggregateOutputType | null
    _avg: ProxyTokenAvgAggregateOutputType | null
    _sum: ProxyTokenSumAggregateOutputType | null
    _min: ProxyTokenMinAggregateOutputType | null
    _max: ProxyTokenMaxAggregateOutputType | null
  }

  type GetProxyTokenGroupByPayload<T extends ProxyTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProxyTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProxyTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProxyTokenGroupByOutputType[P]>
            : GetScalarType<T[P], ProxyTokenGroupByOutputType[P]>
        }
      >
    >


  export type ProxyTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proxyToken"]>

  export type ProxyTokenSelectScalar = {
    id?: boolean
    botId?: boolean
    tokenHash?: boolean
    vendor?: boolean
    keyId?: boolean
    tags?: boolean
    expiresAt?: boolean
    revokedAt?: boolean
    lastUsedAt?: boolean
    requestCount?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ProxyTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "botId" | "tokenHash" | "vendor" | "keyId" | "tags" | "expiresAt" | "revokedAt" | "lastUsedAt" | "requestCount" | "createdAt" | "updatedAt", ExtArgs["result"]["proxyToken"]>
  export type ProxyTokenInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type ProxyTokenIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }
  export type ProxyTokenIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bot?: boolean | BotDefaultArgs<ExtArgs>
    providerKey?: boolean | ProviderKeyDefaultArgs<ExtArgs>
  }

  export type $ProxyTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProxyToken"
    objects: {
      bot: Prisma.$BotPayload<ExtArgs>
      providerKey: Prisma.$ProviderKeyPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      /**
       * ÂÖ≥ËÅîÁöÑ Bot IDÔºà‰∏ÄÂØπ‰∏ÄÂÖ≥Á≥ªÔºâ
       */
      botId: string
      /**
       * Token ÁöÑ SHA-256 ÂìàÂ∏åÂÄºÔºàÊ∞∏‰∏çÂ≠òÂÇ®ÂéüÂßã TokenÔºâ
       */
      tokenHash: string
      /**
       * AI ÊúçÂä°ÂïÜÊ†áËØÜÔºàopenai, anthropic, google Á≠âÔºâ
       */
      vendor: string
      /**
       * ÂÖ≥ËÅîÁöÑ ProviderKey ID
       */
      keyId: string
      /**
       * ËÆøÈóÆÊéßÂà∂Ê†áÁ≠æ
       */
      tags: string[]
      /**
       * Token ËøáÊúüÊó∂Èó¥ÔºàÂèØÈÄâÔºâ
       */
      expiresAt: Date | null
      /**
       * Token Êí§ÈîÄÊó∂Èó¥Ôºànull Ë°®Á§∫ÊúâÊïàÔºâ
       */
      revokedAt: Date | null
      /**
       * ÊúÄÂêé‰ΩøÁî®Êó∂Èó¥
       */
      lastUsedAt: Date | null
      /**
       * ËØ∑Ê±ÇËÆ°Êï∞
       */
      requestCount: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["proxyToken"]>
    composites: {}
  }

  type ProxyTokenGetPayload<S extends boolean | null | undefined | ProxyTokenDefaultArgs> = $Result.GetResult<Prisma.$ProxyTokenPayload, S>

  type ProxyTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProxyTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProxyTokenCountAggregateInputType | true
    }

  export interface ProxyTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProxyToken'], meta: { name: 'ProxyToken' } }
    /**
     * Find zero or one ProxyToken that matches the filter.
     * @param {ProxyTokenFindUniqueArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProxyTokenFindUniqueArgs>(args: SelectSubset<T, ProxyTokenFindUniqueArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProxyToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProxyTokenFindUniqueOrThrowArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProxyTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, ProxyTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindFirstArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProxyTokenFindFirstArgs>(args?: SelectSubset<T, ProxyTokenFindFirstArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProxyToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindFirstOrThrowArgs} args - Arguments to find a ProxyToken
     * @example
     * // Get one ProxyToken
     * const proxyToken = await prisma.proxyToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProxyTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, ProxyTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProxyTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProxyTokens
     * const proxyTokens = await prisma.proxyToken.findMany()
     * 
     * // Get first 10 ProxyTokens
     * const proxyTokens = await prisma.proxyToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProxyTokenFindManyArgs>(args?: SelectSubset<T, ProxyTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProxyToken.
     * @param {ProxyTokenCreateArgs} args - Arguments to create a ProxyToken.
     * @example
     * // Create one ProxyToken
     * const ProxyToken = await prisma.proxyToken.create({
     *   data: {
     *     // ... data to create a ProxyToken
     *   }
     * })
     * 
     */
    create<T extends ProxyTokenCreateArgs>(args: SelectSubset<T, ProxyTokenCreateArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProxyTokens.
     * @param {ProxyTokenCreateManyArgs} args - Arguments to create many ProxyTokens.
     * @example
     * // Create many ProxyTokens
     * const proxyToken = await prisma.proxyToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProxyTokenCreateManyArgs>(args?: SelectSubset<T, ProxyTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProxyTokens and returns the data saved in the database.
     * @param {ProxyTokenCreateManyAndReturnArgs} args - Arguments to create many ProxyTokens.
     * @example
     * // Create many ProxyTokens
     * const proxyToken = await prisma.proxyToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProxyTokens and only return the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProxyTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, ProxyTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProxyToken.
     * @param {ProxyTokenDeleteArgs} args - Arguments to delete one ProxyToken.
     * @example
     * // Delete one ProxyToken
     * const ProxyToken = await prisma.proxyToken.delete({
     *   where: {
     *     // ... filter to delete one ProxyToken
     *   }
     * })
     * 
     */
    delete<T extends ProxyTokenDeleteArgs>(args: SelectSubset<T, ProxyTokenDeleteArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProxyToken.
     * @param {ProxyTokenUpdateArgs} args - Arguments to update one ProxyToken.
     * @example
     * // Update one ProxyToken
     * const proxyToken = await prisma.proxyToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProxyTokenUpdateArgs>(args: SelectSubset<T, ProxyTokenUpdateArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProxyTokens.
     * @param {ProxyTokenDeleteManyArgs} args - Arguments to filter ProxyTokens to delete.
     * @example
     * // Delete a few ProxyTokens
     * const { count } = await prisma.proxyToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProxyTokenDeleteManyArgs>(args?: SelectSubset<T, ProxyTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProxyTokens
     * const proxyToken = await prisma.proxyToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProxyTokenUpdateManyArgs>(args: SelectSubset<T, ProxyTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProxyTokens and returns the data updated in the database.
     * @param {ProxyTokenUpdateManyAndReturnArgs} args - Arguments to update many ProxyTokens.
     * @example
     * // Update many ProxyTokens
     * const proxyToken = await prisma.proxyToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProxyTokens and only return the `id`
     * const proxyTokenWithIdOnly = await prisma.proxyToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProxyTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, ProxyTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProxyToken.
     * @param {ProxyTokenUpsertArgs} args - Arguments to update or create a ProxyToken.
     * @example
     * // Update or create a ProxyToken
     * const proxyToken = await prisma.proxyToken.upsert({
     *   create: {
     *     // ... data to create a ProxyToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProxyToken we want to update
     *   }
     * })
     */
    upsert<T extends ProxyTokenUpsertArgs>(args: SelectSubset<T, ProxyTokenUpsertArgs<ExtArgs>>): Prisma__ProxyTokenClient<$Result.GetResult<Prisma.$ProxyTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProxyTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenCountArgs} args - Arguments to filter ProxyTokens to count.
     * @example
     * // Count the number of ProxyTokens
     * const count = await prisma.proxyToken.count({
     *   where: {
     *     // ... the filter for the ProxyTokens we want to count
     *   }
     * })
    **/
    count<T extends ProxyTokenCountArgs>(
      args?: Subset<T, ProxyTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProxyTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProxyToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProxyTokenAggregateArgs>(args: Subset<T, ProxyTokenAggregateArgs>): Prisma.PrismaPromise<GetProxyTokenAggregateType<T>>

    /**
     * Group by ProxyToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProxyTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProxyTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProxyTokenGroupByArgs['orderBy'] }
        : { orderBy?: ProxyTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProxyTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProxyTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProxyToken model
   */
  readonly fields: ProxyTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProxyToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProxyTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bot<T extends BotDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BotDefaultArgs<ExtArgs>>): Prisma__BotClient<$Result.GetResult<Prisma.$BotPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    providerKey<T extends ProviderKeyDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProviderKeyDefaultArgs<ExtArgs>>): Prisma__ProviderKeyClient<$Result.GetResult<Prisma.$ProviderKeyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProxyToken model
   */
  interface ProxyTokenFieldRefs {
    readonly id: FieldRef<"ProxyToken", 'String'>
    readonly botId: FieldRef<"ProxyToken", 'String'>
    readonly tokenHash: FieldRef<"ProxyToken", 'String'>
    readonly vendor: FieldRef<"ProxyToken", 'String'>
    readonly keyId: FieldRef<"ProxyToken", 'String'>
    readonly tags: FieldRef<"ProxyToken", 'String[]'>
    readonly expiresAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly revokedAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly lastUsedAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly requestCount: FieldRef<"ProxyToken", 'Int'>
    readonly createdAt: FieldRef<"ProxyToken", 'DateTime'>
    readonly updatedAt: FieldRef<"ProxyToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProxyToken findUnique
   */
  export type ProxyTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken findUniqueOrThrow
   */
  export type ProxyTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken findFirst
   */
  export type ProxyTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyTokens.
     */
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken findFirstOrThrow
   */
  export type ProxyTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyToken to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProxyTokens.
     */
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken findMany
   */
  export type ProxyTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter, which ProxyTokens to fetch.
     */
    where?: ProxyTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProxyTokens to fetch.
     */
    orderBy?: ProxyTokenOrderByWithRelationInput | ProxyTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProxyTokens.
     */
    cursor?: ProxyTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ProxyTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProxyTokens.
     */
    skip?: number
    distinct?: ProxyTokenScalarFieldEnum | ProxyTokenScalarFieldEnum[]
  }

  /**
   * ProxyToken create
   */
  export type ProxyTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The data needed to create a ProxyToken.
     */
    data: XOR<ProxyTokenCreateInput, ProxyTokenUncheckedCreateInput>
  }

  /**
   * ProxyToken createMany
   */
  export type ProxyTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProxyTokens.
     */
    data: ProxyTokenCreateManyInput | ProxyTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProxyToken createManyAndReturn
   */
  export type ProxyTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * The data used to create many ProxyTokens.
     */
    data: ProxyTokenCreateManyInput | ProxyTokenCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyToken update
   */
  export type ProxyTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The data needed to update a ProxyToken.
     */
    data: XOR<ProxyTokenUpdateInput, ProxyTokenUncheckedUpdateInput>
    /**
     * Choose, which ProxyToken to update.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken updateMany
   */
  export type ProxyTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProxyTokens.
     */
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyInput>
    /**
     * Filter which ProxyTokens to update
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to update.
     */
    limit?: number
  }

  /**
   * ProxyToken updateManyAndReturn
   */
  export type ProxyTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * The data used to update ProxyTokens.
     */
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyInput>
    /**
     * Filter which ProxyTokens to update
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProxyToken upsert
   */
  export type ProxyTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * The filter to search for the ProxyToken to update in case it exists.
     */
    where: ProxyTokenWhereUniqueInput
    /**
     * In case the ProxyToken found by the `where` argument doesn't exist, create a new ProxyToken with this data.
     */
    create: XOR<ProxyTokenCreateInput, ProxyTokenUncheckedCreateInput>
    /**
     * In case the ProxyToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProxyTokenUpdateInput, ProxyTokenUncheckedUpdateInput>
  }

  /**
   * ProxyToken delete
   */
  export type ProxyTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
    /**
     * Filter which ProxyToken to delete.
     */
    where: ProxyTokenWhereUniqueInput
  }

  /**
   * ProxyToken deleteMany
   */
  export type ProxyTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProxyTokens to delete
     */
    where?: ProxyTokenWhereInput
    /**
     * Limit how many ProxyTokens to delete.
     */
    limit?: number
  }

  /**
   * ProxyToken without action
   */
  export type ProxyTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProxyToken
     */
    select?: ProxyTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProxyToken
     */
    omit?: ProxyTokenOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProxyTokenInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    type: string | null
    title: string | null
    senderId: string | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    type: number
    title: number
    content: number
    senderId: number
    metadata: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    type?: true
    title?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    type?: true
    title?: true
    senderId?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    type?: true
    title?: true
    content?: true
    senderId?: true
    metadata?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    type: string
    title: string | null
    content: JsonValue
    senderId: string | null
    metadata: JsonValue | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedAt: Date | null
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    sender?: boolean | Message$senderArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    type?: boolean
    title?: boolean
    content?: boolean
    senderId?: boolean
    metadata?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "title" | "content" | "senderId" | "metadata" | "createdAt" | "updatedAt" | "isDeleted" | "deletedAt", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
    recipients?: boolean | Message$recipientsArgs<ExtArgs>
    _count?: boolean | MessageCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sender?: boolean | Message$senderArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      sender: Prisma.$UserInfoPayload<ExtArgs> | null
      recipients: Prisma.$MessageRecipientPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: string
      title: string | null
      content: Prisma.JsonValue
      senderId: string | null
      metadata: Prisma.JsonValue | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sender<T extends Message$senderArgs<ExtArgs> = {}>(args?: Subset<T, Message$senderArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    recipients<T extends Message$recipientsArgs<ExtArgs> = {}>(args?: Subset<T, Message$recipientsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly type: FieldRef<"Message", 'String'>
    readonly title: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'Json'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly metadata: FieldRef<"Message", 'Json'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly updatedAt: FieldRef<"Message", 'DateTime'>
    readonly isDeleted: FieldRef<"Message", 'Boolean'>
    readonly deletedAt: FieldRef<"Message", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.sender
   */
  export type Message$senderArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserInfo
     */
    select?: UserInfoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserInfo
     */
    omit?: UserInfoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInfoInclude<ExtArgs> | null
    where?: UserInfoWhereInput
  }

  /**
   * Message.recipients
   */
  export type Message$recipientsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    cursor?: MessageRecipientWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model MessageRecipient
   */

  export type AggregateMessageRecipient = {
    _count: MessageRecipientCountAggregateOutputType | null
    _min: MessageRecipientMinAggregateOutputType | null
    _max: MessageRecipientMaxAggregateOutputType | null
  }

  export type MessageRecipientMinAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageRecipientMaxAggregateOutputType = {
    id: string | null
    messageId: string | null
    userId: string | null
    isRead: boolean | null
    readAt: Date | null
    createdAt: Date | null
    updatedAt: Date | null
    isDeleted: boolean | null
    deletedAt: Date | null
  }

  export type MessageRecipientCountAggregateOutputType = {
    id: number
    messageId: number
    userId: number
    isRead: number
    readAt: number
    createdAt: number
    updatedAt: number
    isDeleted: number
    deletedAt: number
    _all: number
  }


  export type MessageRecipientMinAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageRecipientMaxAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
  }

  export type MessageRecipientCountAggregateInputType = {
    id?: true
    messageId?: true
    userId?: true
    isRead?: true
    readAt?: true
    createdAt?: true
    updatedAt?: true
    isDeleted?: true
    deletedAt?: true
    _all?: true
  }

  export type MessageRecipientAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRecipient to aggregate.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MessageRecipients
    **/
    _count?: true | MessageRecipientCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageRecipientMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageRecipientMaxAggregateInputType
  }

  export type GetMessageRecipientAggregateType<T extends MessageRecipientAggregateArgs> = {
        [P in keyof T & keyof AggregateMessageRecipient]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessageRecipient[P]>
      : GetScalarType<T[P], AggregateMessageRecipient[P]>
  }




  export type MessageRecipientGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageRecipientWhereInput
    orderBy?: MessageRecipientOrderByWithAggregationInput | MessageRecipientOrderByWithAggregationInput[]
    by: MessageRecipientScalarFieldEnum[] | MessageRecipientScalarFieldEnum
    having?: MessageRecipientScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageRecipientCountAggregateInputType | true
    _min?: MessageRecipientMinAggregateInputType
    _max?: MessageRecipientMaxAggregateInputType
  }

  export type MessageRecipientGroupByOutputType = {
    id: string
    messageId: string
    userId: string
    isRead: boolean
    readAt: Date | null
    createdAt: Date
    updatedAt: Date
    isDeleted: boolean
    deletedAt: Date | null
    _count: MessageRecipientCountAggregateOutputType | null
    _min: MessageRecipientMinAggregateOutputType | null
    _max: MessageRecipientMaxAggregateOutputType | null
  }

  type GetMessageRecipientGroupByPayload<T extends MessageRecipientGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageRecipientGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageRecipientGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageRecipientGroupByOutputType[P]>
            : GetScalarType<T[P], MessageRecipientGroupByOutputType[P]>
        }
      >
    >


  export type MessageRecipientSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["messageRecipient"]>

  export type MessageRecipientSelectScalar = {
    id?: boolean
    messageId?: boolean
    userId?: boolean
    isRead?: boolean
    readAt?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
  }

  export type MessageRecipientOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "messageId" | "userId" | "isRead" | "readAt" | "createdAt" | "updatedAt" | "isDeleted" | "deletedAt", ExtArgs["result"]["messageRecipient"]>
  export type MessageRecipientInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MessageRecipientIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type MessageRecipientIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    message?: boolean | MessageDefaultArgs<ExtArgs>
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $MessageRecipientPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MessageRecipient"
    objects: {
      message: Prisma.$MessagePayload<ExtArgs>
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      messageId: string
      userId: string
      isRead: boolean
      readAt: Date | null
      createdAt: Date
      updatedAt: Date
      isDeleted: boolean
      deletedAt: Date | null
    }, ExtArgs["result"]["messageRecipient"]>
    composites: {}
  }

  type MessageRecipientGetPayload<S extends boolean | null | undefined | MessageRecipientDefaultArgs> = $Result.GetResult<Prisma.$MessageRecipientPayload, S>

  type MessageRecipientCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageRecipientFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageRecipientCountAggregateInputType | true
    }

  export interface MessageRecipientDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MessageRecipient'], meta: { name: 'MessageRecipient' } }
    /**
     * Find zero or one MessageRecipient that matches the filter.
     * @param {MessageRecipientFindUniqueArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageRecipientFindUniqueArgs>(args: SelectSubset<T, MessageRecipientFindUniqueArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MessageRecipient that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageRecipientFindUniqueOrThrowArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageRecipientFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageRecipientFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRecipient that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindFirstArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageRecipientFindFirstArgs>(args?: SelectSubset<T, MessageRecipientFindFirstArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MessageRecipient that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindFirstOrThrowArgs} args - Arguments to find a MessageRecipient
     * @example
     * // Get one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageRecipientFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageRecipientFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MessageRecipients that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MessageRecipients
     * const messageRecipients = await prisma.messageRecipient.findMany()
     * 
     * // Get first 10 MessageRecipients
     * const messageRecipients = await prisma.messageRecipient.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageRecipientFindManyArgs>(args?: SelectSubset<T, MessageRecipientFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MessageRecipient.
     * @param {MessageRecipientCreateArgs} args - Arguments to create a MessageRecipient.
     * @example
     * // Create one MessageRecipient
     * const MessageRecipient = await prisma.messageRecipient.create({
     *   data: {
     *     // ... data to create a MessageRecipient
     *   }
     * })
     * 
     */
    create<T extends MessageRecipientCreateArgs>(args: SelectSubset<T, MessageRecipientCreateArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MessageRecipients.
     * @param {MessageRecipientCreateManyArgs} args - Arguments to create many MessageRecipients.
     * @example
     * // Create many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageRecipientCreateManyArgs>(args?: SelectSubset<T, MessageRecipientCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MessageRecipients and returns the data saved in the database.
     * @param {MessageRecipientCreateManyAndReturnArgs} args - Arguments to create many MessageRecipients.
     * @example
     * // Create many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MessageRecipients and only return the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageRecipientCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageRecipientCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MessageRecipient.
     * @param {MessageRecipientDeleteArgs} args - Arguments to delete one MessageRecipient.
     * @example
     * // Delete one MessageRecipient
     * const MessageRecipient = await prisma.messageRecipient.delete({
     *   where: {
     *     // ... filter to delete one MessageRecipient
     *   }
     * })
     * 
     */
    delete<T extends MessageRecipientDeleteArgs>(args: SelectSubset<T, MessageRecipientDeleteArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MessageRecipient.
     * @param {MessageRecipientUpdateArgs} args - Arguments to update one MessageRecipient.
     * @example
     * // Update one MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageRecipientUpdateArgs>(args: SelectSubset<T, MessageRecipientUpdateArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MessageRecipients.
     * @param {MessageRecipientDeleteManyArgs} args - Arguments to filter MessageRecipients to delete.
     * @example
     * // Delete a few MessageRecipients
     * const { count } = await prisma.messageRecipient.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageRecipientDeleteManyArgs>(args?: SelectSubset<T, MessageRecipientDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageRecipientUpdateManyArgs>(args: SelectSubset<T, MessageRecipientUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MessageRecipients and returns the data updated in the database.
     * @param {MessageRecipientUpdateManyAndReturnArgs} args - Arguments to update many MessageRecipients.
     * @example
     * // Update many MessageRecipients
     * const messageRecipient = await prisma.messageRecipient.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MessageRecipients and only return the `id`
     * const messageRecipientWithIdOnly = await prisma.messageRecipient.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageRecipientUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageRecipientUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MessageRecipient.
     * @param {MessageRecipientUpsertArgs} args - Arguments to update or create a MessageRecipient.
     * @example
     * // Update or create a MessageRecipient
     * const messageRecipient = await prisma.messageRecipient.upsert({
     *   create: {
     *     // ... data to create a MessageRecipient
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MessageRecipient we want to update
     *   }
     * })
     */
    upsert<T extends MessageRecipientUpsertArgs>(args: SelectSubset<T, MessageRecipientUpsertArgs<ExtArgs>>): Prisma__MessageRecipientClient<$Result.GetResult<Prisma.$MessageRecipientPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MessageRecipients.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientCountArgs} args - Arguments to filter MessageRecipients to count.
     * @example
     * // Count the number of MessageRecipients
     * const count = await prisma.messageRecipient.count({
     *   where: {
     *     // ... the filter for the MessageRecipients we want to count
     *   }
     * })
    **/
    count<T extends MessageRecipientCountArgs>(
      args?: Subset<T, MessageRecipientCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageRecipientCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MessageRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageRecipientAggregateArgs>(args: Subset<T, MessageRecipientAggregateArgs>): Prisma.PrismaPromise<GetMessageRecipientAggregateType<T>>

    /**
     * Group by MessageRecipient.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageRecipientGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageRecipientGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageRecipientGroupByArgs['orderBy'] }
        : { orderBy?: MessageRecipientGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageRecipientGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageRecipientGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MessageRecipient model
   */
  readonly fields: MessageRecipientFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MessageRecipient.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageRecipientClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    message<T extends MessageDefaultArgs<ExtArgs> = {}>(args?: Subset<T, MessageDefaultArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MessageRecipient model
   */
  interface MessageRecipientFieldRefs {
    readonly id: FieldRef<"MessageRecipient", 'String'>
    readonly messageId: FieldRef<"MessageRecipient", 'String'>
    readonly userId: FieldRef<"MessageRecipient", 'String'>
    readonly isRead: FieldRef<"MessageRecipient", 'Boolean'>
    readonly readAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly createdAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly updatedAt: FieldRef<"MessageRecipient", 'DateTime'>
    readonly isDeleted: FieldRef<"MessageRecipient", 'Boolean'>
    readonly deletedAt: FieldRef<"MessageRecipient", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MessageRecipient findUnique
   */
  export type MessageRecipientFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient findUniqueOrThrow
   */
  export type MessageRecipientFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient findFirst
   */
  export type MessageRecipientFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRecipients.
     */
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient findFirstOrThrow
   */
  export type MessageRecipientFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipient to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MessageRecipients.
     */
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient findMany
   */
  export type MessageRecipientFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter, which MessageRecipients to fetch.
     */
    where?: MessageRecipientWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MessageRecipients to fetch.
     */
    orderBy?: MessageRecipientOrderByWithRelationInput | MessageRecipientOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MessageRecipients.
     */
    cursor?: MessageRecipientWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` MessageRecipients from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MessageRecipients.
     */
    skip?: number
    distinct?: MessageRecipientScalarFieldEnum | MessageRecipientScalarFieldEnum[]
  }

  /**
   * MessageRecipient create
   */
  export type MessageRecipientCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The data needed to create a MessageRecipient.
     */
    data: XOR<MessageRecipientCreateInput, MessageRecipientUncheckedCreateInput>
  }

  /**
   * MessageRecipient createMany
   */
  export type MessageRecipientCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MessageRecipients.
     */
    data: MessageRecipientCreateManyInput | MessageRecipientCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MessageRecipient createManyAndReturn
   */
  export type MessageRecipientCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * The data used to create many MessageRecipients.
     */
    data: MessageRecipientCreateManyInput | MessageRecipientCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRecipient update
   */
  export type MessageRecipientUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The data needed to update a MessageRecipient.
     */
    data: XOR<MessageRecipientUpdateInput, MessageRecipientUncheckedUpdateInput>
    /**
     * Choose, which MessageRecipient to update.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient updateMany
   */
  export type MessageRecipientUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MessageRecipients.
     */
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyInput>
    /**
     * Filter which MessageRecipients to update
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to update.
     */
    limit?: number
  }

  /**
   * MessageRecipient updateManyAndReturn
   */
  export type MessageRecipientUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * The data used to update MessageRecipients.
     */
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyInput>
    /**
     * Filter which MessageRecipients to update
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MessageRecipient upsert
   */
  export type MessageRecipientUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * The filter to search for the MessageRecipient to update in case it exists.
     */
    where: MessageRecipientWhereUniqueInput
    /**
     * In case the MessageRecipient found by the `where` argument doesn't exist, create a new MessageRecipient with this data.
     */
    create: XOR<MessageRecipientCreateInput, MessageRecipientUncheckedCreateInput>
    /**
     * In case the MessageRecipient was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageRecipientUpdateInput, MessageRecipientUncheckedUpdateInput>
  }

  /**
   * MessageRecipient delete
   */
  export type MessageRecipientDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
    /**
     * Filter which MessageRecipient to delete.
     */
    where: MessageRecipientWhereUniqueInput
  }

  /**
   * MessageRecipient deleteMany
   */
  export type MessageRecipientDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MessageRecipients to delete
     */
    where?: MessageRecipientWhereInput
    /**
     * Limit how many MessageRecipients to delete.
     */
    limit?: number
  }

  /**
   * MessageRecipient without action
   */
  export type MessageRecipientDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MessageRecipient
     */
    select?: MessageRecipientSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MessageRecipient
     */
    omit?: MessageRecipientOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageRecipientInclude<ExtArgs> | null
  }


  /**
   * Model OperateLog
   */

  export type AggregateOperateLog = {
    _count: OperateLogCountAggregateOutputType | null
    _min: OperateLogMinAggregateOutputType | null
    _max: OperateLogMaxAggregateOutputType | null
  }

  export type OperateLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    operateType: $Enums.OperateType | null
    target: $Enums.OperateTarget | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperateLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    operateType: $Enums.OperateType | null
    target: $Enums.OperateTarget | null
    targetId: string | null
    targetName: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type OperateLogCountAggregateOutputType = {
    id: number
    userId: number
    operateType: number
    target: number
    targetId: number
    targetName: number
    detail: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type OperateLogMinAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperateLogMaxAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type OperateLogCountAggregateInputType = {
    id?: true
    userId?: true
    operateType?: true
    target?: true
    targetId?: true
    targetName?: true
    detail?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type OperateLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperateLog to aggregate.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned OperateLogs
    **/
    _count?: true | OperateLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OperateLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OperateLogMaxAggregateInputType
  }

  export type GetOperateLogAggregateType<T extends OperateLogAggregateArgs> = {
        [P in keyof T & keyof AggregateOperateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOperateLog[P]>
      : GetScalarType<T[P], AggregateOperateLog[P]>
  }




  export type OperateLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OperateLogWhereInput
    orderBy?: OperateLogOrderByWithAggregationInput | OperateLogOrderByWithAggregationInput[]
    by: OperateLogScalarFieldEnum[] | OperateLogScalarFieldEnum
    having?: OperateLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OperateLogCountAggregateInputType | true
    _min?: OperateLogMinAggregateInputType
    _max?: OperateLogMaxAggregateInputType
  }

  export type OperateLogGroupByOutputType = {
    id: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId: string | null
    targetName: string | null
    detail: JsonValue | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: OperateLogCountAggregateOutputType | null
    _min: OperateLogMinAggregateOutputType | null
    _max: OperateLogMaxAggregateOutputType | null
  }

  type GetOperateLogGroupByPayload<T extends OperateLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OperateLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OperateLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OperateLogGroupByOutputType[P]>
            : GetScalarType<T[P], OperateLogGroupByOutputType[P]>
        }
      >
    >


  export type OperateLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["operateLog"]>

  export type OperateLogSelectScalar = {
    id?: boolean
    userId?: boolean
    operateType?: boolean
    target?: boolean
    targetId?: boolean
    targetName?: boolean
    detail?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type OperateLogOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "operateType" | "target" | "targetId" | "targetName" | "detail" | "ipAddress" | "userAgent" | "createdAt", ExtArgs["result"]["operateLog"]>
  export type OperateLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type OperateLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }
  export type OperateLogIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserInfoDefaultArgs<ExtArgs>
  }

  export type $OperateLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "OperateLog"
    objects: {
      user: Prisma.$UserInfoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      operateType: $Enums.OperateType
      target: $Enums.OperateTarget
      targetId: string | null
      targetName: string | null
      detail: Prisma.JsonValue | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["operateLog"]>
    composites: {}
  }

  type OperateLogGetPayload<S extends boolean | null | undefined | OperateLogDefaultArgs> = $Result.GetResult<Prisma.$OperateLogPayload, S>

  type OperateLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<OperateLogFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: OperateLogCountAggregateInputType | true
    }

  export interface OperateLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['OperateLog'], meta: { name: 'OperateLog' } }
    /**
     * Find zero or one OperateLog that matches the filter.
     * @param {OperateLogFindUniqueArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends OperateLogFindUniqueArgs>(args: SelectSubset<T, OperateLogFindUniqueArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one OperateLog that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {OperateLogFindUniqueOrThrowArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends OperateLogFindUniqueOrThrowArgs>(args: SelectSubset<T, OperateLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperateLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindFirstArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends OperateLogFindFirstArgs>(args?: SelectSubset<T, OperateLogFindFirstArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first OperateLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindFirstOrThrowArgs} args - Arguments to find a OperateLog
     * @example
     * // Get one OperateLog
     * const operateLog = await prisma.operateLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends OperateLogFindFirstOrThrowArgs>(args?: SelectSubset<T, OperateLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more OperateLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all OperateLogs
     * const operateLogs = await prisma.operateLog.findMany()
     * 
     * // Get first 10 OperateLogs
     * const operateLogs = await prisma.operateLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends OperateLogFindManyArgs>(args?: SelectSubset<T, OperateLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a OperateLog.
     * @param {OperateLogCreateArgs} args - Arguments to create a OperateLog.
     * @example
     * // Create one OperateLog
     * const OperateLog = await prisma.operateLog.create({
     *   data: {
     *     // ... data to create a OperateLog
     *   }
     * })
     * 
     */
    create<T extends OperateLogCreateArgs>(args: SelectSubset<T, OperateLogCreateArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many OperateLogs.
     * @param {OperateLogCreateManyArgs} args - Arguments to create many OperateLogs.
     * @example
     * // Create many OperateLogs
     * const operateLog = await prisma.operateLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends OperateLogCreateManyArgs>(args?: SelectSubset<T, OperateLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many OperateLogs and returns the data saved in the database.
     * @param {OperateLogCreateManyAndReturnArgs} args - Arguments to create many OperateLogs.
     * @example
     * // Create many OperateLogs
     * const operateLog = await prisma.operateLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many OperateLogs and only return the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends OperateLogCreateManyAndReturnArgs>(args?: SelectSubset<T, OperateLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a OperateLog.
     * @param {OperateLogDeleteArgs} args - Arguments to delete one OperateLog.
     * @example
     * // Delete one OperateLog
     * const OperateLog = await prisma.operateLog.delete({
     *   where: {
     *     // ... filter to delete one OperateLog
     *   }
     * })
     * 
     */
    delete<T extends OperateLogDeleteArgs>(args: SelectSubset<T, OperateLogDeleteArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one OperateLog.
     * @param {OperateLogUpdateArgs} args - Arguments to update one OperateLog.
     * @example
     * // Update one OperateLog
     * const operateLog = await prisma.operateLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends OperateLogUpdateArgs>(args: SelectSubset<T, OperateLogUpdateArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more OperateLogs.
     * @param {OperateLogDeleteManyArgs} args - Arguments to filter OperateLogs to delete.
     * @example
     * // Delete a few OperateLogs
     * const { count } = await prisma.operateLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends OperateLogDeleteManyArgs>(args?: SelectSubset<T, OperateLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many OperateLogs
     * const operateLog = await prisma.operateLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends OperateLogUpdateManyArgs>(args: SelectSubset<T, OperateLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more OperateLogs and returns the data updated in the database.
     * @param {OperateLogUpdateManyAndReturnArgs} args - Arguments to update many OperateLogs.
     * @example
     * // Update many OperateLogs
     * const operateLog = await prisma.operateLog.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more OperateLogs and only return the `id`
     * const operateLogWithIdOnly = await prisma.operateLog.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends OperateLogUpdateManyAndReturnArgs>(args: SelectSubset<T, OperateLogUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one OperateLog.
     * @param {OperateLogUpsertArgs} args - Arguments to update or create a OperateLog.
     * @example
     * // Update or create a OperateLog
     * const operateLog = await prisma.operateLog.upsert({
     *   create: {
     *     // ... data to create a OperateLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the OperateLog we want to update
     *   }
     * })
     */
    upsert<T extends OperateLogUpsertArgs>(args: SelectSubset<T, OperateLogUpsertArgs<ExtArgs>>): Prisma__OperateLogClient<$Result.GetResult<Prisma.$OperateLogPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of OperateLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogCountArgs} args - Arguments to filter OperateLogs to count.
     * @example
     * // Count the number of OperateLogs
     * const count = await prisma.operateLog.count({
     *   where: {
     *     // ... the filter for the OperateLogs we want to count
     *   }
     * })
    **/
    count<T extends OperateLogCountArgs>(
      args?: Subset<T, OperateLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OperateLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a OperateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OperateLogAggregateArgs>(args: Subset<T, OperateLogAggregateArgs>): Prisma.PrismaPromise<GetOperateLogAggregateType<T>>

    /**
     * Group by OperateLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OperateLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OperateLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OperateLogGroupByArgs['orderBy'] }
        : { orderBy?: OperateLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OperateLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOperateLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the OperateLog model
   */
  readonly fields: OperateLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for OperateLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OperateLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserInfoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserInfoDefaultArgs<ExtArgs>>): Prisma__UserInfoClient<$Result.GetResult<Prisma.$UserInfoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the OperateLog model
   */
  interface OperateLogFieldRefs {
    readonly id: FieldRef<"OperateLog", 'String'>
    readonly userId: FieldRef<"OperateLog", 'String'>
    readonly operateType: FieldRef<"OperateLog", 'OperateType'>
    readonly target: FieldRef<"OperateLog", 'OperateTarget'>
    readonly targetId: FieldRef<"OperateLog", 'String'>
    readonly targetName: FieldRef<"OperateLog", 'String'>
    readonly detail: FieldRef<"OperateLog", 'Json'>
    readonly ipAddress: FieldRef<"OperateLog", 'String'>
    readonly userAgent: FieldRef<"OperateLog", 'String'>
    readonly createdAt: FieldRef<"OperateLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * OperateLog findUnique
   */
  export type OperateLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog findUniqueOrThrow
   */
  export type OperateLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog findFirst
   */
  export type OperateLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperateLogs.
     */
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog findFirstOrThrow
   */
  export type OperateLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLog to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of OperateLogs.
     */
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog findMany
   */
  export type OperateLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter, which OperateLogs to fetch.
     */
    where?: OperateLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of OperateLogs to fetch.
     */
    orderBy?: OperateLogOrderByWithRelationInput | OperateLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing OperateLogs.
     */
    cursor?: OperateLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` OperateLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` OperateLogs.
     */
    skip?: number
    distinct?: OperateLogScalarFieldEnum | OperateLogScalarFieldEnum[]
  }

  /**
   * OperateLog create
   */
  export type OperateLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The data needed to create a OperateLog.
     */
    data: XOR<OperateLogCreateInput, OperateLogUncheckedCreateInput>
  }

  /**
   * OperateLog createMany
   */
  export type OperateLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many OperateLogs.
     */
    data: OperateLogCreateManyInput | OperateLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * OperateLog createManyAndReturn
   */
  export type OperateLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * The data used to create many OperateLogs.
     */
    data: OperateLogCreateManyInput | OperateLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperateLog update
   */
  export type OperateLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The data needed to update a OperateLog.
     */
    data: XOR<OperateLogUpdateInput, OperateLogUncheckedUpdateInput>
    /**
     * Choose, which OperateLog to update.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog updateMany
   */
  export type OperateLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update OperateLogs.
     */
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyInput>
    /**
     * Filter which OperateLogs to update
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to update.
     */
    limit?: number
  }

  /**
   * OperateLog updateManyAndReturn
   */
  export type OperateLogUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * The data used to update OperateLogs.
     */
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyInput>
    /**
     * Filter which OperateLogs to update
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * OperateLog upsert
   */
  export type OperateLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * The filter to search for the OperateLog to update in case it exists.
     */
    where: OperateLogWhereUniqueInput
    /**
     * In case the OperateLog found by the `where` argument doesn't exist, create a new OperateLog with this data.
     */
    create: XOR<OperateLogCreateInput, OperateLogUncheckedCreateInput>
    /**
     * In case the OperateLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OperateLogUpdateInput, OperateLogUncheckedUpdateInput>
  }

  /**
   * OperateLog delete
   */
  export type OperateLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
    /**
     * Filter which OperateLog to delete.
     */
    where: OperateLogWhereUniqueInput
  }

  /**
   * OperateLog deleteMany
   */
  export type OperateLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which OperateLogs to delete
     */
    where?: OperateLogWhereInput
    /**
     * Limit how many OperateLogs to delete.
     */
    limit?: number
  }

  /**
   * OperateLog without action
   */
  export type OperateLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the OperateLog
     */
    select?: OperateLogSelect<ExtArgs> | null
    /**
     * Omit specific fields from the OperateLog
     */
    omit?: OperateLogOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OperateLogInclude<ExtArgs> | null
  }


  /**
   * Model ChannelDefinition
   */

  export type AggregateChannelDefinition = {
    _count: ChannelDefinitionCountAggregateOutputType | null
    _avg: ChannelDefinitionAvgAggregateOutputType | null
    _sum: ChannelDefinitionSumAggregateOutputType | null
    _min: ChannelDefinitionMinAggregateOutputType | null
    _max: ChannelDefinitionMaxAggregateOutputType | null
  }

  export type ChannelDefinitionAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelDefinitionSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelDefinitionMinAggregateOutputType = {
    id: string | null
    label: string | null
    icon: string | null
    popular: boolean | null
    tokenHint: string | null
    tokenPlaceholder: string | null
    helpUrl: string | null
    helpText: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelDefinitionMaxAggregateOutputType = {
    id: string | null
    label: string | null
    icon: string | null
    popular: boolean | null
    tokenHint: string | null
    tokenPlaceholder: string | null
    helpUrl: string | null
    helpText: string | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelDefinitionCountAggregateOutputType = {
    id: number
    label: number
    icon: number
    popular: number
    tokenHint: number
    tokenPlaceholder: number
    helpUrl: number
    helpText: number
    sortOrder: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChannelDefinitionAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelDefinitionSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelDefinitionMinAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelDefinitionMaxAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelDefinitionCountAggregateInputType = {
    id?: true
    label?: true
    icon?: true
    popular?: true
    tokenHint?: true
    tokenPlaceholder?: true
    helpUrl?: true
    helpText?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChannelDefinitionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelDefinition to aggregate.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelDefinitions
    **/
    _count?: true | ChannelDefinitionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelDefinitionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelDefinitionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelDefinitionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelDefinitionMaxAggregateInputType
  }

  export type GetChannelDefinitionAggregateType<T extends ChannelDefinitionAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelDefinition]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelDefinition[P]>
      : GetScalarType<T[P], AggregateChannelDefinition[P]>
  }




  export type ChannelDefinitionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelDefinitionWhereInput
    orderBy?: ChannelDefinitionOrderByWithAggregationInput | ChannelDefinitionOrderByWithAggregationInput[]
    by: ChannelDefinitionScalarFieldEnum[] | ChannelDefinitionScalarFieldEnum
    having?: ChannelDefinitionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelDefinitionCountAggregateInputType | true
    _avg?: ChannelDefinitionAvgAggregateInputType
    _sum?: ChannelDefinitionSumAggregateInputType
    _min?: ChannelDefinitionMinAggregateInputType
    _max?: ChannelDefinitionMaxAggregateInputType
  }

  export type ChannelDefinitionGroupByOutputType = {
    id: string
    label: string
    icon: string
    popular: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl: string | null
    helpText: string | null
    sortOrder: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ChannelDefinitionCountAggregateOutputType | null
    _avg: ChannelDefinitionAvgAggregateOutputType | null
    _sum: ChannelDefinitionSumAggregateOutputType | null
    _min: ChannelDefinitionMinAggregateOutputType | null
    _max: ChannelDefinitionMaxAggregateOutputType | null
  }

  type GetChannelDefinitionGroupByPayload<T extends ChannelDefinitionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelDefinitionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelDefinitionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelDefinitionGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelDefinitionGroupByOutputType[P]>
        }
      >
    >


  export type ChannelDefinitionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    credentialFields?: boolean | ChannelDefinition$credentialFieldsArgs<ExtArgs>
    _count?: boolean | ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }, ExtArgs["result"]["channelDefinition"]>

  export type ChannelDefinitionSelectScalar = {
    id?: boolean
    label?: boolean
    icon?: boolean
    popular?: boolean
    tokenHint?: boolean
    tokenPlaceholder?: boolean
    helpUrl?: boolean
    helpText?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChannelDefinitionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "label" | "icon" | "popular" | "tokenHint" | "tokenPlaceholder" | "helpUrl" | "helpText" | "sortOrder" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["channelDefinition"]>
  export type ChannelDefinitionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    credentialFields?: boolean | ChannelDefinition$credentialFieldsArgs<ExtArgs>
    _count?: boolean | ChannelDefinitionCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ChannelDefinitionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type ChannelDefinitionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ChannelDefinitionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelDefinition"
    objects: {
      credentialFields: Prisma.$ChannelCredentialFieldPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      label: string
      icon: string
      popular: boolean
      tokenHint: string
      tokenPlaceholder: string
      helpUrl: string | null
      helpText: string | null
      sortOrder: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["channelDefinition"]>
    composites: {}
  }

  type ChannelDefinitionGetPayload<S extends boolean | null | undefined | ChannelDefinitionDefaultArgs> = $Result.GetResult<Prisma.$ChannelDefinitionPayload, S>

  type ChannelDefinitionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelDefinitionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelDefinitionCountAggregateInputType | true
    }

  export interface ChannelDefinitionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelDefinition'], meta: { name: 'ChannelDefinition' } }
    /**
     * Find zero or one ChannelDefinition that matches the filter.
     * @param {ChannelDefinitionFindUniqueArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelDefinitionFindUniqueArgs>(args: SelectSubset<T, ChannelDefinitionFindUniqueArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelDefinition that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelDefinitionFindUniqueOrThrowArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelDefinitionFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelDefinition that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindFirstArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelDefinitionFindFirstArgs>(args?: SelectSubset<T, ChannelDefinitionFindFirstArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelDefinition that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindFirstOrThrowArgs} args - Arguments to find a ChannelDefinition
     * @example
     * // Get one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelDefinitionFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelDefinitionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelDefinitions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelDefinitions
     * const channelDefinitions = await prisma.channelDefinition.findMany()
     * 
     * // Get first 10 ChannelDefinitions
     * const channelDefinitions = await prisma.channelDefinition.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelDefinitionFindManyArgs>(args?: SelectSubset<T, ChannelDefinitionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelDefinition.
     * @param {ChannelDefinitionCreateArgs} args - Arguments to create a ChannelDefinition.
     * @example
     * // Create one ChannelDefinition
     * const ChannelDefinition = await prisma.channelDefinition.create({
     *   data: {
     *     // ... data to create a ChannelDefinition
     *   }
     * })
     * 
     */
    create<T extends ChannelDefinitionCreateArgs>(args: SelectSubset<T, ChannelDefinitionCreateArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelDefinitions.
     * @param {ChannelDefinitionCreateManyArgs} args - Arguments to create many ChannelDefinitions.
     * @example
     * // Create many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelDefinitionCreateManyArgs>(args?: SelectSubset<T, ChannelDefinitionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelDefinitions and returns the data saved in the database.
     * @param {ChannelDefinitionCreateManyAndReturnArgs} args - Arguments to create many ChannelDefinitions.
     * @example
     * // Create many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelDefinitions and only return the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelDefinitionCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelDefinitionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChannelDefinition.
     * @param {ChannelDefinitionDeleteArgs} args - Arguments to delete one ChannelDefinition.
     * @example
     * // Delete one ChannelDefinition
     * const ChannelDefinition = await prisma.channelDefinition.delete({
     *   where: {
     *     // ... filter to delete one ChannelDefinition
     *   }
     * })
     * 
     */
    delete<T extends ChannelDefinitionDeleteArgs>(args: SelectSubset<T, ChannelDefinitionDeleteArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelDefinition.
     * @param {ChannelDefinitionUpdateArgs} args - Arguments to update one ChannelDefinition.
     * @example
     * // Update one ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelDefinitionUpdateArgs>(args: SelectSubset<T, ChannelDefinitionUpdateArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelDefinitions.
     * @param {ChannelDefinitionDeleteManyArgs} args - Arguments to filter ChannelDefinitions to delete.
     * @example
     * // Delete a few ChannelDefinitions
     * const { count } = await prisma.channelDefinition.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelDefinitionDeleteManyArgs>(args?: SelectSubset<T, ChannelDefinitionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelDefinitionUpdateManyArgs>(args: SelectSubset<T, ChannelDefinitionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelDefinitions and returns the data updated in the database.
     * @param {ChannelDefinitionUpdateManyAndReturnArgs} args - Arguments to update many ChannelDefinitions.
     * @example
     * // Update many ChannelDefinitions
     * const channelDefinition = await prisma.channelDefinition.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChannelDefinitions and only return the `id`
     * const channelDefinitionWithIdOnly = await prisma.channelDefinition.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelDefinitionUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChannelDefinition.
     * @param {ChannelDefinitionUpsertArgs} args - Arguments to update or create a ChannelDefinition.
     * @example
     * // Update or create a ChannelDefinition
     * const channelDefinition = await prisma.channelDefinition.upsert({
     *   create: {
     *     // ... data to create a ChannelDefinition
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelDefinition we want to update
     *   }
     * })
     */
    upsert<T extends ChannelDefinitionUpsertArgs>(args: SelectSubset<T, ChannelDefinitionUpsertArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChannelDefinitions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionCountArgs} args - Arguments to filter ChannelDefinitions to count.
     * @example
     * // Count the number of ChannelDefinitions
     * const count = await prisma.channelDefinition.count({
     *   where: {
     *     // ... the filter for the ChannelDefinitions we want to count
     *   }
     * })
    **/
    count<T extends ChannelDefinitionCountArgs>(
      args?: Subset<T, ChannelDefinitionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelDefinitionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelDefinitionAggregateArgs>(args: Subset<T, ChannelDefinitionAggregateArgs>): Prisma.PrismaPromise<GetChannelDefinitionAggregateType<T>>

    /**
     * Group by ChannelDefinition.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelDefinitionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelDefinitionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelDefinitionGroupByArgs['orderBy'] }
        : { orderBy?: ChannelDefinitionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelDefinitionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelDefinitionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelDefinition model
   */
  readonly fields: ChannelDefinitionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelDefinition.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelDefinitionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    credentialFields<T extends ChannelDefinition$credentialFieldsArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefinition$credentialFieldsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelDefinition model
   */
  interface ChannelDefinitionFieldRefs {
    readonly id: FieldRef<"ChannelDefinition", 'String'>
    readonly label: FieldRef<"ChannelDefinition", 'String'>
    readonly icon: FieldRef<"ChannelDefinition", 'String'>
    readonly popular: FieldRef<"ChannelDefinition", 'Boolean'>
    readonly tokenHint: FieldRef<"ChannelDefinition", 'String'>
    readonly tokenPlaceholder: FieldRef<"ChannelDefinition", 'String'>
    readonly helpUrl: FieldRef<"ChannelDefinition", 'String'>
    readonly helpText: FieldRef<"ChannelDefinition", 'String'>
    readonly sortOrder: FieldRef<"ChannelDefinition", 'Int'>
    readonly isDeleted: FieldRef<"ChannelDefinition", 'Boolean'>
    readonly createdAt: FieldRef<"ChannelDefinition", 'DateTime'>
    readonly updatedAt: FieldRef<"ChannelDefinition", 'DateTime'>
    readonly deletedAt: FieldRef<"ChannelDefinition", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelDefinition findUnique
   */
  export type ChannelDefinitionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition findUniqueOrThrow
   */
  export type ChannelDefinitionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition findFirst
   */
  export type ChannelDefinitionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelDefinitions.
     */
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition findFirstOrThrow
   */
  export type ChannelDefinitionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinition to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelDefinitions.
     */
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition findMany
   */
  export type ChannelDefinitionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter, which ChannelDefinitions to fetch.
     */
    where?: ChannelDefinitionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelDefinitions to fetch.
     */
    orderBy?: ChannelDefinitionOrderByWithRelationInput | ChannelDefinitionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelDefinitions.
     */
    cursor?: ChannelDefinitionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelDefinitions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelDefinitions.
     */
    skip?: number
    distinct?: ChannelDefinitionScalarFieldEnum | ChannelDefinitionScalarFieldEnum[]
  }

  /**
   * ChannelDefinition create
   */
  export type ChannelDefinitionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelDefinition.
     */
    data: XOR<ChannelDefinitionCreateInput, ChannelDefinitionUncheckedCreateInput>
  }

  /**
   * ChannelDefinition createMany
   */
  export type ChannelDefinitionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelDefinitions.
     */
    data: ChannelDefinitionCreateManyInput | ChannelDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelDefinition createManyAndReturn
   */
  export type ChannelDefinitionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * The data used to create many ChannelDefinitions.
     */
    data: ChannelDefinitionCreateManyInput | ChannelDefinitionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelDefinition update
   */
  export type ChannelDefinitionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelDefinition.
     */
    data: XOR<ChannelDefinitionUpdateInput, ChannelDefinitionUncheckedUpdateInput>
    /**
     * Choose, which ChannelDefinition to update.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition updateMany
   */
  export type ChannelDefinitionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelDefinitions.
     */
    data: XOR<ChannelDefinitionUpdateManyMutationInput, ChannelDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ChannelDefinitions to update
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to update.
     */
    limit?: number
  }

  /**
   * ChannelDefinition updateManyAndReturn
   */
  export type ChannelDefinitionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * The data used to update ChannelDefinitions.
     */
    data: XOR<ChannelDefinitionUpdateManyMutationInput, ChannelDefinitionUncheckedUpdateManyInput>
    /**
     * Filter which ChannelDefinitions to update
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to update.
     */
    limit?: number
  }

  /**
   * ChannelDefinition upsert
   */
  export type ChannelDefinitionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelDefinition to update in case it exists.
     */
    where: ChannelDefinitionWhereUniqueInput
    /**
     * In case the ChannelDefinition found by the `where` argument doesn't exist, create a new ChannelDefinition with this data.
     */
    create: XOR<ChannelDefinitionCreateInput, ChannelDefinitionUncheckedCreateInput>
    /**
     * In case the ChannelDefinition was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelDefinitionUpdateInput, ChannelDefinitionUncheckedUpdateInput>
  }

  /**
   * ChannelDefinition delete
   */
  export type ChannelDefinitionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
    /**
     * Filter which ChannelDefinition to delete.
     */
    where: ChannelDefinitionWhereUniqueInput
  }

  /**
   * ChannelDefinition deleteMany
   */
  export type ChannelDefinitionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelDefinitions to delete
     */
    where?: ChannelDefinitionWhereInput
    /**
     * Limit how many ChannelDefinitions to delete.
     */
    limit?: number
  }

  /**
   * ChannelDefinition.credentialFields
   */
  export type ChannelDefinition$credentialFieldsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    where?: ChannelCredentialFieldWhereInput
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    cursor?: ChannelCredentialFieldWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelDefinition without action
   */
  export type ChannelDefinitionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelDefinition
     */
    select?: ChannelDefinitionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelDefinition
     */
    omit?: ChannelDefinitionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelDefinitionInclude<ExtArgs> | null
  }


  /**
   * Model ChannelCredentialField
   */

  export type AggregateChannelCredentialField = {
    _count: ChannelCredentialFieldCountAggregateOutputType | null
    _avg: ChannelCredentialFieldAvgAggregateOutputType | null
    _sum: ChannelCredentialFieldSumAggregateOutputType | null
    _min: ChannelCredentialFieldMinAggregateOutputType | null
    _max: ChannelCredentialFieldMaxAggregateOutputType | null
  }

  export type ChannelCredentialFieldAvgAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelCredentialFieldSumAggregateOutputType = {
    sortOrder: number | null
  }

  export type ChannelCredentialFieldMinAggregateOutputType = {
    id: string | null
    channelId: string | null
    key: string | null
    label: string | null
    placeholder: string | null
    fieldType: string | null
    required: boolean | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelCredentialFieldMaxAggregateOutputType = {
    id: string | null
    channelId: string | null
    key: string | null
    label: string | null
    placeholder: string | null
    fieldType: string | null
    required: boolean | null
    sortOrder: number | null
    isDeleted: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
    deletedAt: Date | null
  }

  export type ChannelCredentialFieldCountAggregateOutputType = {
    id: number
    channelId: number
    key: number
    label: number
    placeholder: number
    fieldType: number
    required: number
    sortOrder: number
    isDeleted: number
    createdAt: number
    updatedAt: number
    deletedAt: number
    _all: number
  }


  export type ChannelCredentialFieldAvgAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelCredentialFieldSumAggregateInputType = {
    sortOrder?: true
  }

  export type ChannelCredentialFieldMinAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelCredentialFieldMaxAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
  }

  export type ChannelCredentialFieldCountAggregateInputType = {
    id?: true
    channelId?: true
    key?: true
    label?: true
    placeholder?: true
    fieldType?: true
    required?: true
    sortOrder?: true
    isDeleted?: true
    createdAt?: true
    updatedAt?: true
    deletedAt?: true
    _all?: true
  }

  export type ChannelCredentialFieldAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCredentialField to aggregate.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChannelCredentialFields
    **/
    _count?: true | ChannelCredentialFieldCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChannelCredentialFieldAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChannelCredentialFieldSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChannelCredentialFieldMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChannelCredentialFieldMaxAggregateInputType
  }

  export type GetChannelCredentialFieldAggregateType<T extends ChannelCredentialFieldAggregateArgs> = {
        [P in keyof T & keyof AggregateChannelCredentialField]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChannelCredentialField[P]>
      : GetScalarType<T[P], AggregateChannelCredentialField[P]>
  }




  export type ChannelCredentialFieldGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChannelCredentialFieldWhereInput
    orderBy?: ChannelCredentialFieldOrderByWithAggregationInput | ChannelCredentialFieldOrderByWithAggregationInput[]
    by: ChannelCredentialFieldScalarFieldEnum[] | ChannelCredentialFieldScalarFieldEnum
    having?: ChannelCredentialFieldScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChannelCredentialFieldCountAggregateInputType | true
    _avg?: ChannelCredentialFieldAvgAggregateInputType
    _sum?: ChannelCredentialFieldSumAggregateInputType
    _min?: ChannelCredentialFieldMinAggregateInputType
    _max?: ChannelCredentialFieldMaxAggregateInputType
  }

  export type ChannelCredentialFieldGroupByOutputType = {
    id: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType: string
    required: boolean
    sortOrder: number
    isDeleted: boolean
    createdAt: Date
    updatedAt: Date
    deletedAt: Date | null
    _count: ChannelCredentialFieldCountAggregateOutputType | null
    _avg: ChannelCredentialFieldAvgAggregateOutputType | null
    _sum: ChannelCredentialFieldSumAggregateOutputType | null
    _min: ChannelCredentialFieldMinAggregateOutputType | null
    _max: ChannelCredentialFieldMaxAggregateOutputType | null
  }

  type GetChannelCredentialFieldGroupByPayload<T extends ChannelCredentialFieldGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChannelCredentialFieldGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChannelCredentialFieldGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChannelCredentialFieldGroupByOutputType[P]>
            : GetScalarType<T[P], ChannelCredentialFieldGroupByOutputType[P]>
        }
      >
    >


  export type ChannelCredentialFieldSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["channelCredentialField"]>

  export type ChannelCredentialFieldSelectScalar = {
    id?: boolean
    channelId?: boolean
    key?: boolean
    label?: boolean
    placeholder?: boolean
    fieldType?: boolean
    required?: boolean
    sortOrder?: boolean
    isDeleted?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    deletedAt?: boolean
  }

  export type ChannelCredentialFieldOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "channelId" | "key" | "label" | "placeholder" | "fieldType" | "required" | "sortOrder" | "isDeleted" | "createdAt" | "updatedAt" | "deletedAt", ExtArgs["result"]["channelCredentialField"]>
  export type ChannelCredentialFieldInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }
  export type ChannelCredentialFieldIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }
  export type ChannelCredentialFieldIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    channel?: boolean | ChannelDefinitionDefaultArgs<ExtArgs>
  }

  export type $ChannelCredentialFieldPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChannelCredentialField"
    objects: {
      channel: Prisma.$ChannelDefinitionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      channelId: string
      key: string
      label: string
      placeholder: string
      fieldType: string
      required: boolean
      sortOrder: number
      isDeleted: boolean
      createdAt: Date
      updatedAt: Date
      deletedAt: Date | null
    }, ExtArgs["result"]["channelCredentialField"]>
    composites: {}
  }

  type ChannelCredentialFieldGetPayload<S extends boolean | null | undefined | ChannelCredentialFieldDefaultArgs> = $Result.GetResult<Prisma.$ChannelCredentialFieldPayload, S>

  type ChannelCredentialFieldCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ChannelCredentialFieldFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ChannelCredentialFieldCountAggregateInputType | true
    }

  export interface ChannelCredentialFieldDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChannelCredentialField'], meta: { name: 'ChannelCredentialField' } }
    /**
     * Find zero or one ChannelCredentialField that matches the filter.
     * @param {ChannelCredentialFieldFindUniqueArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChannelCredentialFieldFindUniqueArgs>(args: SelectSubset<T, ChannelCredentialFieldFindUniqueArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ChannelCredentialField that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ChannelCredentialFieldFindUniqueOrThrowArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChannelCredentialFieldFindUniqueOrThrowArgs>(args: SelectSubset<T, ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelCredentialField that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindFirstArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChannelCredentialFieldFindFirstArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindFirstArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ChannelCredentialField that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindFirstOrThrowArgs} args - Arguments to find a ChannelCredentialField
     * @example
     * // Get one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChannelCredentialFieldFindFirstOrThrowArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ChannelCredentialFields that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChannelCredentialFields
     * const channelCredentialFields = await prisma.channelCredentialField.findMany()
     * 
     * // Get first 10 ChannelCredentialFields
     * const channelCredentialFields = await prisma.channelCredentialField.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChannelCredentialFieldFindManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ChannelCredentialField.
     * @param {ChannelCredentialFieldCreateArgs} args - Arguments to create a ChannelCredentialField.
     * @example
     * // Create one ChannelCredentialField
     * const ChannelCredentialField = await prisma.channelCredentialField.create({
     *   data: {
     *     // ... data to create a ChannelCredentialField
     *   }
     * })
     * 
     */
    create<T extends ChannelCredentialFieldCreateArgs>(args: SelectSubset<T, ChannelCredentialFieldCreateArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ChannelCredentialFields.
     * @param {ChannelCredentialFieldCreateManyArgs} args - Arguments to create many ChannelCredentialFields.
     * @example
     * // Create many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChannelCredentialFieldCreateManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ChannelCredentialFields and returns the data saved in the database.
     * @param {ChannelCredentialFieldCreateManyAndReturnArgs} args - Arguments to create many ChannelCredentialFields.
     * @example
     * // Create many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ChannelCredentialFields and only return the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ChannelCredentialFieldCreateManyAndReturnArgs>(args?: SelectSubset<T, ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ChannelCredentialField.
     * @param {ChannelCredentialFieldDeleteArgs} args - Arguments to delete one ChannelCredentialField.
     * @example
     * // Delete one ChannelCredentialField
     * const ChannelCredentialField = await prisma.channelCredentialField.delete({
     *   where: {
     *     // ... filter to delete one ChannelCredentialField
     *   }
     * })
     * 
     */
    delete<T extends ChannelCredentialFieldDeleteArgs>(args: SelectSubset<T, ChannelCredentialFieldDeleteArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ChannelCredentialField.
     * @param {ChannelCredentialFieldUpdateArgs} args - Arguments to update one ChannelCredentialField.
     * @example
     * // Update one ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChannelCredentialFieldUpdateArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ChannelCredentialFields.
     * @param {ChannelCredentialFieldDeleteManyArgs} args - Arguments to filter ChannelCredentialFields to delete.
     * @example
     * // Delete a few ChannelCredentialFields
     * const { count } = await prisma.channelCredentialField.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChannelCredentialFieldDeleteManyArgs>(args?: SelectSubset<T, ChannelCredentialFieldDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCredentialFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChannelCredentialFieldUpdateManyArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChannelCredentialFields and returns the data updated in the database.
     * @param {ChannelCredentialFieldUpdateManyAndReturnArgs} args - Arguments to update many ChannelCredentialFields.
     * @example
     * // Update many ChannelCredentialFields
     * const channelCredentialField = await prisma.channelCredentialField.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ChannelCredentialFields and only return the `id`
     * const channelCredentialFieldWithIdOnly = await prisma.channelCredentialField.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ChannelCredentialFieldUpdateManyAndReturnArgs>(args: SelectSubset<T, ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ChannelCredentialField.
     * @param {ChannelCredentialFieldUpsertArgs} args - Arguments to update or create a ChannelCredentialField.
     * @example
     * // Update or create a ChannelCredentialField
     * const channelCredentialField = await prisma.channelCredentialField.upsert({
     *   create: {
     *     // ... data to create a ChannelCredentialField
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChannelCredentialField we want to update
     *   }
     * })
     */
    upsert<T extends ChannelCredentialFieldUpsertArgs>(args: SelectSubset<T, ChannelCredentialFieldUpsertArgs<ExtArgs>>): Prisma__ChannelCredentialFieldClient<$Result.GetResult<Prisma.$ChannelCredentialFieldPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ChannelCredentialFields.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldCountArgs} args - Arguments to filter ChannelCredentialFields to count.
     * @example
     * // Count the number of ChannelCredentialFields
     * const count = await prisma.channelCredentialField.count({
     *   where: {
     *     // ... the filter for the ChannelCredentialFields we want to count
     *   }
     * })
    **/
    count<T extends ChannelCredentialFieldCountArgs>(
      args?: Subset<T, ChannelCredentialFieldCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChannelCredentialFieldCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChannelCredentialField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChannelCredentialFieldAggregateArgs>(args: Subset<T, ChannelCredentialFieldAggregateArgs>): Prisma.PrismaPromise<GetChannelCredentialFieldAggregateType<T>>

    /**
     * Group by ChannelCredentialField.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChannelCredentialFieldGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChannelCredentialFieldGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChannelCredentialFieldGroupByArgs['orderBy'] }
        : { orderBy?: ChannelCredentialFieldGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChannelCredentialFieldGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChannelCredentialFieldGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChannelCredentialField model
   */
  readonly fields: ChannelCredentialFieldFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChannelCredentialField.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChannelCredentialFieldClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    channel<T extends ChannelDefinitionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChannelDefinitionDefaultArgs<ExtArgs>>): Prisma__ChannelDefinitionClient<$Result.GetResult<Prisma.$ChannelDefinitionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChannelCredentialField model
   */
  interface ChannelCredentialFieldFieldRefs {
    readonly id: FieldRef<"ChannelCredentialField", 'String'>
    readonly channelId: FieldRef<"ChannelCredentialField", 'String'>
    readonly key: FieldRef<"ChannelCredentialField", 'String'>
    readonly label: FieldRef<"ChannelCredentialField", 'String'>
    readonly placeholder: FieldRef<"ChannelCredentialField", 'String'>
    readonly fieldType: FieldRef<"ChannelCredentialField", 'String'>
    readonly required: FieldRef<"ChannelCredentialField", 'Boolean'>
    readonly sortOrder: FieldRef<"ChannelCredentialField", 'Int'>
    readonly isDeleted: FieldRef<"ChannelCredentialField", 'Boolean'>
    readonly createdAt: FieldRef<"ChannelCredentialField", 'DateTime'>
    readonly updatedAt: FieldRef<"ChannelCredentialField", 'DateTime'>
    readonly deletedAt: FieldRef<"ChannelCredentialField", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChannelCredentialField findUnique
   */
  export type ChannelCredentialFieldFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField findUniqueOrThrow
   */
  export type ChannelCredentialFieldFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField findFirst
   */
  export type ChannelCredentialFieldFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCredentialFields.
     */
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField findFirstOrThrow
   */
  export type ChannelCredentialFieldFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialField to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChannelCredentialFields.
     */
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField findMany
   */
  export type ChannelCredentialFieldFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter, which ChannelCredentialFields to fetch.
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChannelCredentialFields to fetch.
     */
    orderBy?: ChannelCredentialFieldOrderByWithRelationInput | ChannelCredentialFieldOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChannelCredentialFields.
     */
    cursor?: ChannelCredentialFieldWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `¬±n` ChannelCredentialFields from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChannelCredentialFields.
     */
    skip?: number
    distinct?: ChannelCredentialFieldScalarFieldEnum | ChannelCredentialFieldScalarFieldEnum[]
  }

  /**
   * ChannelCredentialField create
   */
  export type ChannelCredentialFieldCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The data needed to create a ChannelCredentialField.
     */
    data: XOR<ChannelCredentialFieldCreateInput, ChannelCredentialFieldUncheckedCreateInput>
  }

  /**
   * ChannelCredentialField createMany
   */
  export type ChannelCredentialFieldCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChannelCredentialFields.
     */
    data: ChannelCredentialFieldCreateManyInput | ChannelCredentialFieldCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChannelCredentialField createManyAndReturn
   */
  export type ChannelCredentialFieldCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * The data used to create many ChannelCredentialFields.
     */
    data: ChannelCredentialFieldCreateManyInput | ChannelCredentialFieldCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelCredentialField update
   */
  export type ChannelCredentialFieldUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The data needed to update a ChannelCredentialField.
     */
    data: XOR<ChannelCredentialFieldUpdateInput, ChannelCredentialFieldUncheckedUpdateInput>
    /**
     * Choose, which ChannelCredentialField to update.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField updateMany
   */
  export type ChannelCredentialFieldUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChannelCredentialFields.
     */
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCredentialFields to update
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to update.
     */
    limit?: number
  }

  /**
   * ChannelCredentialField updateManyAndReturn
   */
  export type ChannelCredentialFieldUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * The data used to update ChannelCredentialFields.
     */
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyInput>
    /**
     * Filter which ChannelCredentialFields to update
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ChannelCredentialField upsert
   */
  export type ChannelCredentialFieldUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * The filter to search for the ChannelCredentialField to update in case it exists.
     */
    where: ChannelCredentialFieldWhereUniqueInput
    /**
     * In case the ChannelCredentialField found by the `where` argument doesn't exist, create a new ChannelCredentialField with this data.
     */
    create: XOR<ChannelCredentialFieldCreateInput, ChannelCredentialFieldUncheckedCreateInput>
    /**
     * In case the ChannelCredentialField was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChannelCredentialFieldUpdateInput, ChannelCredentialFieldUncheckedUpdateInput>
  }

  /**
   * ChannelCredentialField delete
   */
  export type ChannelCredentialFieldDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
    /**
     * Filter which ChannelCredentialField to delete.
     */
    where: ChannelCredentialFieldWhereUniqueInput
  }

  /**
   * ChannelCredentialField deleteMany
   */
  export type ChannelCredentialFieldDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChannelCredentialFields to delete
     */
    where?: ChannelCredentialFieldWhereInput
    /**
     * Limit how many ChannelCredentialFields to delete.
     */
    limit?: number
  }

  /**
   * ChannelCredentialField without action
   */
  export type ChannelCredentialFieldDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChannelCredentialField
     */
    select?: ChannelCredentialFieldSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ChannelCredentialField
     */
    omit?: ChannelCredentialFieldOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChannelCredentialFieldInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserInfoScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    code: 'code',
    avatarFileId: 'avatarFileId',
    sex: 'sex',
    locale: 'locale',
    isAnonymity: 'isAnonymity',
    isAdmin: 'isAdmin',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt',
    deviceId: 'deviceId',
    wechatOpenid: 'wechatOpenid',
    wechatUnionId: 'wechatUnionId',
    googleSub: 'googleSub',
    discordId: 'discordId',
    mobile: 'mobile',
    email: 'email'
  };

  export type UserInfoScalarFieldEnum = (typeof UserInfoScalarFieldEnum)[keyof typeof UserInfoScalarFieldEnum]


  export const PersonaTemplateScalarFieldEnum: {
    id: 'id',
    name: 'name',
    emoji: 'emoji',
    avatarFileId: 'avatarFileId',
    tagline: 'tagline',
    soulMarkdown: 'soulMarkdown',
    soulPreview: 'soulPreview',
    isSystem: 'isSystem',
    createdById: 'createdById',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type PersonaTemplateScalarFieldEnum = (typeof PersonaTemplateScalarFieldEnum)[keyof typeof PersonaTemplateScalarFieldEnum]


  export const WechatAuthScalarFieldEnum: {
    openid: 'openid',
    sessionKey: 'sessionKey',
    refreshToken: 'refreshToken',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type WechatAuthScalarFieldEnum = (typeof WechatAuthScalarFieldEnum)[keyof typeof WechatAuthScalarFieldEnum]


  export const GoogleAuthScalarFieldEnum: {
    sub: 'sub',
    email: 'email',
    verifiedEmail: 'verifiedEmail',
    atHash: 'atHash',
    name: 'name',
    picture: 'picture',
    givenName: 'givenName',
    familyName: 'familyName',
    exp: 'exp',
    iat: 'iat',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type GoogleAuthScalarFieldEnum = (typeof GoogleAuthScalarFieldEnum)[keyof typeof GoogleAuthScalarFieldEnum]


  export const DiscordAuthScalarFieldEnum: {
    discordId: 'discordId',
    email: 'email',
    verifiedEmail: 'verifiedEmail',
    name: 'name',
    accessToken: 'accessToken',
    refreshToken: 'refreshToken',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type DiscordAuthScalarFieldEnum = (typeof DiscordAuthScalarFieldEnum)[keyof typeof DiscordAuthScalarFieldEnum]


  export const MobileAuthScalarFieldEnum: {
    mobile: 'mobile',
    password: 'password',
    verified: 'verified',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type MobileAuthScalarFieldEnum = (typeof MobileAuthScalarFieldEnum)[keyof typeof MobileAuthScalarFieldEnum]


  export const EmailAuthScalarFieldEnum: {
    email: 'email',
    password: 'password',
    verified: 'verified',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type EmailAuthScalarFieldEnum = (typeof EmailAuthScalarFieldEnum)[keyof typeof EmailAuthScalarFieldEnum]


  export const RiskDetectionRecordScalarFieldEnum: {
    id: 'id',
    action: 'action',
    data: 'data',
    status: 'status',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type RiskDetectionRecordScalarFieldEnum = (typeof RiskDetectionRecordScalarFieldEnum)[keyof typeof RiskDetectionRecordScalarFieldEnum]


  export const SystemTaskQueueScalarFieldEnum: {
    id: 'id',
    taskType: 'taskType',
    status: 'status',
    recipient: 'recipient',
    templateCode: 'templateCode',
    templateData: 'templateData',
    content: 'content',
    subject: 'subject',
    retryCount: 'retryCount',
    processedAt: 'processedAt',
    errorMessage: 'errorMessage',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SystemTaskQueueScalarFieldEnum = (typeof SystemTaskQueueScalarFieldEnum)[keyof typeof SystemTaskQueueScalarFieldEnum]


  export const FileSourceScalarFieldEnum: {
    id: 'id',
    isUploaded: 'isUploaded',
    bucket: 'bucket',
    key: 'key',
    hash: 'hash',
    thumbImg: 'thumbImg',
    fsize: 'fsize',
    mimeType: 'mimeType',
    type: 'type',
    endUser: 'endUser',
    status: 'status',
    sha256: 'sha256',
    parts: 'parts',
    ext: 'ext',
    expireAt: 'expireAt',
    transitionToIaAt: 'transitionToIaAt',
    transitionToArchiveAt: 'transitionToArchiveAt',
    transitionToDeepArchiveAt: 'transitionToDeepArchiveAt',
    transitionToArchiveIRAt: 'transitionToArchiveIRAt',
    env: 'env',
    vendor: 'vendor',
    region: 'region',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type FileSourceScalarFieldEnum = (typeof FileSourceScalarFieldEnum)[keyof typeof FileSourceScalarFieldEnum]


  export const CountryCodeScalarFieldEnum: {
    id: 'id',
    continent: 'continent',
    code: 'code',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type CountryCodeScalarFieldEnum = (typeof CountryCodeScalarFieldEnum)[keyof typeof CountryCodeScalarFieldEnum]


  export const BotScalarFieldEnum: {
    id: 'id',
    name: 'name',
    hostname: 'hostname',
    aiProvider: 'aiProvider',
    model: 'model',
    channelType: 'channelType',
    containerId: 'containerId',
    port: 'port',
    gatewayToken: 'gatewayToken',
    proxyTokenHash: 'proxyTokenHash',
    tags: 'tags',
    status: 'status',
    createdById: 'createdById',
    personaTemplateId: 'personaTemplateId',
    emoji: 'emoji',
    avatarFileId: 'avatarFileId',
    soulMarkdown: 'soulMarkdown',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type BotScalarFieldEnum = (typeof BotScalarFieldEnum)[keyof typeof BotScalarFieldEnum]


  export const ProviderKeyScalarFieldEnum: {
    id: 'id',
    vendor: 'vendor',
    apiType: 'apiType',
    secretEncrypted: 'secretEncrypted',
    label: 'label',
    tag: 'tag',
    baseUrl: 'baseUrl',
    createdById: 'createdById',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ProviderKeyScalarFieldEnum = (typeof ProviderKeyScalarFieldEnum)[keyof typeof ProviderKeyScalarFieldEnum]


  export const BotProviderKeyScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    providerKeyId: 'providerKeyId',
    isPrimary: 'isPrimary',
    createdAt: 'createdAt'
  };

  export type BotProviderKeyScalarFieldEnum = (typeof BotProviderKeyScalarFieldEnum)[keyof typeof BotProviderKeyScalarFieldEnum]


  export const BotUsageLogScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    vendor: 'vendor',
    providerKeyId: 'providerKeyId',
    statusCode: 'statusCode',
    requestTokens: 'requestTokens',
    responseTokens: 'responseTokens',
    createdAt: 'createdAt'
  };

  export type BotUsageLogScalarFieldEnum = (typeof BotUsageLogScalarFieldEnum)[keyof typeof BotUsageLogScalarFieldEnum]


  export const ProxyTokenScalarFieldEnum: {
    id: 'id',
    botId: 'botId',
    tokenHash: 'tokenHash',
    vendor: 'vendor',
    keyId: 'keyId',
    tags: 'tags',
    expiresAt: 'expiresAt',
    revokedAt: 'revokedAt',
    lastUsedAt: 'lastUsedAt',
    requestCount: 'requestCount',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProxyTokenScalarFieldEnum = (typeof ProxyTokenScalarFieldEnum)[keyof typeof ProxyTokenScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    type: 'type',
    title: 'title',
    content: 'content',
    senderId: 'senderId',
    metadata: 'metadata',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const MessageRecipientScalarFieldEnum: {
    id: 'id',
    messageId: 'messageId',
    userId: 'userId',
    isRead: 'isRead',
    readAt: 'readAt',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt'
  };

  export type MessageRecipientScalarFieldEnum = (typeof MessageRecipientScalarFieldEnum)[keyof typeof MessageRecipientScalarFieldEnum]


  export const OperateLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    operateType: 'operateType',
    target: 'target',
    targetId: 'targetId',
    targetName: 'targetName',
    detail: 'detail',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type OperateLogScalarFieldEnum = (typeof OperateLogScalarFieldEnum)[keyof typeof OperateLogScalarFieldEnum]


  export const ChannelDefinitionScalarFieldEnum: {
    id: 'id',
    label: 'label',
    icon: 'icon',
    popular: 'popular',
    tokenHint: 'tokenHint',
    tokenPlaceholder: 'tokenPlaceholder',
    helpUrl: 'helpUrl',
    helpText: 'helpText',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChannelDefinitionScalarFieldEnum = (typeof ChannelDefinitionScalarFieldEnum)[keyof typeof ChannelDefinitionScalarFieldEnum]


  export const ChannelCredentialFieldScalarFieldEnum: {
    id: 'id',
    channelId: 'channelId',
    key: 'key',
    label: 'label',
    placeholder: 'placeholder',
    fieldType: 'fieldType',
    required: 'required',
    sortOrder: 'sortOrder',
    isDeleted: 'isDeleted',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    deletedAt: 'deletedAt'
  };

  export type ChannelCredentialFieldScalarFieldEnum = (typeof ChannelCredentialFieldScalarFieldEnum)[keyof typeof ChannelCredentialFieldScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'SexType'
   */
  export type EnumSexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexType'>
    


  /**
   * Reference to a field of type 'SexType[]'
   */
  export type ListEnumSexTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SexType[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'TaskType'
   */
  export type EnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType'>
    


  /**
   * Reference to a field of type 'TaskType[]'
   */
  export type ListEnumTaskTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskType[]'>
    


  /**
   * Reference to a field of type 'TaskStatus'
   */
  export type EnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus'>
    


  /**
   * Reference to a field of type 'TaskStatus[]'
   */
  export type ListEnumTaskStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TaskStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'FileEnvType'
   */
  export type EnumFileEnvTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileEnvType'>
    


  /**
   * Reference to a field of type 'FileEnvType[]'
   */
  export type ListEnumFileEnvTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileEnvType[]'>
    


  /**
   * Reference to a field of type 'FileBucketVendor'
   */
  export type EnumFileBucketVendorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileBucketVendor'>
    


  /**
   * Reference to a field of type 'FileBucketVendor[]'
   */
  export type ListEnumFileBucketVendorFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileBucketVendor[]'>
    


  /**
   * Reference to a field of type 'BotStatus'
   */
  export type EnumBotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BotStatus'>
    


  /**
   * Reference to a field of type 'BotStatus[]'
   */
  export type ListEnumBotStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BotStatus[]'>
    


  /**
   * Reference to a field of type 'Bytes'
   */
  export type BytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes'>
    


  /**
   * Reference to a field of type 'Bytes[]'
   */
  export type ListBytesFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Bytes[]'>
    


  /**
   * Reference to a field of type 'OperateType'
   */
  export type EnumOperateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateType'>
    


  /**
   * Reference to a field of type 'OperateType[]'
   */
  export type ListEnumOperateTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateType[]'>
    


  /**
   * Reference to a field of type 'OperateTarget'
   */
  export type EnumOperateTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateTarget'>
    


  /**
   * Reference to a field of type 'OperateTarget[]'
   */
  export type ListEnumOperateTargetFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'OperateTarget[]'>
    
  /**
   * Deep Input Types
   */


  export type UserInfoWhereInput = {
    AND?: UserInfoWhereInput | UserInfoWhereInput[]
    OR?: UserInfoWhereInput[]
    NOT?: UserInfoWhereInput | UserInfoWhereInput[]
    id?: UuidFilter<"UserInfo"> | string
    nickname?: StringFilter<"UserInfo"> | string
    code?: StringNullableFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableFilter<"UserInfo"> | string | null
    googleSub?: StringNullableFilter<"UserInfo"> | string | null
    discordId?: StringNullableFilter<"UserInfo"> | string | null
    mobile?: StringNullableFilter<"UserInfo"> | string | null
    email?: StringNullableFilter<"UserInfo"> | string | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    wechatAuth?: XOR<WechatAuthNullableScalarRelationFilter, WechatAuthWhereInput> | null
    googleAuth?: XOR<GoogleAuthNullableScalarRelationFilter, GoogleAuthWhereInput> | null
    discordAuth?: XOR<DiscordAuthNullableScalarRelationFilter, DiscordAuthWhereInput> | null
    mobileAuth?: XOR<MobileAuthNullableScalarRelationFilter, MobileAuthWhereInput> | null
    emailAuth?: XOR<EmailAuthNullableScalarRelationFilter, EmailAuthWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageRecipientListRelationFilter
    bots?: BotListRelationFilter
    providerKeys?: ProviderKeyListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    operateLogs?: OperateLogListRelationFilter
  }

  export type UserInfoOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    sex?: SortOrder
    locale?: SortOrderInput | SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    wechatOpenid?: SortOrderInput | SortOrder
    wechatUnionId?: SortOrderInput | SortOrder
    googleSub?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    avatarFile?: FileSourceOrderByWithRelationInput
    wechatAuth?: WechatAuthOrderByWithRelationInput
    googleAuth?: GoogleAuthOrderByWithRelationInput
    discordAuth?: DiscordAuthOrderByWithRelationInput
    mobileAuth?: MobileAuthOrderByWithRelationInput
    emailAuth?: EmailAuthOrderByWithRelationInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageRecipientOrderByRelationAggregateInput
    bots?: BotOrderByRelationAggregateInput
    providerKeys?: ProviderKeyOrderByRelationAggregateInput
    personaTemplates?: PersonaTemplateOrderByRelationAggregateInput
    operateLogs?: OperateLogOrderByRelationAggregateInput
  }

  export type UserInfoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    deviceId?: string
    wechatOpenid?: string
    wechatUnionId?: string
    googleSub?: string
    discordId?: string
    mobile?: string
    email?: string
    AND?: UserInfoWhereInput | UserInfoWhereInput[]
    OR?: UserInfoWhereInput[]
    NOT?: UserInfoWhereInput | UserInfoWhereInput[]
    nickname?: StringFilter<"UserInfo"> | string
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    wechatAuth?: XOR<WechatAuthNullableScalarRelationFilter, WechatAuthWhereInput> | null
    googleAuth?: XOR<GoogleAuthNullableScalarRelationFilter, GoogleAuthWhereInput> | null
    discordAuth?: XOR<DiscordAuthNullableScalarRelationFilter, DiscordAuthWhereInput> | null
    mobileAuth?: XOR<MobileAuthNullableScalarRelationFilter, MobileAuthWhereInput> | null
    emailAuth?: XOR<EmailAuthNullableScalarRelationFilter, EmailAuthWhereInput> | null
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageRecipientListRelationFilter
    bots?: BotListRelationFilter
    providerKeys?: ProviderKeyListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    operateLogs?: OperateLogListRelationFilter
  }, "id" | "code" | "deviceId" | "wechatOpenid" | "wechatUnionId" | "googleSub" | "discordId" | "mobile" | "email">

  export type UserInfoOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    sex?: SortOrder
    locale?: SortOrderInput | SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    deviceId?: SortOrderInput | SortOrder
    wechatOpenid?: SortOrderInput | SortOrder
    wechatUnionId?: SortOrderInput | SortOrder
    googleSub?: SortOrderInput | SortOrder
    discordId?: SortOrderInput | SortOrder
    mobile?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    _count?: UserInfoCountOrderByAggregateInput
    _max?: UserInfoMaxOrderByAggregateInput
    _min?: UserInfoMinOrderByAggregateInput
  }

  export type UserInfoScalarWhereWithAggregatesInput = {
    AND?: UserInfoScalarWhereWithAggregatesInput | UserInfoScalarWhereWithAggregatesInput[]
    OR?: UserInfoScalarWhereWithAggregatesInput[]
    NOT?: UserInfoScalarWhereWithAggregatesInput | UserInfoScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"UserInfo"> | string
    nickname?: StringWithAggregatesFilter<"UserInfo"> | string
    code?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeWithAggregatesFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    isAnonymity?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    isAdmin?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"UserInfo"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    googleSub?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    discordId?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    mobile?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
    email?: StringNullableWithAggregatesFilter<"UserInfo"> | string | null
  }

  export type PersonaTemplateWhereInput = {
    AND?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    OR?: PersonaTemplateWhereInput[]
    NOT?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    id?: UuidFilter<"PersonaTemplate"> | string
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
    createdBy?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    bots?: BotListRelationFilter
  }

  export type PersonaTemplateOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    avatarFile?: FileSourceOrderByWithRelationInput
    bots?: BotOrderByRelationAggregateInput
  }

  export type PersonaTemplateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    OR?: PersonaTemplateWhereInput[]
    NOT?: PersonaTemplateWhereInput | PersonaTemplateWhereInput[]
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
    createdBy?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    bots?: BotListRelationFilter
  }, "id">

  export type PersonaTemplateOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrderInput | SortOrder
    isSystem?: SortOrder
    createdById?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: PersonaTemplateCountOrderByAggregateInput
    _max?: PersonaTemplateMaxOrderByAggregateInput
    _min?: PersonaTemplateMinOrderByAggregateInput
  }

  export type PersonaTemplateScalarWhereWithAggregatesInput = {
    AND?: PersonaTemplateScalarWhereWithAggregatesInput | PersonaTemplateScalarWhereWithAggregatesInput[]
    OR?: PersonaTemplateScalarWhereWithAggregatesInput[]
    NOT?: PersonaTemplateScalarWhereWithAggregatesInput | PersonaTemplateScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"PersonaTemplate"> | string
    name?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    emoji?: StringNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    tagline?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringWithAggregatesFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolWithAggregatesFilter<"PersonaTemplate"> | boolean
    createdById?: UuidNullableWithAggregatesFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"PersonaTemplate"> | Date | string | null
  }

  export type WechatAuthWhereInput = {
    AND?: WechatAuthWhereInput | WechatAuthWhereInput[]
    OR?: WechatAuthWhereInput[]
    NOT?: WechatAuthWhereInput | WechatAuthWhereInput[]
    openid?: StringFilter<"WechatAuth"> | string
    sessionKey?: StringNullableFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableFilter<"WechatAuth"> | string | null
    isDeleted?: BoolFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WechatAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type WechatAuthOrderByWithRelationInput = {
    openid?: SortOrder
    sessionKey?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type WechatAuthWhereUniqueInput = Prisma.AtLeast<{
    openid?: string
    AND?: WechatAuthWhereInput | WechatAuthWhereInput[]
    OR?: WechatAuthWhereInput[]
    NOT?: WechatAuthWhereInput | WechatAuthWhereInput[]
    sessionKey?: StringNullableFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableFilter<"WechatAuth"> | string | null
    isDeleted?: BoolFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"WechatAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "openid">

  export type WechatAuthOrderByWithAggregationInput = {
    openid?: SortOrder
    sessionKey?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: WechatAuthCountOrderByAggregateInput
    _max?: WechatAuthMaxOrderByAggregateInput
    _min?: WechatAuthMinOrderByAggregateInput
  }

  export type WechatAuthScalarWhereWithAggregatesInput = {
    AND?: WechatAuthScalarWhereWithAggregatesInput | WechatAuthScalarWhereWithAggregatesInput[]
    OR?: WechatAuthScalarWhereWithAggregatesInput[]
    NOT?: WechatAuthScalarWhereWithAggregatesInput | WechatAuthScalarWhereWithAggregatesInput[]
    openid?: StringWithAggregatesFilter<"WechatAuth"> | string
    sessionKey?: StringNullableWithAggregatesFilter<"WechatAuth"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"WechatAuth"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"WechatAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"WechatAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"WechatAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"WechatAuth"> | Date | string | null
  }

  export type GoogleAuthWhereInput = {
    AND?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    OR?: GoogleAuthWhereInput[]
    NOT?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    sub?: StringFilter<"GoogleAuth"> | string
    email?: StringFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableFilter<"GoogleAuth"> | string | null
    name?: StringNullableFilter<"GoogleAuth"> | string | null
    picture?: StringNullableFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableFilter<"GoogleAuth"> | string | null
    exp?: IntFilter<"GoogleAuth"> | number
    iat?: IntFilter<"GoogleAuth"> | number
    isDeleted?: BoolFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"GoogleAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type GoogleAuthOrderByWithRelationInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    familyName?: SortOrderInput | SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type GoogleAuthWhereUniqueInput = Prisma.AtLeast<{
    sub?: string
    AND?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    OR?: GoogleAuthWhereInput[]
    NOT?: GoogleAuthWhereInput | GoogleAuthWhereInput[]
    email?: StringFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableFilter<"GoogleAuth"> | string | null
    name?: StringNullableFilter<"GoogleAuth"> | string | null
    picture?: StringNullableFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableFilter<"GoogleAuth"> | string | null
    exp?: IntFilter<"GoogleAuth"> | number
    iat?: IntFilter<"GoogleAuth"> | number
    isDeleted?: BoolFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"GoogleAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "sub">

  export type GoogleAuthOrderByWithAggregationInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrderInput | SortOrder
    name?: SortOrderInput | SortOrder
    picture?: SortOrderInput | SortOrder
    givenName?: SortOrderInput | SortOrder
    familyName?: SortOrderInput | SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: GoogleAuthCountOrderByAggregateInput
    _avg?: GoogleAuthAvgOrderByAggregateInput
    _max?: GoogleAuthMaxOrderByAggregateInput
    _min?: GoogleAuthMinOrderByAggregateInput
    _sum?: GoogleAuthSumOrderByAggregateInput
  }

  export type GoogleAuthScalarWhereWithAggregatesInput = {
    AND?: GoogleAuthScalarWhereWithAggregatesInput | GoogleAuthScalarWhereWithAggregatesInput[]
    OR?: GoogleAuthScalarWhereWithAggregatesInput[]
    NOT?: GoogleAuthScalarWhereWithAggregatesInput | GoogleAuthScalarWhereWithAggregatesInput[]
    sub?: StringWithAggregatesFilter<"GoogleAuth"> | string
    email?: StringWithAggregatesFilter<"GoogleAuth"> | string
    verifiedEmail?: BoolWithAggregatesFilter<"GoogleAuth"> | boolean
    atHash?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    name?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    picture?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    givenName?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    familyName?: StringNullableWithAggregatesFilter<"GoogleAuth"> | string | null
    exp?: IntWithAggregatesFilter<"GoogleAuth"> | number
    iat?: IntWithAggregatesFilter<"GoogleAuth"> | number
    isDeleted?: BoolWithAggregatesFilter<"GoogleAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"GoogleAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"GoogleAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"GoogleAuth"> | Date | string | null
  }

  export type DiscordAuthWhereInput = {
    AND?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    OR?: DiscordAuthWhereInput[]
    NOT?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    discordId?: StringFilter<"DiscordAuth"> | string
    email?: StringFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolFilter<"DiscordAuth"> | boolean
    name?: StringNullableFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DiscordAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type DiscordAuthOrderByWithRelationInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type DiscordAuthWhereUniqueInput = Prisma.AtLeast<{
    discordId?: string
    AND?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    OR?: DiscordAuthWhereInput[]
    NOT?: DiscordAuthWhereInput | DiscordAuthWhereInput[]
    email?: StringFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolFilter<"DiscordAuth"> | boolean
    name?: StringNullableFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"DiscordAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "discordId">

  export type DiscordAuthOrderByWithAggregationInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrderInput | SortOrder
    accessToken?: SortOrderInput | SortOrder
    refreshToken?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: DiscordAuthCountOrderByAggregateInput
    _max?: DiscordAuthMaxOrderByAggregateInput
    _min?: DiscordAuthMinOrderByAggregateInput
  }

  export type DiscordAuthScalarWhereWithAggregatesInput = {
    AND?: DiscordAuthScalarWhereWithAggregatesInput | DiscordAuthScalarWhereWithAggregatesInput[]
    OR?: DiscordAuthScalarWhereWithAggregatesInput[]
    NOT?: DiscordAuthScalarWhereWithAggregatesInput | DiscordAuthScalarWhereWithAggregatesInput[]
    discordId?: StringWithAggregatesFilter<"DiscordAuth"> | string
    email?: StringWithAggregatesFilter<"DiscordAuth"> | string
    verifiedEmail?: BoolWithAggregatesFilter<"DiscordAuth"> | boolean
    name?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    accessToken?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    refreshToken?: StringNullableWithAggregatesFilter<"DiscordAuth"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"DiscordAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"DiscordAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"DiscordAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"DiscordAuth"> | Date | string | null
  }

  export type MobileAuthWhereInput = {
    AND?: MobileAuthWhereInput | MobileAuthWhereInput[]
    OR?: MobileAuthWhereInput[]
    NOT?: MobileAuthWhereInput | MobileAuthWhereInput[]
    mobile?: StringFilter<"MobileAuth"> | string
    password?: StringFilter<"MobileAuth"> | string
    verified?: BoolFilter<"MobileAuth"> | boolean
    isDeleted?: BoolFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MobileAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type MobileAuthOrderByWithRelationInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type MobileAuthWhereUniqueInput = Prisma.AtLeast<{
    mobile?: string
    AND?: MobileAuthWhereInput | MobileAuthWhereInput[]
    OR?: MobileAuthWhereInput[]
    NOT?: MobileAuthWhereInput | MobileAuthWhereInput[]
    password?: StringFilter<"MobileAuth"> | string
    verified?: BoolFilter<"MobileAuth"> | boolean
    isDeleted?: BoolFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"MobileAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "mobile">

  export type MobileAuthOrderByWithAggregationInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MobileAuthCountOrderByAggregateInput
    _max?: MobileAuthMaxOrderByAggregateInput
    _min?: MobileAuthMinOrderByAggregateInput
  }

  export type MobileAuthScalarWhereWithAggregatesInput = {
    AND?: MobileAuthScalarWhereWithAggregatesInput | MobileAuthScalarWhereWithAggregatesInput[]
    OR?: MobileAuthScalarWhereWithAggregatesInput[]
    NOT?: MobileAuthScalarWhereWithAggregatesInput | MobileAuthScalarWhereWithAggregatesInput[]
    mobile?: StringWithAggregatesFilter<"MobileAuth"> | string
    password?: StringWithAggregatesFilter<"MobileAuth"> | string
    verified?: BoolWithAggregatesFilter<"MobileAuth"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"MobileAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"MobileAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MobileAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MobileAuth"> | Date | string | null
  }

  export type EmailAuthWhereInput = {
    AND?: EmailAuthWhereInput | EmailAuthWhereInput[]
    OR?: EmailAuthWhereInput[]
    NOT?: EmailAuthWhereInput | EmailAuthWhereInput[]
    email?: StringFilter<"EmailAuth"> | string
    password?: StringFilter<"EmailAuth"> | string
    verified?: BoolFilter<"EmailAuth"> | boolean
    isDeleted?: BoolFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmailAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type EmailAuthOrderByWithRelationInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type EmailAuthWhereUniqueInput = Prisma.AtLeast<{
    email?: string
    AND?: EmailAuthWhereInput | EmailAuthWhereInput[]
    OR?: EmailAuthWhereInput[]
    NOT?: EmailAuthWhereInput | EmailAuthWhereInput[]
    password?: StringFilter<"EmailAuth"> | string
    verified?: BoolFilter<"EmailAuth"> | boolean
    isDeleted?: BoolFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableFilter<"EmailAuth"> | Date | string | null
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "email">

  export type EmailAuthOrderByWithAggregationInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: EmailAuthCountOrderByAggregateInput
    _max?: EmailAuthMaxOrderByAggregateInput
    _min?: EmailAuthMinOrderByAggregateInput
  }

  export type EmailAuthScalarWhereWithAggregatesInput = {
    AND?: EmailAuthScalarWhereWithAggregatesInput | EmailAuthScalarWhereWithAggregatesInput[]
    OR?: EmailAuthScalarWhereWithAggregatesInput[]
    NOT?: EmailAuthScalarWhereWithAggregatesInput | EmailAuthScalarWhereWithAggregatesInput[]
    email?: StringWithAggregatesFilter<"EmailAuth"> | string
    password?: StringWithAggregatesFilter<"EmailAuth"> | string
    verified?: BoolWithAggregatesFilter<"EmailAuth"> | boolean
    isDeleted?: BoolWithAggregatesFilter<"EmailAuth"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"EmailAuth"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmailAuth"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"EmailAuth"> | Date | string | null
  }

  export type RiskDetectionRecordWhereInput = {
    AND?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    OR?: RiskDetectionRecordWhereInput[]
    NOT?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    id?: StringFilter<"RiskDetectionRecord"> | string
    action?: StringFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableFilter<"RiskDetectionRecord">
    status?: IntFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RiskDetectionRecord"> | Date | string | null
  }

  export type RiskDetectionRecordOrderByWithRelationInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type RiskDetectionRecordWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    OR?: RiskDetectionRecordWhereInput[]
    NOT?: RiskDetectionRecordWhereInput | RiskDetectionRecordWhereInput[]
    action?: StringFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableFilter<"RiskDetectionRecord">
    status?: IntFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableFilter<"RiskDetectionRecord"> | Date | string | null
  }, "id">

  export type RiskDetectionRecordOrderByWithAggregationInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrderInput | SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: RiskDetectionRecordCountOrderByAggregateInput
    _avg?: RiskDetectionRecordAvgOrderByAggregateInput
    _max?: RiskDetectionRecordMaxOrderByAggregateInput
    _min?: RiskDetectionRecordMinOrderByAggregateInput
    _sum?: RiskDetectionRecordSumOrderByAggregateInput
  }

  export type RiskDetectionRecordScalarWhereWithAggregatesInput = {
    AND?: RiskDetectionRecordScalarWhereWithAggregatesInput | RiskDetectionRecordScalarWhereWithAggregatesInput[]
    OR?: RiskDetectionRecordScalarWhereWithAggregatesInput[]
    NOT?: RiskDetectionRecordScalarWhereWithAggregatesInput | RiskDetectionRecordScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RiskDetectionRecord"> | string
    action?: StringWithAggregatesFilter<"RiskDetectionRecord"> | string
    data?: JsonNullableWithAggregatesFilter<"RiskDetectionRecord">
    status?: IntWithAggregatesFilter<"RiskDetectionRecord"> | number
    isDeleted?: BoolWithAggregatesFilter<"RiskDetectionRecord"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"RiskDetectionRecord"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"RiskDetectionRecord"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"RiskDetectionRecord"> | Date | string | null
  }

  export type SystemTaskQueueWhereInput = {
    AND?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    OR?: SystemTaskQueueWhereInput[]
    NOT?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    id?: UuidFilter<"SystemTaskQueue"> | string
    taskType?: EnumTaskTypeFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableFilter<"SystemTaskQueue">
    content?: StringNullableFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableFilter<"SystemTaskQueue">
    createdAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
  }

  export type SystemTaskQueueOrderByWithRelationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateData?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    OR?: SystemTaskQueueWhereInput[]
    NOT?: SystemTaskQueueWhereInput | SystemTaskQueueWhereInput[]
    taskType?: EnumTaskTypeFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableFilter<"SystemTaskQueue">
    content?: StringNullableFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableFilter<"SystemTaskQueue">
    createdAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeFilter<"SystemTaskQueue"> | Date | string
  }, "id">

  export type SystemTaskQueueOrderByWithAggregationInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrderInput | SortOrder
    templateData?: SortOrderInput | SortOrder
    content?: SortOrderInput | SortOrder
    subject?: SortOrderInput | SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SystemTaskQueueCountOrderByAggregateInput
    _avg?: SystemTaskQueueAvgOrderByAggregateInput
    _max?: SystemTaskQueueMaxOrderByAggregateInput
    _min?: SystemTaskQueueMinOrderByAggregateInput
    _sum?: SystemTaskQueueSumOrderByAggregateInput
  }

  export type SystemTaskQueueScalarWhereWithAggregatesInput = {
    AND?: SystemTaskQueueScalarWhereWithAggregatesInput | SystemTaskQueueScalarWhereWithAggregatesInput[]
    OR?: SystemTaskQueueScalarWhereWithAggregatesInput[]
    NOT?: SystemTaskQueueScalarWhereWithAggregatesInput | SystemTaskQueueScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"SystemTaskQueue"> | string
    taskType?: EnumTaskTypeWithAggregatesFilter<"SystemTaskQueue"> | $Enums.TaskType
    status?: EnumTaskStatusWithAggregatesFilter<"SystemTaskQueue"> | $Enums.TaskStatus
    recipient?: StringWithAggregatesFilter<"SystemTaskQueue"> | string
    templateCode?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    templateData?: JsonNullableWithAggregatesFilter<"SystemTaskQueue">
    content?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    subject?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    retryCount?: IntWithAggregatesFilter<"SystemTaskQueue"> | number
    processedAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
    errorMessage?: StringNullableWithAggregatesFilter<"SystemTaskQueue"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"SystemTaskQueue">
    createdAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"SystemTaskQueue"> | Date | string
  }

  export type FileSourceWhereInput = {
    AND?: FileSourceWhereInput | FileSourceWhereInput[]
    OR?: FileSourceWhereInput[]
    NOT?: FileSourceWhereInput | FileSourceWhereInput[]
    id?: UuidFilter<"FileSource"> | string
    isUploaded?: BoolFilter<"FileSource"> | boolean
    bucket?: StringFilter<"FileSource"> | string
    key?: StringFilter<"FileSource"> | string
    hash?: StringNullableFilter<"FileSource"> | string | null
    thumbImg?: StringNullableFilter<"FileSource"> | string | null
    fsize?: FloatFilter<"FileSource"> | number
    mimeType?: StringFilter<"FileSource"> | string
    type?: IntFilter<"FileSource"> | number
    endUser?: StringNullableFilter<"FileSource"> | string | null
    status?: IntFilter<"FileSource"> | number
    sha256?: StringNullableFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringFilter<"FileSource"> | string
    expireAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringFilter<"FileSource"> | string
    isDeleted?: BoolFilter<"FileSource"> | boolean
    createdAt?: DateTimeFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    userAvatars?: UserInfoListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    botAvatars?: BotListRelationFilter
  }

  export type FileSourceOrderByWithRelationInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrderInput | SortOrder
    thumbImg?: SortOrderInput | SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrderInput | SortOrder
    status?: SortOrder
    sha256?: SortOrderInput | SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrderInput | SortOrder
    transitionToIaAt?: SortOrderInput | SortOrder
    transitionToArchiveAt?: SortOrderInput | SortOrder
    transitionToDeepArchiveAt?: SortOrderInput | SortOrder
    transitionToArchiveIRAt?: SortOrderInput | SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    userAvatars?: UserInfoOrderByRelationAggregateInput
    personaTemplates?: PersonaTemplateOrderByRelationAggregateInput
    botAvatars?: BotOrderByRelationAggregateInput
  }

  export type FileSourceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: FileSourceWhereInput | FileSourceWhereInput[]
    OR?: FileSourceWhereInput[]
    NOT?: FileSourceWhereInput | FileSourceWhereInput[]
    isUploaded?: BoolFilter<"FileSource"> | boolean
    bucket?: StringFilter<"FileSource"> | string
    hash?: StringNullableFilter<"FileSource"> | string | null
    thumbImg?: StringNullableFilter<"FileSource"> | string | null
    fsize?: FloatFilter<"FileSource"> | number
    mimeType?: StringFilter<"FileSource"> | string
    type?: IntFilter<"FileSource"> | number
    endUser?: StringNullableFilter<"FileSource"> | string | null
    status?: IntFilter<"FileSource"> | number
    sha256?: StringNullableFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringFilter<"FileSource"> | string
    expireAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringFilter<"FileSource"> | string
    isDeleted?: BoolFilter<"FileSource"> | boolean
    createdAt?: DateTimeFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableFilter<"FileSource"> | Date | string | null
    userAvatars?: UserInfoListRelationFilter
    personaTemplates?: PersonaTemplateListRelationFilter
    botAvatars?: BotListRelationFilter
  }, "id" | "key">

  export type FileSourceOrderByWithAggregationInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrderInput | SortOrder
    thumbImg?: SortOrderInput | SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrderInput | SortOrder
    status?: SortOrder
    sha256?: SortOrderInput | SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrderInput | SortOrder
    transitionToIaAt?: SortOrderInput | SortOrder
    transitionToArchiveAt?: SortOrderInput | SortOrder
    transitionToDeepArchiveAt?: SortOrderInput | SortOrder
    transitionToArchiveIRAt?: SortOrderInput | SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: FileSourceCountOrderByAggregateInput
    _avg?: FileSourceAvgOrderByAggregateInput
    _max?: FileSourceMaxOrderByAggregateInput
    _min?: FileSourceMinOrderByAggregateInput
    _sum?: FileSourceSumOrderByAggregateInput
  }

  export type FileSourceScalarWhereWithAggregatesInput = {
    AND?: FileSourceScalarWhereWithAggregatesInput | FileSourceScalarWhereWithAggregatesInput[]
    OR?: FileSourceScalarWhereWithAggregatesInput[]
    NOT?: FileSourceScalarWhereWithAggregatesInput | FileSourceScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"FileSource"> | string
    isUploaded?: BoolWithAggregatesFilter<"FileSource"> | boolean
    bucket?: StringWithAggregatesFilter<"FileSource"> | string
    key?: StringWithAggregatesFilter<"FileSource"> | string
    hash?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    thumbImg?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    fsize?: FloatWithAggregatesFilter<"FileSource"> | number
    mimeType?: StringWithAggregatesFilter<"FileSource"> | string
    type?: IntWithAggregatesFilter<"FileSource"> | number
    endUser?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    status?: IntWithAggregatesFilter<"FileSource"> | number
    sha256?: StringNullableWithAggregatesFilter<"FileSource"> | string | null
    parts?: IntNullableListFilter<"FileSource">
    ext?: StringWithAggregatesFilter<"FileSource"> | string
    expireAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToIaAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToArchiveAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToDeepArchiveAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    transitionToArchiveIRAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
    env?: EnumFileEnvTypeWithAggregatesFilter<"FileSource"> | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorWithAggregatesFilter<"FileSource"> | $Enums.FileBucketVendor
    region?: StringWithAggregatesFilter<"FileSource"> | string
    isDeleted?: BoolWithAggregatesFilter<"FileSource"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"FileSource"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"FileSource"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"FileSource"> | Date | string | null
  }

  export type CountryCodeWhereInput = {
    AND?: CountryCodeWhereInput | CountryCodeWhereInput[]
    OR?: CountryCodeWhereInput[]
    NOT?: CountryCodeWhereInput | CountryCodeWhereInput[]
    id?: UuidFilter<"CountryCode"> | string
    continent?: StringFilter<"CountryCode"> | string
    code?: StringFilter<"CountryCode"> | string
    isDeleted?: BoolFilter<"CountryCode"> | boolean
    createdAt?: DateTimeFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CountryCode"> | Date | string | null
  }

  export type CountryCodeOrderByWithRelationInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
  }

  export type CountryCodeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    continent_code?: CountryCodeContinentCodeCompoundUniqueInput
    AND?: CountryCodeWhereInput | CountryCodeWhereInput[]
    OR?: CountryCodeWhereInput[]
    NOT?: CountryCodeWhereInput | CountryCodeWhereInput[]
    continent?: StringFilter<"CountryCode"> | string
    code?: StringFilter<"CountryCode"> | string
    isDeleted?: BoolFilter<"CountryCode"> | boolean
    createdAt?: DateTimeFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableFilter<"CountryCode"> | Date | string | null
  }, "id" | "continent_code">

  export type CountryCodeOrderByWithAggregationInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: CountryCodeCountOrderByAggregateInput
    _max?: CountryCodeMaxOrderByAggregateInput
    _min?: CountryCodeMinOrderByAggregateInput
  }

  export type CountryCodeScalarWhereWithAggregatesInput = {
    AND?: CountryCodeScalarWhereWithAggregatesInput | CountryCodeScalarWhereWithAggregatesInput[]
    OR?: CountryCodeScalarWhereWithAggregatesInput[]
    NOT?: CountryCodeScalarWhereWithAggregatesInput | CountryCodeScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"CountryCode"> | string
    continent?: StringWithAggregatesFilter<"CountryCode"> | string
    code?: StringWithAggregatesFilter<"CountryCode"> | string
    isDeleted?: BoolWithAggregatesFilter<"CountryCode"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"CountryCode"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"CountryCode"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"CountryCode"> | Date | string | null
  }

  export type BotWhereInput = {
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    id?: UuidFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    aiProvider?: StringFilter<"Bot"> | string
    model?: StringFilter<"Bot"> | string
    channelType?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    personaTemplate?: XOR<PersonaTemplateNullableScalarRelationFilter, PersonaTemplateWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    providerKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyToken?: XOR<ProxyTokenNullableScalarRelationFilter, ProxyTokenWhereInput> | null
  }

  export type BotOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    aiProvider?: SortOrder
    model?: SortOrder
    channelType?: SortOrder
    containerId?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    gatewayToken?: SortOrderInput | SortOrder
    proxyTokenHash?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    soulMarkdown?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    personaTemplate?: PersonaTemplateOrderByWithRelationInput
    avatarFile?: FileSourceOrderByWithRelationInput
    providerKeys?: BotProviderKeyOrderByRelationAggregateInput
    usageLogs?: BotUsageLogOrderByRelationAggregateInput
    proxyToken?: ProxyTokenOrderByWithRelationInput
  }

  export type BotWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotWhereInput | BotWhereInput[]
    OR?: BotWhereInput[]
    NOT?: BotWhereInput | BotWhereInput[]
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    aiProvider?: StringFilter<"Bot"> | string
    model?: StringFilter<"Bot"> | string
    channelType?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    personaTemplate?: XOR<PersonaTemplateNullableScalarRelationFilter, PersonaTemplateWhereInput> | null
    avatarFile?: XOR<FileSourceNullableScalarRelationFilter, FileSourceWhereInput> | null
    providerKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyToken?: XOR<ProxyTokenNullableScalarRelationFilter, ProxyTokenWhereInput> | null
  }, "id">

  export type BotOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    aiProvider?: SortOrder
    model?: SortOrder
    channelType?: SortOrder
    containerId?: SortOrderInput | SortOrder
    port?: SortOrderInput | SortOrder
    gatewayToken?: SortOrderInput | SortOrder
    proxyTokenHash?: SortOrderInput | SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrderInput | SortOrder
    emoji?: SortOrderInput | SortOrder
    avatarFileId?: SortOrderInput | SortOrder
    soulMarkdown?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: BotCountOrderByAggregateInput
    _avg?: BotAvgOrderByAggregateInput
    _max?: BotMaxOrderByAggregateInput
    _min?: BotMinOrderByAggregateInput
    _sum?: BotSumOrderByAggregateInput
  }

  export type BotScalarWhereWithAggregatesInput = {
    AND?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    OR?: BotScalarWhereWithAggregatesInput[]
    NOT?: BotScalarWhereWithAggregatesInput | BotScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Bot"> | string
    name?: StringWithAggregatesFilter<"Bot"> | string
    hostname?: StringWithAggregatesFilter<"Bot"> | string
    aiProvider?: StringWithAggregatesFilter<"Bot"> | string
    model?: StringWithAggregatesFilter<"Bot"> | string
    channelType?: StringWithAggregatesFilter<"Bot"> | string
    containerId?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    port?: IntNullableWithAggregatesFilter<"Bot"> | number | null
    gatewayToken?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusWithAggregatesFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidWithAggregatesFilter<"Bot"> | string
    personaTemplateId?: UuidNullableWithAggregatesFilter<"Bot"> | string | null
    emoji?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableWithAggregatesFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableWithAggregatesFilter<"Bot"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"Bot"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Bot"> | Date | string | null
  }

  export type ProviderKeyWhereInput = {
    AND?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    OR?: ProviderKeyWhereInput[]
    NOT?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    id?: UuidFilter<"ProviderKey"> | string
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    botProviderKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyTokens?: ProxyTokenListRelationFilter
  }

  export type ProviderKeyOrderByWithRelationInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrderInput | SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    createdBy?: UserInfoOrderByWithRelationInput
    botProviderKeys?: BotProviderKeyOrderByRelationAggregateInput
    usageLogs?: BotUsageLogOrderByRelationAggregateInput
    proxyTokens?: ProxyTokenOrderByRelationAggregateInput
  }

  export type ProviderKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_key_user_label_unique?: ProviderKeyProvider_key_user_label_uniqueCompoundUniqueInput
    AND?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    OR?: ProviderKeyWhereInput[]
    NOT?: ProviderKeyWhereInput | ProviderKeyWhereInput[]
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
    createdBy?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
    botProviderKeys?: BotProviderKeyListRelationFilter
    usageLogs?: BotUsageLogListRelationFilter
    proxyTokens?: ProxyTokenListRelationFilter
  }, "id" | "provider_key_user_label_unique">

  export type ProviderKeyOrderByWithAggregationInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrderInput | SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrderInput | SortOrder
    baseUrl?: SortOrderInput | SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ProviderKeyCountOrderByAggregateInput
    _max?: ProviderKeyMaxOrderByAggregateInput
    _min?: ProviderKeyMinOrderByAggregateInput
  }

  export type ProviderKeyScalarWhereWithAggregatesInput = {
    AND?: ProviderKeyScalarWhereWithAggregatesInput | ProviderKeyScalarWhereWithAggregatesInput[]
    OR?: ProviderKeyScalarWhereWithAggregatesInput[]
    NOT?: ProviderKeyScalarWhereWithAggregatesInput | ProviderKeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProviderKey"> | string
    vendor?: StringWithAggregatesFilter<"ProviderKey"> | string
    apiType?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesWithAggregatesFilter<"ProviderKey"> | Bytes
    label?: StringWithAggregatesFilter<"ProviderKey"> | string
    tag?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableWithAggregatesFilter<"ProviderKey"> | string | null
    createdById?: UuidWithAggregatesFilter<"ProviderKey"> | string
    isDeleted?: BoolWithAggregatesFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ProviderKey"> | Date | string | null
  }

  export type BotProviderKeyWhereInput = {
    AND?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    OR?: BotProviderKeyWhereInput[]
    NOT?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    id?: UuidFilter<"BotProviderKey"> | string
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }

  export type BotProviderKeyOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type BotProviderKeyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId_providerKeyId?: BotProviderKeyBotIdProviderKeyIdCompoundUniqueInput
    AND?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    OR?: BotProviderKeyWhereInput[]
    NOT?: BotProviderKeyWhereInput | BotProviderKeyWhereInput[]
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }, "id" | "botId_providerKeyId">

  export type BotProviderKeyOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
    _count?: BotProviderKeyCountOrderByAggregateInput
    _max?: BotProviderKeyMaxOrderByAggregateInput
    _min?: BotProviderKeyMinOrderByAggregateInput
  }

  export type BotProviderKeyScalarWhereWithAggregatesInput = {
    AND?: BotProviderKeyScalarWhereWithAggregatesInput | BotProviderKeyScalarWhereWithAggregatesInput[]
    OR?: BotProviderKeyScalarWhereWithAggregatesInput[]
    NOT?: BotProviderKeyScalarWhereWithAggregatesInput | BotProviderKeyScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    botId?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    providerKeyId?: UuidWithAggregatesFilter<"BotProviderKey"> | string
    isPrimary?: BoolWithAggregatesFilter<"BotProviderKey"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"BotProviderKey"> | Date | string
  }

  export type BotUsageLogWhereInput = {
    AND?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    OR?: BotUsageLogWhereInput[]
    NOT?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    id?: UuidFilter<"BotUsageLog"> | string
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyNullableScalarRelationFilter, ProviderKeyWhereInput> | null
  }

  export type BotUsageLogOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestTokens?: SortOrderInput | SortOrder
    responseTokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type BotUsageLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    OR?: BotUsageLogWhereInput[]
    NOT?: BotUsageLogWhereInput | BotUsageLogWhereInput[]
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyNullableScalarRelationFilter, ProviderKeyWhereInput> | null
  }, "id">

  export type BotUsageLogOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrderInput | SortOrder
    statusCode?: SortOrderInput | SortOrder
    requestTokens?: SortOrderInput | SortOrder
    responseTokens?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: BotUsageLogCountOrderByAggregateInput
    _avg?: BotUsageLogAvgOrderByAggregateInput
    _max?: BotUsageLogMaxOrderByAggregateInput
    _min?: BotUsageLogMinOrderByAggregateInput
    _sum?: BotUsageLogSumOrderByAggregateInput
  }

  export type BotUsageLogScalarWhereWithAggregatesInput = {
    AND?: BotUsageLogScalarWhereWithAggregatesInput | BotUsageLogScalarWhereWithAggregatesInput[]
    OR?: BotUsageLogScalarWhereWithAggregatesInput[]
    NOT?: BotUsageLogScalarWhereWithAggregatesInput | BotUsageLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"BotUsageLog"> | string
    botId?: UuidWithAggregatesFilter<"BotUsageLog"> | string
    vendor?: StringWithAggregatesFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableWithAggregatesFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableWithAggregatesFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"BotUsageLog"> | Date | string
  }

  export type ProxyTokenWhereInput = {
    AND?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    OR?: ProxyTokenWhereInput[]
    NOT?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    id?: UuidFilter<"ProxyToken"> | string
    botId?: UuidFilter<"ProxyToken"> | string
    tokenHash?: StringFilter<"ProxyToken"> | string
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }

  export type ProxyTokenOrderByWithRelationInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bot?: BotOrderByWithRelationInput
    providerKey?: ProviderKeyOrderByWithRelationInput
  }

  export type ProxyTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    botId?: string
    tokenHash?: string
    AND?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    OR?: ProxyTokenWhereInput[]
    NOT?: ProxyTokenWhereInput | ProxyTokenWhereInput[]
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
    bot?: XOR<BotScalarRelationFilter, BotWhereInput>
    providerKey?: XOR<ProviderKeyScalarRelationFilter, ProviderKeyWhereInput>
  }, "id" | "botId" | "tokenHash">

  export type ProxyTokenOrderByWithAggregationInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrderInput | SortOrder
    revokedAt?: SortOrderInput | SortOrder
    lastUsedAt?: SortOrderInput | SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ProxyTokenCountOrderByAggregateInput
    _avg?: ProxyTokenAvgOrderByAggregateInput
    _max?: ProxyTokenMaxOrderByAggregateInput
    _min?: ProxyTokenMinOrderByAggregateInput
    _sum?: ProxyTokenSumOrderByAggregateInput
  }

  export type ProxyTokenScalarWhereWithAggregatesInput = {
    AND?: ProxyTokenScalarWhereWithAggregatesInput | ProxyTokenScalarWhereWithAggregatesInput[]
    OR?: ProxyTokenScalarWhereWithAggregatesInput[]
    NOT?: ProxyTokenScalarWhereWithAggregatesInput | ProxyTokenScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ProxyToken"> | string
    botId?: UuidWithAggregatesFilter<"ProxyToken"> | string
    tokenHash?: StringWithAggregatesFilter<"ProxyToken"> | string
    vendor?: StringWithAggregatesFilter<"ProxyToken"> | string
    keyId?: UuidWithAggregatesFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableWithAggregatesFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntWithAggregatesFilter<"ProxyToken"> | number
    createdAt?: DateTimeWithAggregatesFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ProxyToken"> | Date | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: UuidFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sender?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    recipients?: MessageRecipientListRelationFilter
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    senderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    sender?: UserInfoOrderByWithRelationInput
    recipients?: MessageRecipientOrderByRelationAggregateInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    sender?: XOR<UserInfoNullableScalarRelationFilter, UserInfoWhereInput> | null
    recipients?: MessageRecipientListRelationFilter
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrderInput | SortOrder
    content?: SortOrder
    senderId?: SortOrderInput | SortOrder
    metadata?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"Message"> | string
    type?: StringWithAggregatesFilter<"Message"> | string
    title?: StringNullableWithAggregatesFilter<"Message"> | string | null
    content?: JsonWithAggregatesFilter<"Message">
    senderId?: UuidNullableWithAggregatesFilter<"Message"> | string | null
    metadata?: JsonNullableWithAggregatesFilter<"Message">
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
  }

  export type MessageRecipientWhereInput = {
    AND?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    OR?: MessageRecipientWhereInput[]
    NOT?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    id?: UuidFilter<"MessageRecipient"> | string
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type MessageRecipientOrderByWithRelationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    message?: MessageOrderByWithRelationInput
    user?: UserInfoOrderByWithRelationInput
  }

  export type MessageRecipientWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    messageId_userId?: MessageRecipientMessageIdUserIdCompoundUniqueInput
    AND?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    OR?: MessageRecipientWhereInput[]
    NOT?: MessageRecipientWhereInput | MessageRecipientWhereInput[]
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    message?: XOR<MessageScalarRelationFilter, MessageWhereInput>
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "id" | "messageId_userId">

  export type MessageRecipientOrderByWithAggregationInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: MessageRecipientCountOrderByAggregateInput
    _max?: MessageRecipientMaxOrderByAggregateInput
    _min?: MessageRecipientMinOrderByAggregateInput
  }

  export type MessageRecipientScalarWhereWithAggregatesInput = {
    AND?: MessageRecipientScalarWhereWithAggregatesInput | MessageRecipientScalarWhereWithAggregatesInput[]
    OR?: MessageRecipientScalarWhereWithAggregatesInput[]
    NOT?: MessageRecipientScalarWhereWithAggregatesInput | MessageRecipientScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    messageId?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    userId?: UuidWithAggregatesFilter<"MessageRecipient"> | string
    isRead?: BoolWithAggregatesFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeWithAggregatesFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolWithAggregatesFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"MessageRecipient"> | Date | string | null
  }

  export type OperateLogWhereInput = {
    AND?: OperateLogWhereInput | OperateLogWhereInput[]
    OR?: OperateLogWhereInput[]
    NOT?: OperateLogWhereInput | OperateLogWhereInput[]
    id?: UuidFilter<"OperateLog"> | string
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }

  export type OperateLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    user?: UserInfoOrderByWithRelationInput
  }

  export type OperateLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: OperateLogWhereInput | OperateLogWhereInput[]
    OR?: OperateLogWhereInput[]
    NOT?: OperateLogWhereInput | OperateLogWhereInput[]
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
    user?: XOR<UserInfoScalarRelationFilter, UserInfoWhereInput>
  }, "id">

  export type OperateLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrderInput | SortOrder
    targetName?: SortOrderInput | SortOrder
    detail?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: OperateLogCountOrderByAggregateInput
    _max?: OperateLogMaxOrderByAggregateInput
    _min?: OperateLogMinOrderByAggregateInput
  }

  export type OperateLogScalarWhereWithAggregatesInput = {
    AND?: OperateLogScalarWhereWithAggregatesInput | OperateLogScalarWhereWithAggregatesInput[]
    OR?: OperateLogScalarWhereWithAggregatesInput[]
    NOT?: OperateLogScalarWhereWithAggregatesInput | OperateLogScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"OperateLog"> | string
    userId?: UuidWithAggregatesFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeWithAggregatesFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetWithAggregatesFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableWithAggregatesFilter<"OperateLog"> | string | null
    targetName?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    detail?: JsonNullableWithAggregatesFilter<"OperateLog">
    ipAddress?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"OperateLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"OperateLog"> | Date | string
  }

  export type ChannelDefinitionWhereInput = {
    AND?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    OR?: ChannelDefinitionWhereInput[]
    NOT?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    id?: StringFilter<"ChannelDefinition"> | string
    label?: StringFilter<"ChannelDefinition"> | string
    icon?: StringFilter<"ChannelDefinition"> | string
    popular?: BoolFilter<"ChannelDefinition"> | boolean
    tokenHint?: StringFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntFilter<"ChannelDefinition"> | number
    isDeleted?: BoolFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelDefinition"> | Date | string | null
    credentialFields?: ChannelCredentialFieldListRelationFilter
  }

  export type ChannelDefinitionOrderByWithRelationInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    credentialFields?: ChannelCredentialFieldOrderByRelationAggregateInput
  }

  export type ChannelDefinitionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    OR?: ChannelDefinitionWhereInput[]
    NOT?: ChannelDefinitionWhereInput | ChannelDefinitionWhereInput[]
    label?: StringFilter<"ChannelDefinition"> | string
    icon?: StringFilter<"ChannelDefinition"> | string
    popular?: BoolFilter<"ChannelDefinition"> | boolean
    tokenHint?: StringFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntFilter<"ChannelDefinition"> | number
    isDeleted?: BoolFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelDefinition"> | Date | string | null
    credentialFields?: ChannelCredentialFieldListRelationFilter
  }, "id">

  export type ChannelDefinitionOrderByWithAggregationInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrderInput | SortOrder
    helpText?: SortOrderInput | SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChannelDefinitionCountOrderByAggregateInput
    _avg?: ChannelDefinitionAvgOrderByAggregateInput
    _max?: ChannelDefinitionMaxOrderByAggregateInput
    _min?: ChannelDefinitionMinOrderByAggregateInput
    _sum?: ChannelDefinitionSumOrderByAggregateInput
  }

  export type ChannelDefinitionScalarWhereWithAggregatesInput = {
    AND?: ChannelDefinitionScalarWhereWithAggregatesInput | ChannelDefinitionScalarWhereWithAggregatesInput[]
    OR?: ChannelDefinitionScalarWhereWithAggregatesInput[]
    NOT?: ChannelDefinitionScalarWhereWithAggregatesInput | ChannelDefinitionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    label?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    icon?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    popular?: BoolWithAggregatesFilter<"ChannelDefinition"> | boolean
    tokenHint?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    tokenPlaceholder?: StringWithAggregatesFilter<"ChannelDefinition"> | string
    helpUrl?: StringNullableWithAggregatesFilter<"ChannelDefinition"> | string | null
    helpText?: StringNullableWithAggregatesFilter<"ChannelDefinition"> | string | null
    sortOrder?: IntWithAggregatesFilter<"ChannelDefinition"> | number
    isDeleted?: BoolWithAggregatesFilter<"ChannelDefinition"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChannelDefinition"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChannelDefinition"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChannelDefinition"> | Date | string | null
  }

  export type ChannelCredentialFieldWhereInput = {
    AND?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    OR?: ChannelCredentialFieldWhereInput[]
    NOT?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    id?: UuidFilter<"ChannelCredentialField"> | string
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
    channel?: XOR<ChannelDefinitionScalarRelationFilter, ChannelDefinitionWhereInput>
  }

  export type ChannelCredentialFieldOrderByWithRelationInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    channel?: ChannelDefinitionOrderByWithRelationInput
  }

  export type ChannelCredentialFieldWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    channelId_key?: ChannelCredentialFieldChannelIdKeyCompoundUniqueInput
    AND?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    OR?: ChannelCredentialFieldWhereInput[]
    NOT?: ChannelCredentialFieldWhereInput | ChannelCredentialFieldWhereInput[]
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
    channel?: XOR<ChannelDefinitionScalarRelationFilter, ChannelDefinitionWhereInput>
  }, "id" | "channelId_key">

  export type ChannelCredentialFieldOrderByWithAggregationInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    _count?: ChannelCredentialFieldCountOrderByAggregateInput
    _avg?: ChannelCredentialFieldAvgOrderByAggregateInput
    _max?: ChannelCredentialFieldMaxOrderByAggregateInput
    _min?: ChannelCredentialFieldMinOrderByAggregateInput
    _sum?: ChannelCredentialFieldSumOrderByAggregateInput
  }

  export type ChannelCredentialFieldScalarWhereWithAggregatesInput = {
    AND?: ChannelCredentialFieldScalarWhereWithAggregatesInput | ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    OR?: ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    NOT?: ChannelCredentialFieldScalarWhereWithAggregatesInput | ChannelCredentialFieldScalarWhereWithAggregatesInput[]
    id?: UuidWithAggregatesFilter<"ChannelCredentialField"> | string
    channelId?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    key?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    label?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    placeholder?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    fieldType?: StringWithAggregatesFilter<"ChannelCredentialField"> | string
    required?: BoolWithAggregatesFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntWithAggregatesFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolWithAggregatesFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableWithAggregatesFilter<"ChannelCredentialField"> | Date | string | null
  }

  export type UserInfoCreateInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateManyInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
  }

  export type UserInfoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserInfoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaTemplateCreateInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateCreateManyInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonaTemplateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthCreateInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutWechatAuthInput
  }

  export type WechatAuthUncheckedCreateInput = {
    openid: string
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUpdateInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutWechatAuthNestedInput
  }

  export type WechatAuthUncheckedUpdateInput = {
    openid?: StringFieldUpdateOperationsInput | string
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthCreateManyInput = {
    openid: string
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUpdateManyMutationInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthUncheckedUpdateManyInput = {
    openid?: StringFieldUpdateOperationsInput | string
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthCreateInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutGoogleAuthInput
  }

  export type GoogleAuthUncheckedCreateInput = {
    sub: string
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutGoogleAuthNestedInput
  }

  export type GoogleAuthUncheckedUpdateInput = {
    sub?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthCreateManyInput = {
    sub: string
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUncheckedUpdateManyInput = {
    sub?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthCreateInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutDiscordAuthInput
  }

  export type DiscordAuthUncheckedCreateInput = {
    discordId: string
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutDiscordAuthNestedInput
  }

  export type DiscordAuthUncheckedUpdateInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthCreateManyInput = {
    discordId: string
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUncheckedUpdateManyInput = {
    discordId?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthCreateInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutMobileAuthInput
  }

  export type MobileAuthUncheckedCreateInput = {
    mobile: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutMobileAuthNestedInput
  }

  export type MobileAuthUncheckedUpdateInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthCreateManyInput = {
    mobile: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUncheckedUpdateManyInput = {
    mobile?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthCreateInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutEmailAuthInput
  }

  export type EmailAuthUncheckedCreateInput = {
    email: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUpdateInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutEmailAuthNestedInput
  }

  export type EmailAuthUncheckedUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthCreateManyInput = {
    email: string
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUpdateManyMutationInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUncheckedUpdateManyInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordCreateInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUncheckedCreateInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordCreateManyInput = {
    id: string
    action: string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type RiskDetectionRecordUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type RiskDetectionRecordUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    data?: NullableJsonNullValueInput | InputJsonValue
    status?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type SystemTaskQueueCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUncheckedCreateInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueCreateManyInput = {
    id?: string
    taskType: $Enums.TaskType
    status: $Enums.TaskStatus
    recipient: string
    templateCode?: string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: string | null
    subject?: string | null
    retryCount?: number
    processedAt: Date | string
    errorMessage?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type SystemTaskQueueUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemTaskQueueUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    taskType?: EnumTaskTypeFieldUpdateOperationsInput | $Enums.TaskType
    status?: EnumTaskStatusFieldUpdateOperationsInput | $Enums.TaskStatus
    recipient?: StringFieldUpdateOperationsInput | string
    templateCode?: NullableStringFieldUpdateOperationsInput | string | null
    templateData?: NullableJsonNullValueInput | InputJsonValue
    content?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    retryCount?: IntFieldUpdateOperationsInput | number
    processedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    errorMessage?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileSourceCreateInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceCreateManyInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type FileSourceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileSourceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeCreateInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUncheckedCreateInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeCreateManyInput = {
    id?: string
    continent: string
    code: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type CountryCodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CountryCodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    continent?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotCreateInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotCreateManyInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyCreateInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyCreateManyInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProviderKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotProviderKeyCreateInput = {
    id?: string
    isPrimary?: boolean
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutProviderKeysInput
    providerKey: ProviderKeyCreateNestedOneWithoutBotProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateInput = {
    id?: string
    botId: string
    providerKeyId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotProviderKeyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProviderKeysNestedInput
    providerKey?: ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyCreateManyInput = {
    id?: string
    botId: string
    providerKeyId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotProviderKeyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogCreateInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutUsageLogsInput
    providerKey?: ProviderKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateInput = {
    id?: string
    botId: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type BotUsageLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutUsageLogsNestedInput
    providerKey?: ProviderKeyUpdateOneWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogCreateManyInput = {
    id?: string
    botId: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type BotUsageLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenCreateInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutProxyTokenInput
    providerKey: ProviderKeyCreateNestedOneWithoutProxyTokensInput
  }

  export type ProxyTokenUncheckedCreateInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProxyTokenNestedInput
    providerKey?: ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput
  }

  export type ProxyTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenCreateManyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageCreateInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    sender?: UserInfoCreateNestedOneWithoutSentMessagesInput
    recipients?: MessageRecipientCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserInfoUpdateOneWithoutSentMessagesNestedInput
    recipients?: MessageRecipientUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageCreateManyInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientCreateInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutRecipientsInput
    user: UserInfoCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageRecipientUncheckedCreateInput = {
    id?: string
    messageId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutRecipientsNestedInput
    user?: UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageRecipientUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientCreateManyInput = {
    id?: string
    messageId: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperateLogCreateInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    user: UserInfoCreateNestedOneWithoutOperateLogsInput
  }

  export type OperateLogUncheckedCreateInput = {
    id?: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserInfoUpdateOneRequiredWithoutOperateLogsNestedInput
  }

  export type OperateLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogCreateManyInput = {
    id?: string
    userId: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChannelDefinitionCreateInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    credentialFields?: ChannelCredentialFieldCreateNestedManyWithoutChannelInput
  }

  export type ChannelDefinitionUncheckedCreateInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    credentialFields?: ChannelCredentialFieldUncheckedCreateNestedManyWithoutChannelInput
  }

  export type ChannelDefinitionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialFields?: ChannelCredentialFieldUpdateManyWithoutChannelNestedInput
  }

  export type ChannelDefinitionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    credentialFields?: ChannelCredentialFieldUncheckedUpdateManyWithoutChannelNestedInput
  }

  export type ChannelDefinitionCreateManyInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelDefinitionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    channel: ChannelDefinitionCreateNestedOneWithoutCredentialFieldsInput
  }

  export type ChannelCredentialFieldUncheckedCreateInput = {
    id?: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    channel?: ChannelDefinitionUpdateOneRequiredWithoutCredentialFieldsNestedInput
  }

  export type ChannelCredentialFieldUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateManyInput = {
    id?: string
    channelId: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    channelId?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type UuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type EnumSexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeFilter<$PrismaModel> | $Enums.SexType
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FileSourceNullableScalarRelationFilter = {
    is?: FileSourceWhereInput | null
    isNot?: FileSourceWhereInput | null
  }

  export type WechatAuthNullableScalarRelationFilter = {
    is?: WechatAuthWhereInput | null
    isNot?: WechatAuthWhereInput | null
  }

  export type GoogleAuthNullableScalarRelationFilter = {
    is?: GoogleAuthWhereInput | null
    isNot?: GoogleAuthWhereInput | null
  }

  export type DiscordAuthNullableScalarRelationFilter = {
    is?: DiscordAuthWhereInput | null
    isNot?: DiscordAuthWhereInput | null
  }

  export type MobileAuthNullableScalarRelationFilter = {
    is?: MobileAuthWhereInput | null
    isNot?: MobileAuthWhereInput | null
  }

  export type EmailAuthNullableScalarRelationFilter = {
    is?: EmailAuthWhereInput | null
    isNot?: EmailAuthWhereInput | null
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type MessageRecipientListRelationFilter = {
    every?: MessageRecipientWhereInput
    some?: MessageRecipientWhereInput
    none?: MessageRecipientWhereInput
  }

  export type BotListRelationFilter = {
    every?: BotWhereInput
    some?: BotWhereInput
    none?: BotWhereInput
  }

  export type ProviderKeyListRelationFilter = {
    every?: ProviderKeyWhereInput
    some?: ProviderKeyWhereInput
    none?: ProviderKeyWhereInput
  }

  export type PersonaTemplateListRelationFilter = {
    every?: PersonaTemplateWhereInput
    some?: PersonaTemplateWhereInput
    none?: PersonaTemplateWhereInput
  }

  export type OperateLogListRelationFilter = {
    every?: OperateLogWhereInput
    some?: OperateLogWhereInput
    none?: OperateLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageRecipientOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PersonaTemplateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type OperateLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserInfoCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UserInfoMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UserInfoMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    code?: SortOrder
    avatarFileId?: SortOrder
    sex?: SortOrder
    locale?: SortOrder
    isAnonymity?: SortOrder
    isAdmin?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
    deviceId?: SortOrder
    wechatOpenid?: SortOrder
    wechatUnionId?: SortOrder
    googleSub?: SortOrder
    discordId?: SortOrder
    mobile?: SortOrder
    email?: SortOrder
  }

  export type UuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type UuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumSexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeWithAggregatesFilter<$PrismaModel> | $Enums.SexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexTypeFilter<$PrismaModel>
    _max?: NestedEnumSexTypeFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type UserInfoNullableScalarRelationFilter = {
    is?: UserInfoWhereInput | null
    isNot?: UserInfoWhereInput | null
  }

  export type PersonaTemplateCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonaTemplateMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type PersonaTemplateMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    tagline?: SortOrder
    soulMarkdown?: SortOrder
    soulPreview?: SortOrder
    isSystem?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type UserInfoScalarRelationFilter = {
    is?: UserInfoWhereInput
    isNot?: UserInfoWhereInput
  }

  export type WechatAuthCountOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WechatAuthMaxOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type WechatAuthMinOrderByAggregateInput = {
    openid?: SortOrder
    sessionKey?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type GoogleAuthCountOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthAvgOrderByAggregateInput = {
    exp?: SortOrder
    iat?: SortOrder
  }

  export type GoogleAuthMaxOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthMinOrderByAggregateInput = {
    sub?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    atHash?: SortOrder
    name?: SortOrder
    picture?: SortOrder
    givenName?: SortOrder
    familyName?: SortOrder
    exp?: SortOrder
    iat?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type GoogleAuthSumOrderByAggregateInput = {
    exp?: SortOrder
    iat?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DiscordAuthCountOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DiscordAuthMaxOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type DiscordAuthMinOrderByAggregateInput = {
    discordId?: SortOrder
    email?: SortOrder
    verifiedEmail?: SortOrder
    name?: SortOrder
    accessToken?: SortOrder
    refreshToken?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthCountOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthMaxOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type MobileAuthMinOrderByAggregateInput = {
    mobile?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthCountOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthMaxOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type EmailAuthMinOrderByAggregateInput = {
    email?: SortOrder
    password?: SortOrder
    verified?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type RiskDetectionRecordCountOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    data?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordAvgOrderByAggregateInput = {
    status?: SortOrder
  }

  export type RiskDetectionRecordMaxOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordMinOrderByAggregateInput = {
    id?: SortOrder
    action?: SortOrder
    status?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type RiskDetectionRecordSumOrderByAggregateInput = {
    status?: SortOrder
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type EnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type SystemTaskQueueCountOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    templateData?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueAvgOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type SystemTaskQueueMaxOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueMinOrderByAggregateInput = {
    id?: SortOrder
    taskType?: SortOrder
    status?: SortOrder
    recipient?: SortOrder
    templateCode?: SortOrder
    content?: SortOrder
    subject?: SortOrder
    retryCount?: SortOrder
    processedAt?: SortOrder
    errorMessage?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SystemTaskQueueSumOrderByAggregateInput = {
    retryCount?: SortOrder
  }

  export type EnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type EnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumFileEnvTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeFilter<$PrismaModel> | $Enums.FileEnvType
  }

  export type EnumFileBucketVendorFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorFilter<$PrismaModel> | $Enums.FileBucketVendor
  }

  export type UserInfoListRelationFilter = {
    every?: UserInfoWhereInput
    some?: UserInfoWhereInput
    none?: UserInfoWhereInput
  }

  export type UserInfoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileSourceCountOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    parts?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceAvgOrderByAggregateInput = {
    fsize?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parts?: SortOrder
  }

  export type FileSourceMaxOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceMinOrderByAggregateInput = {
    id?: SortOrder
    isUploaded?: SortOrder
    bucket?: SortOrder
    key?: SortOrder
    hash?: SortOrder
    thumbImg?: SortOrder
    fsize?: SortOrder
    mimeType?: SortOrder
    type?: SortOrder
    endUser?: SortOrder
    status?: SortOrder
    sha256?: SortOrder
    ext?: SortOrder
    expireAt?: SortOrder
    transitionToIaAt?: SortOrder
    transitionToArchiveAt?: SortOrder
    transitionToDeepArchiveAt?: SortOrder
    transitionToArchiveIRAt?: SortOrder
    env?: SortOrder
    vendor?: SortOrder
    region?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type FileSourceSumOrderByAggregateInput = {
    fsize?: SortOrder
    type?: SortOrder
    status?: SortOrder
    parts?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumFileEnvTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileEnvType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileEnvTypeFilter<$PrismaModel>
    _max?: NestedEnumFileEnvTypeFilter<$PrismaModel>
  }

  export type EnumFileBucketVendorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel> | $Enums.FileBucketVendor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileBucketVendorFilter<$PrismaModel>
    _max?: NestedEnumFileBucketVendorFilter<$PrismaModel>
  }

  export type CountryCodeContinentCodeCompoundUniqueInput = {
    continent: string
    code: string
  }

  export type CountryCodeCountOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryCodeMaxOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type CountryCodeMinOrderByAggregateInput = {
    id?: SortOrder
    continent?: SortOrder
    code?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type EnumBotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusFilter<$PrismaModel> | $Enums.BotStatus
  }

  export type PersonaTemplateNullableScalarRelationFilter = {
    is?: PersonaTemplateWhereInput | null
    isNot?: PersonaTemplateWhereInput | null
  }

  export type BotProviderKeyListRelationFilter = {
    every?: BotProviderKeyWhereInput
    some?: BotProviderKeyWhereInput
    none?: BotProviderKeyWhereInput
  }

  export type BotUsageLogListRelationFilter = {
    every?: BotUsageLogWhereInput
    some?: BotUsageLogWhereInput
    none?: BotUsageLogWhereInput
  }

  export type ProxyTokenNullableScalarRelationFilter = {
    is?: ProxyTokenWhereInput | null
    isNot?: ProxyTokenWhereInput | null
  }

  export type BotProviderKeyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotUsageLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BotCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    aiProvider?: SortOrder
    model?: SortOrder
    channelType?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    tags?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type BotMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    aiProvider?: SortOrder
    model?: SortOrder
    channelType?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    hostname?: SortOrder
    aiProvider?: SortOrder
    model?: SortOrder
    channelType?: SortOrder
    containerId?: SortOrder
    port?: SortOrder
    gatewayToken?: SortOrder
    proxyTokenHash?: SortOrder
    status?: SortOrder
    createdById?: SortOrder
    personaTemplateId?: SortOrder
    emoji?: SortOrder
    avatarFileId?: SortOrder
    soulMarkdown?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BotSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumBotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusWithAggregatesFilter<$PrismaModel> | $Enums.BotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotStatusFilter<$PrismaModel>
    _max?: NestedEnumBotStatusFilter<$PrismaModel>
  }

  export type BytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type ProxyTokenListRelationFilter = {
    every?: ProxyTokenWhereInput
    some?: ProxyTokenWhereInput
    none?: ProxyTokenWhereInput
  }

  export type ProxyTokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProviderKeyProvider_key_user_label_uniqueCompoundUniqueInput = {
    createdById: string
    label: string
  }

  export type ProviderKeyCountOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProviderKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ProviderKeyMinOrderByAggregateInput = {
    id?: SortOrder
    vendor?: SortOrder
    apiType?: SortOrder
    secretEncrypted?: SortOrder
    label?: SortOrder
    tag?: SortOrder
    baseUrl?: SortOrder
    createdById?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type BytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }

  export type BotScalarRelationFilter = {
    is?: BotWhereInput
    isNot?: BotWhereInput
  }

  export type ProviderKeyScalarRelationFilter = {
    is?: ProviderKeyWhereInput
    isNot?: ProviderKeyWhereInput
  }

  export type BotProviderKeyBotIdProviderKeyIdCompoundUniqueInput = {
    botId: string
    providerKeyId: string
  }

  export type BotProviderKeyCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type BotProviderKeyMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type BotProviderKeyMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    providerKeyId?: SortOrder
    isPrimary?: SortOrder
    createdAt?: SortOrder
  }

  export type ProviderKeyNullableScalarRelationFilter = {
    is?: ProviderKeyWhereInput | null
    isNot?: ProviderKeyWhereInput | null
  }

  export type BotUsageLogCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
  }

  export type BotUsageLogAvgOrderByAggregateInput = {
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
  }

  export type BotUsageLogMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
  }

  export type BotUsageLogMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    vendor?: SortOrder
    providerKeyId?: SortOrder
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
    createdAt?: SortOrder
  }

  export type BotUsageLogSumOrderByAggregateInput = {
    statusCode?: SortOrder
    requestTokens?: SortOrder
    responseTokens?: SortOrder
  }

  export type ProxyTokenCountOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    tags?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenAvgOrderByAggregateInput = {
    requestCount?: SortOrder
  }

  export type ProxyTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenMinOrderByAggregateInput = {
    id?: SortOrder
    botId?: SortOrder
    tokenHash?: SortOrder
    vendor?: SortOrder
    keyId?: SortOrder
    expiresAt?: SortOrder
    revokedAt?: SortOrder
    lastUsedAt?: SortOrder
    requestCount?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ProxyTokenSumOrderByAggregateInput = {
    requestCount?: SortOrder
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    content?: SortOrder
    senderId?: SortOrder
    metadata?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    title?: SortOrder
    senderId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type MessageScalarRelationFilter = {
    is?: MessageWhereInput
    isNot?: MessageWhereInput
  }

  export type MessageRecipientMessageIdUserIdCompoundUniqueInput = {
    messageId: string
    userId: string
  }

  export type MessageRecipientCountOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageRecipientMaxOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type MessageRecipientMinOrderByAggregateInput = {
    id?: SortOrder
    messageId?: SortOrder
    userId?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
  }

  export type EnumOperateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeFilter<$PrismaModel> | $Enums.OperateType
  }

  export type EnumOperateTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetFilter<$PrismaModel> | $Enums.OperateTarget
  }

  export type OperateLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    detail?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperateLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type OperateLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    operateType?: SortOrder
    target?: SortOrder
    targetId?: SortOrder
    targetName?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumOperateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTypeFilter<$PrismaModel>
    _max?: NestedEnumOperateTypeFilter<$PrismaModel>
  }

  export type EnumOperateTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel> | $Enums.OperateTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTargetFilter<$PrismaModel>
    _max?: NestedEnumOperateTargetFilter<$PrismaModel>
  }

  export type ChannelCredentialFieldListRelationFilter = {
    every?: ChannelCredentialFieldWhereInput
    some?: ChannelCredentialFieldWhereInput
    none?: ChannelCredentialFieldWhereInput
  }

  export type ChannelCredentialFieldOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChannelDefinitionCountOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelDefinitionMaxOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionMinOrderByAggregateInput = {
    id?: SortOrder
    label?: SortOrder
    icon?: SortOrder
    popular?: SortOrder
    tokenHint?: SortOrder
    tokenPlaceholder?: SortOrder
    helpUrl?: SortOrder
    helpText?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelDefinitionSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelDefinitionScalarRelationFilter = {
    is?: ChannelDefinitionWhereInput
    isNot?: ChannelDefinitionWhereInput
  }

  export type ChannelCredentialFieldChannelIdKeyCompoundUniqueInput = {
    channelId: string
    key: string
  }

  export type ChannelCredentialFieldCountOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldAvgOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type ChannelCredentialFieldMaxOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldMinOrderByAggregateInput = {
    id?: SortOrder
    channelId?: SortOrder
    key?: SortOrder
    label?: SortOrder
    placeholder?: SortOrder
    fieldType?: SortOrder
    required?: SortOrder
    sortOrder?: SortOrder
    isDeleted?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    deletedAt?: SortOrder
  }

  export type ChannelCredentialFieldSumOrderByAggregateInput = {
    sortOrder?: SortOrder
  }

  export type FileSourceCreateNestedOneWithoutUserAvatarsInput = {
    create?: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutUserAvatarsInput
    connect?: FileSourceWhereUniqueInput
  }

  export type WechatAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    connect?: WechatAuthWhereUniqueInput
  }

  export type GoogleAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    connect?: GoogleAuthWhereUniqueInput
  }

  export type DiscordAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    connect?: DiscordAuthWhereUniqueInput
  }

  export type MobileAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    connect?: MobileAuthWhereUniqueInput
  }

  export type EmailAuthCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    connect?: EmailAuthWhereUniqueInput
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageRecipientCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type BotCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type ProviderKeyCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
  }

  export type PersonaTemplateCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type OperateLogCreateNestedManyWithoutUserInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
  }

  export type WechatAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    connect?: WechatAuthWhereUniqueInput
  }

  export type GoogleAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    connect?: GoogleAuthWhereUniqueInput
  }

  export type DiscordAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    connect?: DiscordAuthWhereUniqueInput
  }

  export type MobileAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    connect?: MobileAuthWhereUniqueInput
  }

  export type EmailAuthUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    connect?: EmailAuthWhereUniqueInput
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageRecipientUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
  }

  export type PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type OperateLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumSexTypeFieldUpdateOperationsInput = {
    set?: $Enums.SexType
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FileSourceUpdateOneWithoutUserAvatarsNestedInput = {
    create?: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutUserAvatarsInput
    upsert?: FileSourceUpsertWithoutUserAvatarsInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutUserAvatarsInput, FileSourceUpdateWithoutUserAvatarsInput>, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type WechatAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    upsert?: WechatAuthUpsertWithoutUserInput
    disconnect?: WechatAuthWhereInput | boolean
    delete?: WechatAuthWhereInput | boolean
    connect?: WechatAuthWhereUniqueInput
    update?: XOR<XOR<WechatAuthUpdateToOneWithWhereWithoutUserInput, WechatAuthUpdateWithoutUserInput>, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    upsert?: GoogleAuthUpsertWithoutUserInput
    disconnect?: GoogleAuthWhereInput | boolean
    delete?: GoogleAuthWhereInput | boolean
    connect?: GoogleAuthWhereUniqueInput
    update?: XOR<XOR<GoogleAuthUpdateToOneWithWhereWithoutUserInput, GoogleAuthUpdateWithoutUserInput>, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    upsert?: DiscordAuthUpsertWithoutUserInput
    disconnect?: DiscordAuthWhereInput | boolean
    delete?: DiscordAuthWhereInput | boolean
    connect?: DiscordAuthWhereUniqueInput
    update?: XOR<XOR<DiscordAuthUpdateToOneWithWhereWithoutUserInput, DiscordAuthUpdateWithoutUserInput>, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    upsert?: MobileAuthUpsertWithoutUserInput
    disconnect?: MobileAuthWhereInput | boolean
    delete?: MobileAuthWhereInput | boolean
    connect?: MobileAuthWhereUniqueInput
    update?: XOR<XOR<MobileAuthUpdateToOneWithWhereWithoutUserInput, MobileAuthUpdateWithoutUserInput>, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    upsert?: EmailAuthUpsertWithoutUserInput
    disconnect?: EmailAuthWhereInput | boolean
    delete?: EmailAuthWhereInput | boolean
    connect?: EmailAuthWhereUniqueInput
    update?: XOR<XOR<EmailAuthUpdateToOneWithWhereWithoutUserInput, EmailAuthUpdateWithoutUserInput>, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageRecipientUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutUserInput | MessageRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutUserInput | MessageRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutUserInput | MessageRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type BotUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutCreatedByInput | BotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutCreatedByInput | BotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BotUpdateManyWithWhereWithoutCreatedByInput | BotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type ProviderKeyUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    set?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    disconnect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    delete?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    update?: ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProviderKeyUpdateManyWithWhereWithoutCreatedByInput | ProviderKeyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
  }

  export type PersonaTemplateUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type OperateLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    upsert?: OperateLogUpsertWithWhereUniqueWithoutUserInput | OperateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    set?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    disconnect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    delete?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    update?: OperateLogUpdateWithWhereUniqueWithoutUserInput | OperateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperateLogUpdateManyWithWhereWithoutUserInput | OperateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
  }

  export type WechatAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: WechatAuthCreateOrConnectWithoutUserInput
    upsert?: WechatAuthUpsertWithoutUserInput
    disconnect?: WechatAuthWhereInput | boolean
    delete?: WechatAuthWhereInput | boolean
    connect?: WechatAuthWhereUniqueInput
    update?: XOR<XOR<WechatAuthUpdateToOneWithWhereWithoutUserInput, WechatAuthUpdateWithoutUserInput>, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: GoogleAuthCreateOrConnectWithoutUserInput
    upsert?: GoogleAuthUpsertWithoutUserInput
    disconnect?: GoogleAuthWhereInput | boolean
    delete?: GoogleAuthWhereInput | boolean
    connect?: GoogleAuthWhereUniqueInput
    update?: XOR<XOR<GoogleAuthUpdateToOneWithWhereWithoutUserInput, GoogleAuthUpdateWithoutUserInput>, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: DiscordAuthCreateOrConnectWithoutUserInput
    upsert?: DiscordAuthUpsertWithoutUserInput
    disconnect?: DiscordAuthWhereInput | boolean
    delete?: DiscordAuthWhereInput | boolean
    connect?: DiscordAuthWhereUniqueInput
    update?: XOR<XOR<DiscordAuthUpdateToOneWithWhereWithoutUserInput, DiscordAuthUpdateWithoutUserInput>, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: MobileAuthCreateOrConnectWithoutUserInput
    upsert?: MobileAuthUpsertWithoutUserInput
    disconnect?: MobileAuthWhereInput | boolean
    delete?: MobileAuthWhereInput | boolean
    connect?: MobileAuthWhereUniqueInput
    update?: XOR<XOR<MobileAuthUpdateToOneWithWhereWithoutUserInput, MobileAuthUpdateWithoutUserInput>, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmailAuthCreateOrConnectWithoutUserInput
    upsert?: EmailAuthUpsertWithoutUserInput
    disconnect?: EmailAuthWhereInput | boolean
    delete?: EmailAuthWhereInput | boolean
    connect?: EmailAuthWhereUniqueInput
    update?: XOR<XOR<EmailAuthUpdateToOneWithWhereWithoutUserInput, EmailAuthUpdateWithoutUserInput>, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageRecipientUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput> | MessageRecipientCreateWithoutUserInput[] | MessageRecipientUncheckedCreateWithoutUserInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutUserInput | MessageRecipientCreateOrConnectWithoutUserInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutUserInput | MessageRecipientUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: MessageRecipientCreateManyUserInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutUserInput | MessageRecipientUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutUserInput | MessageRecipientUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput> | BotCreateWithoutCreatedByInput[] | BotUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: BotCreateOrConnectWithoutCreatedByInput | BotCreateOrConnectWithoutCreatedByInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutCreatedByInput | BotUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: BotCreateManyCreatedByInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutCreatedByInput | BotUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: BotUpdateManyWithWhereWithoutCreatedByInput | BotUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput> | ProviderKeyCreateWithoutCreatedByInput[] | ProviderKeyUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutCreatedByInput | ProviderKeyCreateOrConnectWithoutCreatedByInput[]
    upsert?: ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ProviderKeyCreateManyCreatedByInputEnvelope
    set?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    disconnect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    delete?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    connect?: ProviderKeyWhereUniqueInput | ProviderKeyWhereUniqueInput[]
    update?: ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput | ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ProviderKeyUpdateManyWithWhereWithoutCreatedByInput | ProviderKeyUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput> | PersonaTemplateCreateWithoutCreatedByInput[] | PersonaTemplateUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutCreatedByInput | PersonaTemplateCreateOrConnectWithoutCreatedByInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: PersonaTemplateCreateManyCreatedByInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput | PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput | PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type OperateLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput> | OperateLogCreateWithoutUserInput[] | OperateLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OperateLogCreateOrConnectWithoutUserInput | OperateLogCreateOrConnectWithoutUserInput[]
    upsert?: OperateLogUpsertWithWhereUniqueWithoutUserInput | OperateLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OperateLogCreateManyUserInputEnvelope
    set?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    disconnect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    delete?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    connect?: OperateLogWhereUniqueInput | OperateLogWhereUniqueInput[]
    update?: OperateLogUpdateWithWhereUniqueWithoutUserInput | OperateLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OperateLogUpdateManyWithWhereWithoutUserInput | OperateLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
  }

  export type UserInfoCreateNestedOneWithoutPersonaTemplatesInput = {
    create?: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutPersonaTemplatesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type FileSourceCreateNestedOneWithoutPersonaTemplatesInput = {
    create?: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutPersonaTemplatesInput
    connect?: FileSourceWhereUniqueInput
  }

  export type BotCreateNestedManyWithoutPersonaTemplateInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutPersonaTemplateInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type UserInfoUpdateOneWithoutPersonaTemplatesNestedInput = {
    create?: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutPersonaTemplatesInput
    upsert?: UserInfoUpsertWithoutPersonaTemplatesInput
    disconnect?: UserInfoWhereInput | boolean
    delete?: UserInfoWhereInput | boolean
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutPersonaTemplatesInput, UserInfoUpdateWithoutPersonaTemplatesInput>, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type FileSourceUpdateOneWithoutPersonaTemplatesNestedInput = {
    create?: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutPersonaTemplatesInput
    upsert?: FileSourceUpsertWithoutPersonaTemplatesInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutPersonaTemplatesInput, FileSourceUpdateWithoutPersonaTemplatesInput>, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type BotUpdateManyWithoutPersonaTemplateNestedInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutPersonaTemplateInput | BotUpsertWithWhereUniqueWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutPersonaTemplateInput | BotUpdateWithWhereUniqueWithoutPersonaTemplateInput[]
    updateMany?: BotUpdateManyWithWhereWithoutPersonaTemplateInput | BotUpdateManyWithWhereWithoutPersonaTemplateInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput = {
    create?: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput> | BotCreateWithoutPersonaTemplateInput[] | BotUncheckedCreateWithoutPersonaTemplateInput[]
    connectOrCreate?: BotCreateOrConnectWithoutPersonaTemplateInput | BotCreateOrConnectWithoutPersonaTemplateInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutPersonaTemplateInput | BotUpsertWithWhereUniqueWithoutPersonaTemplateInput[]
    createMany?: BotCreateManyPersonaTemplateInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutPersonaTemplateInput | BotUpdateWithWhereUniqueWithoutPersonaTemplateInput[]
    updateMany?: BotUpdateManyWithWhereWithoutPersonaTemplateInput | BotUpdateManyWithWhereWithoutPersonaTemplateInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type UserInfoCreateNestedOneWithoutWechatAuthInput = {
    create?: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutWechatAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutWechatAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutWechatAuthInput
    upsert?: UserInfoUpsertWithoutWechatAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutWechatAuthInput, UserInfoUpdateWithoutWechatAuthInput>, UserInfoUncheckedUpdateWithoutWechatAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutGoogleAuthInput = {
    create?: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutGoogleAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserInfoUpdateOneRequiredWithoutGoogleAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutGoogleAuthInput
    upsert?: UserInfoUpsertWithoutGoogleAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutGoogleAuthInput, UserInfoUpdateWithoutGoogleAuthInput>, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutDiscordAuthInput = {
    create?: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutDiscordAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutDiscordAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutDiscordAuthInput
    upsert?: UserInfoUpsertWithoutDiscordAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutDiscordAuthInput, UserInfoUpdateWithoutDiscordAuthInput>, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutMobileAuthInput = {
    create?: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutMobileAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutMobileAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutMobileAuthInput
    upsert?: UserInfoUpsertWithoutMobileAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutMobileAuthInput, UserInfoUpdateWithoutMobileAuthInput>, UserInfoUncheckedUpdateWithoutMobileAuthInput>
  }

  export type UserInfoCreateNestedOneWithoutEmailAuthInput = {
    create?: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutEmailAuthInput
    connect?: UserInfoWhereUniqueInput
  }

  export type UserInfoUpdateOneRequiredWithoutEmailAuthNestedInput = {
    create?: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutEmailAuthInput
    upsert?: UserInfoUpsertWithoutEmailAuthInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutEmailAuthInput, UserInfoUpdateWithoutEmailAuthInput>, UserInfoUncheckedUpdateWithoutEmailAuthInput>
  }

  export type EnumTaskTypeFieldUpdateOperationsInput = {
    set?: $Enums.TaskType
  }

  export type EnumTaskStatusFieldUpdateOperationsInput = {
    set?: $Enums.TaskStatus
  }

  export type FileSourceCreatepartsInput = {
    set: number[]
  }

  export type UserInfoCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
  }

  export type PersonaTemplateCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type BotCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
  }

  export type PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
  }

  export type BotUncheckedCreateNestedManyWithoutAvatarFileInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FileSourceUpdatepartsInput = {
    set?: number[]
    push?: number | number[]
  }

  export type EnumFileEnvTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileEnvType
  }

  export type EnumFileBucketVendorFieldUpdateOperationsInput = {
    set?: $Enums.FileBucketVendor
  }

  export type UserInfoUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    upsert?: UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput | UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    set?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    disconnect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    delete?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    update?: UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput | UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: UserInfoUpdateManyWithWhereWithoutAvatarFileInput | UserInfoUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
  }

  export type PersonaTemplateUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput | PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type BotUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutAvatarFileInput | BotUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutAvatarFileInput | BotUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: BotUpdateManyWithWhereWithoutAvatarFileInput | BotUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput> | UserInfoCreateWithoutAvatarFileInput[] | UserInfoUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: UserInfoCreateOrConnectWithoutAvatarFileInput | UserInfoCreateOrConnectWithoutAvatarFileInput[]
    upsert?: UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput | UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: UserInfoCreateManyAvatarFileInputEnvelope
    set?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    disconnect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    delete?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    connect?: UserInfoWhereUniqueInput | UserInfoWhereUniqueInput[]
    update?: UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput | UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: UserInfoUpdateManyWithWhereWithoutAvatarFileInput | UserInfoUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput> | PersonaTemplateCreateWithoutAvatarFileInput[] | PersonaTemplateUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutAvatarFileInput | PersonaTemplateCreateOrConnectWithoutAvatarFileInput[]
    upsert?: PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: PersonaTemplateCreateManyAvatarFileInputEnvelope
    set?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    disconnect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    delete?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    connect?: PersonaTemplateWhereUniqueInput | PersonaTemplateWhereUniqueInput[]
    update?: PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput | PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput | PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
  }

  export type BotUncheckedUpdateManyWithoutAvatarFileNestedInput = {
    create?: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput> | BotCreateWithoutAvatarFileInput[] | BotUncheckedCreateWithoutAvatarFileInput[]
    connectOrCreate?: BotCreateOrConnectWithoutAvatarFileInput | BotCreateOrConnectWithoutAvatarFileInput[]
    upsert?: BotUpsertWithWhereUniqueWithoutAvatarFileInput | BotUpsertWithWhereUniqueWithoutAvatarFileInput[]
    createMany?: BotCreateManyAvatarFileInputEnvelope
    set?: BotWhereUniqueInput | BotWhereUniqueInput[]
    disconnect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    delete?: BotWhereUniqueInput | BotWhereUniqueInput[]
    connect?: BotWhereUniqueInput | BotWhereUniqueInput[]
    update?: BotUpdateWithWhereUniqueWithoutAvatarFileInput | BotUpdateWithWhereUniqueWithoutAvatarFileInput[]
    updateMany?: BotUpdateManyWithWhereWithoutAvatarFileInput | BotUpdateManyWithWhereWithoutAvatarFileInput[]
    deleteMany?: BotScalarWhereInput | BotScalarWhereInput[]
  }

  export type BotCreatetagsInput = {
    set: string[]
  }

  export type UserInfoCreateNestedOneWithoutBotsInput = {
    create?: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutBotsInput
    connect?: UserInfoWhereUniqueInput
  }

  export type PersonaTemplateCreateNestedOneWithoutBotsInput = {
    create?: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutBotsInput
    connect?: PersonaTemplateWhereUniqueInput
  }

  export type FileSourceCreateNestedOneWithoutBotAvatarsInput = {
    create?: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutBotAvatarsInput
    connect?: FileSourceWhereUniqueInput
  }

  export type BotProviderKeyCreateNestedManyWithoutBotInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogCreateNestedManyWithoutBotInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenCreateNestedOneWithoutBotInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    connect?: ProxyTokenWhereUniqueInput
  }

  export type BotProviderKeyUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogUncheckedCreateNestedManyWithoutBotInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenUncheckedCreateNestedOneWithoutBotInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    connect?: ProxyTokenWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BotUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type EnumBotStatusFieldUpdateOperationsInput = {
    set?: $Enums.BotStatus
  }

  export type UserInfoUpdateOneRequiredWithoutBotsNestedInput = {
    create?: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutBotsInput
    upsert?: UserInfoUpsertWithoutBotsInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutBotsInput, UserInfoUpdateWithoutBotsInput>, UserInfoUncheckedUpdateWithoutBotsInput>
  }

  export type PersonaTemplateUpdateOneWithoutBotsNestedInput = {
    create?: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    connectOrCreate?: PersonaTemplateCreateOrConnectWithoutBotsInput
    upsert?: PersonaTemplateUpsertWithoutBotsInput
    disconnect?: PersonaTemplateWhereInput | boolean
    delete?: PersonaTemplateWhereInput | boolean
    connect?: PersonaTemplateWhereUniqueInput
    update?: XOR<XOR<PersonaTemplateUpdateToOneWithWhereWithoutBotsInput, PersonaTemplateUpdateWithoutBotsInput>, PersonaTemplateUncheckedUpdateWithoutBotsInput>
  }

  export type FileSourceUpdateOneWithoutBotAvatarsNestedInput = {
    create?: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    connectOrCreate?: FileSourceCreateOrConnectWithoutBotAvatarsInput
    upsert?: FileSourceUpsertWithoutBotAvatarsInput
    disconnect?: FileSourceWhereInput | boolean
    delete?: FileSourceWhereInput | boolean
    connect?: FileSourceWhereUniqueInput
    update?: XOR<XOR<FileSourceUpdateToOneWithWhereWithoutBotAvatarsInput, FileSourceUpdateWithoutBotAvatarsInput>, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
  }

  export type BotProviderKeyUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutBotInput | BotProviderKeyUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutBotInput | BotProviderKeyUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutBotInput | BotProviderKeyUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutBotInput | BotUsageLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutBotInput | BotUsageLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutBotInput | BotUsageLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUpdateOneWithoutBotNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    upsert?: ProxyTokenUpsertWithoutBotInput
    disconnect?: ProxyTokenWhereInput | boolean
    delete?: ProxyTokenWhereInput | boolean
    connect?: ProxyTokenWhereUniqueInput
    update?: XOR<XOR<ProxyTokenUpdateToOneWithWhereWithoutBotInput, ProxyTokenUpdateWithoutBotInput>, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput> | BotProviderKeyCreateWithoutBotInput[] | BotProviderKeyUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutBotInput | BotProviderKeyCreateOrConnectWithoutBotInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutBotInput | BotProviderKeyUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotProviderKeyCreateManyBotInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutBotInput | BotProviderKeyUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutBotInput | BotProviderKeyUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUncheckedUpdateManyWithoutBotNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput> | BotUsageLogCreateWithoutBotInput[] | BotUsageLogUncheckedCreateWithoutBotInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutBotInput | BotUsageLogCreateOrConnectWithoutBotInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutBotInput | BotUsageLogUpsertWithWhereUniqueWithoutBotInput[]
    createMany?: BotUsageLogCreateManyBotInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutBotInput | BotUsageLogUpdateWithWhereUniqueWithoutBotInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutBotInput | BotUsageLogUpdateManyWithWhereWithoutBotInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUncheckedUpdateOneWithoutBotNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutBotInput
    upsert?: ProxyTokenUpsertWithoutBotInput
    disconnect?: ProxyTokenWhereInput | boolean
    delete?: ProxyTokenWhereInput | boolean
    connect?: ProxyTokenWhereUniqueInput
    update?: XOR<XOR<ProxyTokenUpdateToOneWithWhereWithoutBotInput, ProxyTokenUpdateWithoutBotInput>, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type UserInfoCreateNestedOneWithoutProviderKeysInput = {
    create?: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutProviderKeysInput
    connect?: UserInfoWhereUniqueInput
  }

  export type BotProviderKeyCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
  }

  export type BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
  }

  export type BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
  }

  export type ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
  }

  export type BytesFieldUpdateOperationsInput = {
    set?: Bytes
  }

  export type UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput = {
    create?: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutProviderKeysInput
    upsert?: UserInfoUpsertWithoutProviderKeysInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutProviderKeysInput, UserInfoUpdateWithoutProviderKeysInput>, UserInfoUncheckedUpdateWithoutProviderKeysInput>
  }

  export type BotProviderKeyUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput | BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput | BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    upsert?: ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    set?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    disconnect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    delete?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    update?: ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput | ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput> | BotProviderKeyCreateWithoutProviderKeyInput[] | BotProviderKeyUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotProviderKeyCreateOrConnectWithoutProviderKeyInput | BotProviderKeyCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotProviderKeyCreateManyProviderKeyInputEnvelope
    set?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    disconnect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    delete?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    connect?: BotProviderKeyWhereUniqueInput | BotProviderKeyWhereUniqueInput[]
    update?: BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput | BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput | BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
  }

  export type BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput> | BotUsageLogCreateWithoutProviderKeyInput[] | BotUsageLogUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: BotUsageLogCreateOrConnectWithoutProviderKeyInput | BotUsageLogCreateOrConnectWithoutProviderKeyInput[]
    upsert?: BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: BotUsageLogCreateManyProviderKeyInputEnvelope
    set?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    disconnect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    delete?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    connect?: BotUsageLogWhereUniqueInput | BotUsageLogWhereUniqueInput[]
    update?: BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput | BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput | BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
  }

  export type ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput = {
    create?: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput> | ProxyTokenCreateWithoutProviderKeyInput[] | ProxyTokenUncheckedCreateWithoutProviderKeyInput[]
    connectOrCreate?: ProxyTokenCreateOrConnectWithoutProviderKeyInput | ProxyTokenCreateOrConnectWithoutProviderKeyInput[]
    upsert?: ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput[]
    createMany?: ProxyTokenCreateManyProviderKeyInputEnvelope
    set?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    disconnect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    delete?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    connect?: ProxyTokenWhereUniqueInput | ProxyTokenWhereUniqueInput[]
    update?: ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput | ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput[]
    updateMany?: ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput | ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput[]
    deleteMany?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
  }

  export type BotCreateNestedOneWithoutProviderKeysInput = {
    create?: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: BotCreateOrConnectWithoutProviderKeysInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutBotProviderKeysInput = {
    create?: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutBotProviderKeysInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type BotUpdateOneRequiredWithoutProviderKeysNestedInput = {
    create?: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    connectOrCreate?: BotCreateOrConnectWithoutProviderKeysInput
    upsert?: BotUpsertWithoutProviderKeysInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutProviderKeysInput, BotUpdateWithoutProviderKeysInput>, BotUncheckedUpdateWithoutProviderKeysInput>
  }

  export type ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutBotProviderKeysInput
    upsert?: ProviderKeyUpsertWithoutBotProviderKeysInput
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutBotProviderKeysInput, ProviderKeyUpdateWithoutBotProviderKeysInput>, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
  }

  export type BotCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUsageLogsInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutUsageLogsInput = {
    create?: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutUsageLogsInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type BotUpdateOneRequiredWithoutUsageLogsNestedInput = {
    create?: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: BotCreateOrConnectWithoutUsageLogsInput
    upsert?: BotUpsertWithoutUsageLogsInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutUsageLogsInput, BotUpdateWithoutUsageLogsInput>, BotUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProviderKeyUpdateOneWithoutUsageLogsNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutUsageLogsInput
    upsert?: ProviderKeyUpsertWithoutUsageLogsInput
    disconnect?: ProviderKeyWhereInput | boolean
    delete?: ProviderKeyWhereInput | boolean
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutUsageLogsInput, ProviderKeyUpdateWithoutUsageLogsInput>, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProxyTokenCreatetagsInput = {
    set: string[]
  }

  export type BotCreateNestedOneWithoutProxyTokenInput = {
    create?: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    connectOrCreate?: BotCreateOrConnectWithoutProxyTokenInput
    connect?: BotWhereUniqueInput
  }

  export type ProviderKeyCreateNestedOneWithoutProxyTokensInput = {
    create?: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutProxyTokensInput
    connect?: ProviderKeyWhereUniqueInput
  }

  export type ProxyTokenUpdatetagsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BotUpdateOneRequiredWithoutProxyTokenNestedInput = {
    create?: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    connectOrCreate?: BotCreateOrConnectWithoutProxyTokenInput
    upsert?: BotUpsertWithoutProxyTokenInput
    connect?: BotWhereUniqueInput
    update?: XOR<XOR<BotUpdateToOneWithWhereWithoutProxyTokenInput, BotUpdateWithoutProxyTokenInput>, BotUncheckedUpdateWithoutProxyTokenInput>
  }

  export type ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput = {
    create?: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    connectOrCreate?: ProviderKeyCreateOrConnectWithoutProxyTokensInput
    upsert?: ProviderKeyUpsertWithoutProxyTokensInput
    connect?: ProviderKeyWhereUniqueInput
    update?: XOR<XOR<ProviderKeyUpdateToOneWithWhereWithoutProxyTokensInput, ProviderKeyUpdateWithoutProxyTokensInput>, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
  }

  export type UserInfoCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutSentMessagesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type MessageRecipientCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type MessageRecipientUncheckedCreateNestedManyWithoutMessageInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
  }

  export type UserInfoUpdateOneWithoutSentMessagesNestedInput = {
    create?: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutSentMessagesInput
    upsert?: UserInfoUpsertWithoutSentMessagesInput
    disconnect?: UserInfoWhereInput | boolean
    delete?: UserInfoWhereInput | boolean
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutSentMessagesInput, UserInfoUpdateWithoutSentMessagesInput>, UserInfoUncheckedUpdateWithoutSentMessagesInput>
  }

  export type MessageRecipientUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutMessageInput | MessageRecipientUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutMessageInput | MessageRecipientUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutMessageInput | MessageRecipientUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput = {
    create?: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput> | MessageRecipientCreateWithoutMessageInput[] | MessageRecipientUncheckedCreateWithoutMessageInput[]
    connectOrCreate?: MessageRecipientCreateOrConnectWithoutMessageInput | MessageRecipientCreateOrConnectWithoutMessageInput[]
    upsert?: MessageRecipientUpsertWithWhereUniqueWithoutMessageInput | MessageRecipientUpsertWithWhereUniqueWithoutMessageInput[]
    createMany?: MessageRecipientCreateManyMessageInputEnvelope
    set?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    disconnect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    delete?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    connect?: MessageRecipientWhereUniqueInput | MessageRecipientWhereUniqueInput[]
    update?: MessageRecipientUpdateWithWhereUniqueWithoutMessageInput | MessageRecipientUpdateWithWhereUniqueWithoutMessageInput[]
    updateMany?: MessageRecipientUpdateManyWithWhereWithoutMessageInput | MessageRecipientUpdateManyWithWhereWithoutMessageInput[]
    deleteMany?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
  }

  export type MessageCreateNestedOneWithoutRecipientsInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
  }

  export type UserInfoCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserInfoWhereUniqueInput
  }

  export type MessageUpdateOneRequiredWithoutRecipientsNestedInput = {
    create?: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    connectOrCreate?: MessageCreateOrConnectWithoutRecipientsInput
    upsert?: MessageUpsertWithoutRecipientsInput
    connect?: MessageWhereUniqueInput
    update?: XOR<XOR<MessageUpdateToOneWithWhereWithoutRecipientsInput, MessageUpdateWithoutRecipientsInput>, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserInfoUpsertWithoutReceivedMessagesInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutReceivedMessagesInput, UserInfoUpdateWithoutReceivedMessagesInput>, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserInfoCreateNestedOneWithoutOperateLogsInput = {
    create?: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutOperateLogsInput
    connect?: UserInfoWhereUniqueInput
  }

  export type EnumOperateTypeFieldUpdateOperationsInput = {
    set?: $Enums.OperateType
  }

  export type EnumOperateTargetFieldUpdateOperationsInput = {
    set?: $Enums.OperateTarget
  }

  export type UserInfoUpdateOneRequiredWithoutOperateLogsNestedInput = {
    create?: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    connectOrCreate?: UserInfoCreateOrConnectWithoutOperateLogsInput
    upsert?: UserInfoUpsertWithoutOperateLogsInput
    connect?: UserInfoWhereUniqueInput
    update?: XOR<XOR<UserInfoUpdateToOneWithWhereWithoutOperateLogsInput, UserInfoUpdateWithoutOperateLogsInput>, UserInfoUncheckedUpdateWithoutOperateLogsInput>
  }

  export type ChannelCredentialFieldCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
  }

  export type ChannelCredentialFieldUncheckedCreateNestedManyWithoutChannelInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
  }

  export type ChannelCredentialFieldUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    set?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    disconnect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    delete?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    update?: ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput | ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
  }

  export type ChannelCredentialFieldUncheckedUpdateManyWithoutChannelNestedInput = {
    create?: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput> | ChannelCredentialFieldCreateWithoutChannelInput[] | ChannelCredentialFieldUncheckedCreateWithoutChannelInput[]
    connectOrCreate?: ChannelCredentialFieldCreateOrConnectWithoutChannelInput | ChannelCredentialFieldCreateOrConnectWithoutChannelInput[]
    upsert?: ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput[]
    createMany?: ChannelCredentialFieldCreateManyChannelInputEnvelope
    set?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    disconnect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    delete?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    connect?: ChannelCredentialFieldWhereUniqueInput | ChannelCredentialFieldWhereUniqueInput[]
    update?: ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput | ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput[]
    updateMany?: ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput | ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput[]
    deleteMany?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
  }

  export type ChannelDefinitionCreateNestedOneWithoutCredentialFieldsInput = {
    create?: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    connectOrCreate?: ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput
    connect?: ChannelDefinitionWhereUniqueInput
  }

  export type ChannelDefinitionUpdateOneRequiredWithoutCredentialFieldsNestedInput = {
    create?: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    connectOrCreate?: ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput
    upsert?: ChannelDefinitionUpsertWithoutCredentialFieldsInput
    connect?: ChannelDefinitionWhereUniqueInput
    update?: XOR<XOR<ChannelDefinitionUpdateToOneWithWhereWithoutCredentialFieldsInput, ChannelDefinitionUpdateWithoutCredentialFieldsInput>, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
  }

  export type NestedUuidFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidFilter<$PrismaModel> | string
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedUuidNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumSexTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeFilter<$PrismaModel> | $Enums.SexType
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedUuidWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedUuidNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedUuidNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedEnumSexTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SexType | EnumSexTypeFieldRefInput<$PrismaModel>
    in?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.SexType[] | ListEnumSexTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumSexTypeWithAggregatesFilter<$PrismaModel> | $Enums.SexType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSexTypeFilter<$PrismaModel>
    _max?: NestedEnumSexTypeFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTaskTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeFilter<$PrismaModel> | $Enums.TaskType
  }

  export type NestedEnumTaskStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusFilter<$PrismaModel> | $Enums.TaskStatus
  }

  export type NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskType | EnumTaskTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskType[] | ListEnumTaskTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskTypeWithAggregatesFilter<$PrismaModel> | $Enums.TaskType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskTypeFilter<$PrismaModel>
    _max?: NestedEnumTaskTypeFilter<$PrismaModel>
  }

  export type NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TaskStatus | EnumTaskStatusFieldRefInput<$PrismaModel>
    in?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.TaskStatus[] | ListEnumTaskStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumTaskStatusWithAggregatesFilter<$PrismaModel> | $Enums.TaskStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTaskStatusFilter<$PrismaModel>
    _max?: NestedEnumTaskStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileEnvTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeFilter<$PrismaModel> | $Enums.FileEnvType
  }

  export type NestedEnumFileBucketVendorFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorFilter<$PrismaModel> | $Enums.FileBucketVendor
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileEnvType | EnumFileEnvTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileEnvType[] | ListEnumFileEnvTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileEnvTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileEnvType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileEnvTypeFilter<$PrismaModel>
    _max?: NestedEnumFileEnvTypeFilter<$PrismaModel>
  }

  export type NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileBucketVendor | EnumFileBucketVendorFieldRefInput<$PrismaModel>
    in?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileBucketVendor[] | ListEnumFileBucketVendorFieldRefInput<$PrismaModel>
    not?: NestedEnumFileBucketVendorWithAggregatesFilter<$PrismaModel> | $Enums.FileBucketVendor
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileBucketVendorFilter<$PrismaModel>
    _max?: NestedEnumFileBucketVendorFilter<$PrismaModel>
  }

  export type NestedEnumBotStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusFilter<$PrismaModel> | $Enums.BotStatus
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumBotStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.BotStatus | EnumBotStatusFieldRefInput<$PrismaModel>
    in?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.BotStatus[] | ListEnumBotStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumBotStatusWithAggregatesFilter<$PrismaModel> | $Enums.BotStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumBotStatusFilter<$PrismaModel>
    _max?: NestedEnumBotStatusFilter<$PrismaModel>
  }

  export type NestedBytesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesFilter<$PrismaModel> | Bytes
  }

  export type NestedBytesWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Bytes | BytesFieldRefInput<$PrismaModel>
    in?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    notIn?: Bytes[] | ListBytesFieldRefInput<$PrismaModel>
    not?: NestedBytesWithAggregatesFilter<$PrismaModel> | Bytes
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBytesFilter<$PrismaModel>
    _max?: NestedBytesFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumOperateTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeFilter<$PrismaModel> | $Enums.OperateType
  }

  export type NestedEnumOperateTargetFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetFilter<$PrismaModel> | $Enums.OperateTarget
  }

  export type NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateType | EnumOperateTypeFieldRefInput<$PrismaModel>
    in?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateType[] | ListEnumOperateTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTypeWithAggregatesFilter<$PrismaModel> | $Enums.OperateType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTypeFilter<$PrismaModel>
    _max?: NestedEnumOperateTypeFilter<$PrismaModel>
  }

  export type NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.OperateTarget | EnumOperateTargetFieldRefInput<$PrismaModel>
    in?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    notIn?: $Enums.OperateTarget[] | ListEnumOperateTargetFieldRefInput<$PrismaModel>
    not?: NestedEnumOperateTargetWithAggregatesFilter<$PrismaModel> | $Enums.OperateTarget
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumOperateTargetFilter<$PrismaModel>
    _max?: NestedEnumOperateTargetFilter<$PrismaModel>
  }

  export type FileSourceCreateWithoutUserAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutUserAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutUserAvatarsInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
  }

  export type WechatAuthCreateWithoutUserInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthUncheckedCreateWithoutUserInput = {
    sessionKey?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type WechatAuthCreateOrConnectWithoutUserInput = {
    where: WechatAuthWhereUniqueInput
    create: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
  }

  export type GoogleAuthCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthUncheckedCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    atHash?: string | null
    name?: string | null
    picture?: string | null
    givenName?: string | null
    familyName?: string | null
    exp: number
    iat: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type GoogleAuthCreateOrConnectWithoutUserInput = {
    where: GoogleAuthWhereUniqueInput
    create: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
  }

  export type DiscordAuthCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthUncheckedCreateWithoutUserInput = {
    email: string
    verifiedEmail?: boolean
    name?: string | null
    accessToken?: string | null
    refreshToken?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type DiscordAuthCreateOrConnectWithoutUserInput = {
    where: DiscordAuthWhereUniqueInput
    create: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
  }

  export type MobileAuthCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthUncheckedCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type MobileAuthCreateOrConnectWithoutUserInput = {
    where: MobileAuthWhereUniqueInput
    create: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
  }

  export type EmailAuthCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthUncheckedCreateWithoutUserInput = {
    password: string
    verified?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type EmailAuthCreateOrConnectWithoutUserInput = {
    where: EmailAuthWhereUniqueInput
    create: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientCreateNestedManyWithoutMessageInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    recipients?: MessageRecipientUncheckedCreateNestedManyWithoutMessageInput
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageRecipientCreateWithoutUserInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    message: MessageCreateNestedOneWithoutRecipientsInput
  }

  export type MessageRecipientUncheckedCreateWithoutUserInput = {
    id?: string
    messageId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateOrConnectWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    create: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput>
  }

  export type MessageRecipientCreateManyUserInputEnvelope = {
    data: MessageRecipientCreateManyUserInput | MessageRecipientCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type BotCreateWithoutCreatedByInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput>
  }

  export type BotCreateManyCreatedByInputEnvelope = {
    data: BotCreateManyCreatedByInput | BotCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ProviderKeyCreateWithoutCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput>
  }

  export type ProviderKeyCreateManyCreatedByInputEnvelope = {
    data: ProviderKeyCreateManyCreatedByInput | ProviderKeyCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type PersonaTemplateCreateWithoutCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateCreateOrConnectWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type PersonaTemplateCreateManyCreatedByInputEnvelope = {
    data: PersonaTemplateCreateManyCreatedByInput | PersonaTemplateCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type OperateLogCreateWithoutUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogUncheckedCreateWithoutUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type OperateLogCreateOrConnectWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    create: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput>
  }

  export type OperateLogCreateManyUserInputEnvelope = {
    data: OperateLogCreateManyUserInput | OperateLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileSourceUpsertWithoutUserAvatarsInput = {
    update: XOR<FileSourceUpdateWithoutUserAvatarsInput, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
    create: XOR<FileSourceCreateWithoutUserAvatarsInput, FileSourceUncheckedCreateWithoutUserAvatarsInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutUserAvatarsInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutUserAvatarsInput, FileSourceUncheckedUpdateWithoutUserAvatarsInput>
  }

  export type FileSourceUpdateWithoutUserAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutUserAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type WechatAuthUpsertWithoutUserInput = {
    update: XOR<WechatAuthUpdateWithoutUserInput, WechatAuthUncheckedUpdateWithoutUserInput>
    create: XOR<WechatAuthCreateWithoutUserInput, WechatAuthUncheckedCreateWithoutUserInput>
    where?: WechatAuthWhereInput
  }

  export type WechatAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: WechatAuthWhereInput
    data: XOR<WechatAuthUpdateWithoutUserInput, WechatAuthUncheckedUpdateWithoutUserInput>
  }

  export type WechatAuthUpdateWithoutUserInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type WechatAuthUncheckedUpdateWithoutUserInput = {
    sessionKey?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUpsertWithoutUserInput = {
    update: XOR<GoogleAuthUpdateWithoutUserInput, GoogleAuthUncheckedUpdateWithoutUserInput>
    create: XOR<GoogleAuthCreateWithoutUserInput, GoogleAuthUncheckedCreateWithoutUserInput>
    where?: GoogleAuthWhereInput
  }

  export type GoogleAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: GoogleAuthWhereInput
    data: XOR<GoogleAuthUpdateWithoutUserInput, GoogleAuthUncheckedUpdateWithoutUserInput>
  }

  export type GoogleAuthUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type GoogleAuthUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    atHash?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    picture?: NullableStringFieldUpdateOperationsInput | string | null
    givenName?: NullableStringFieldUpdateOperationsInput | string | null
    familyName?: NullableStringFieldUpdateOperationsInput | string | null
    exp?: IntFieldUpdateOperationsInput | number
    iat?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUpsertWithoutUserInput = {
    update: XOR<DiscordAuthUpdateWithoutUserInput, DiscordAuthUncheckedUpdateWithoutUserInput>
    create: XOR<DiscordAuthCreateWithoutUserInput, DiscordAuthUncheckedCreateWithoutUserInput>
    where?: DiscordAuthWhereInput
  }

  export type DiscordAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: DiscordAuthWhereInput
    data: XOR<DiscordAuthUpdateWithoutUserInput, DiscordAuthUncheckedUpdateWithoutUserInput>
  }

  export type DiscordAuthUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DiscordAuthUncheckedUpdateWithoutUserInput = {
    email?: StringFieldUpdateOperationsInput | string
    verifiedEmail?: BoolFieldUpdateOperationsInput | boolean
    name?: NullableStringFieldUpdateOperationsInput | string | null
    accessToken?: NullableStringFieldUpdateOperationsInput | string | null
    refreshToken?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUpsertWithoutUserInput = {
    update: XOR<MobileAuthUpdateWithoutUserInput, MobileAuthUncheckedUpdateWithoutUserInput>
    create: XOR<MobileAuthCreateWithoutUserInput, MobileAuthUncheckedCreateWithoutUserInput>
    where?: MobileAuthWhereInput
  }

  export type MobileAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: MobileAuthWhereInput
    data: XOR<MobileAuthUpdateWithoutUserInput, MobileAuthUncheckedUpdateWithoutUserInput>
  }

  export type MobileAuthUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MobileAuthUncheckedUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUpsertWithoutUserInput = {
    update: XOR<EmailAuthUpdateWithoutUserInput, EmailAuthUncheckedUpdateWithoutUserInput>
    create: XOR<EmailAuthCreateWithoutUserInput, EmailAuthUncheckedCreateWithoutUserInput>
    where?: EmailAuthWhereInput
  }

  export type EmailAuthUpdateToOneWithWhereWithoutUserInput = {
    where?: EmailAuthWhereInput
    data: XOR<EmailAuthUpdateWithoutUserInput, EmailAuthUncheckedUpdateWithoutUserInput>
  }

  export type EmailAuthUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailAuthUncheckedUpdateWithoutUserInput = {
    password?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: UuidFilter<"Message"> | string
    type?: StringFilter<"Message"> | string
    title?: StringNullableFilter<"Message"> | string | null
    content?: JsonFilter<"Message">
    senderId?: UuidNullableFilter<"Message"> | string | null
    metadata?: JsonNullableFilter<"Message">
    createdAt?: DateTimeFilter<"Message"> | Date | string
    updatedAt?: DateTimeFilter<"Message"> | Date | string
    isDeleted?: BoolFilter<"Message"> | boolean
    deletedAt?: DateTimeNullableFilter<"Message"> | Date | string | null
  }

  export type MessageRecipientUpsertWithWhereUniqueWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    update: XOR<MessageRecipientUpdateWithoutUserInput, MessageRecipientUncheckedUpdateWithoutUserInput>
    create: XOR<MessageRecipientCreateWithoutUserInput, MessageRecipientUncheckedCreateWithoutUserInput>
  }

  export type MessageRecipientUpdateWithWhereUniqueWithoutUserInput = {
    where: MessageRecipientWhereUniqueInput
    data: XOR<MessageRecipientUpdateWithoutUserInput, MessageRecipientUncheckedUpdateWithoutUserInput>
  }

  export type MessageRecipientUpdateManyWithWhereWithoutUserInput = {
    where: MessageRecipientScalarWhereInput
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyWithoutUserInput>
  }

  export type MessageRecipientScalarWhereInput = {
    AND?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
    OR?: MessageRecipientScalarWhereInput[]
    NOT?: MessageRecipientScalarWhereInput | MessageRecipientScalarWhereInput[]
    id?: UuidFilter<"MessageRecipient"> | string
    messageId?: UuidFilter<"MessageRecipient"> | string
    userId?: UuidFilter<"MessageRecipient"> | string
    isRead?: BoolFilter<"MessageRecipient"> | boolean
    readAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
    createdAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    updatedAt?: DateTimeFilter<"MessageRecipient"> | Date | string
    isDeleted?: BoolFilter<"MessageRecipient"> | boolean
    deletedAt?: DateTimeNullableFilter<"MessageRecipient"> | Date | string | null
  }

  export type BotUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutCreatedByInput, BotUncheckedUpdateWithoutCreatedByInput>
    create: XOR<BotCreateWithoutCreatedByInput, BotUncheckedCreateWithoutCreatedByInput>
  }

  export type BotUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutCreatedByInput, BotUncheckedUpdateWithoutCreatedByInput>
  }

  export type BotUpdateManyWithWhereWithoutCreatedByInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type BotScalarWhereInput = {
    AND?: BotScalarWhereInput | BotScalarWhereInput[]
    OR?: BotScalarWhereInput[]
    NOT?: BotScalarWhereInput | BotScalarWhereInput[]
    id?: UuidFilter<"Bot"> | string
    name?: StringFilter<"Bot"> | string
    hostname?: StringFilter<"Bot"> | string
    aiProvider?: StringFilter<"Bot"> | string
    model?: StringFilter<"Bot"> | string
    channelType?: StringFilter<"Bot"> | string
    containerId?: StringNullableFilter<"Bot"> | string | null
    port?: IntNullableFilter<"Bot"> | number | null
    gatewayToken?: StringNullableFilter<"Bot"> | string | null
    proxyTokenHash?: StringNullableFilter<"Bot"> | string | null
    tags?: StringNullableListFilter<"Bot">
    status?: EnumBotStatusFilter<"Bot"> | $Enums.BotStatus
    createdById?: UuidFilter<"Bot"> | string
    personaTemplateId?: UuidNullableFilter<"Bot"> | string | null
    emoji?: StringNullableFilter<"Bot"> | string | null
    avatarFileId?: UuidNullableFilter<"Bot"> | string | null
    soulMarkdown?: StringNullableFilter<"Bot"> | string | null
    isDeleted?: BoolFilter<"Bot"> | boolean
    createdAt?: DateTimeFilter<"Bot"> | Date | string
    updatedAt?: DateTimeFilter<"Bot"> | Date | string
    deletedAt?: DateTimeNullableFilter<"Bot"> | Date | string | null
  }

  export type ProviderKeyUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    update: XOR<ProviderKeyUpdateWithoutCreatedByInput, ProviderKeyUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ProviderKeyCreateWithoutCreatedByInput, ProviderKeyUncheckedCreateWithoutCreatedByInput>
  }

  export type ProviderKeyUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ProviderKeyWhereUniqueInput
    data: XOR<ProviderKeyUpdateWithoutCreatedByInput, ProviderKeyUncheckedUpdateWithoutCreatedByInput>
  }

  export type ProviderKeyUpdateManyWithWhereWithoutCreatedByInput = {
    where: ProviderKeyScalarWhereInput
    data: XOR<ProviderKeyUpdateManyMutationInput, ProviderKeyUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ProviderKeyScalarWhereInput = {
    AND?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
    OR?: ProviderKeyScalarWhereInput[]
    NOT?: ProviderKeyScalarWhereInput | ProviderKeyScalarWhereInput[]
    id?: UuidFilter<"ProviderKey"> | string
    vendor?: StringFilter<"ProviderKey"> | string
    apiType?: StringNullableFilter<"ProviderKey"> | string | null
    secretEncrypted?: BytesFilter<"ProviderKey"> | Bytes
    label?: StringFilter<"ProviderKey"> | string
    tag?: StringNullableFilter<"ProviderKey"> | string | null
    baseUrl?: StringNullableFilter<"ProviderKey"> | string | null
    createdById?: UuidFilter<"ProviderKey"> | string
    isDeleted?: BoolFilter<"ProviderKey"> | boolean
    createdAt?: DateTimeFilter<"ProviderKey"> | Date | string
    updatedAt?: DateTimeFilter<"ProviderKey"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ProviderKey"> | Date | string | null
  }

  export type PersonaTemplateUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    update: XOR<PersonaTemplateUpdateWithoutCreatedByInput, PersonaTemplateUncheckedUpdateWithoutCreatedByInput>
    create: XOR<PersonaTemplateCreateWithoutCreatedByInput, PersonaTemplateUncheckedCreateWithoutCreatedByInput>
  }

  export type PersonaTemplateUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: PersonaTemplateWhereUniqueInput
    data: XOR<PersonaTemplateUpdateWithoutCreatedByInput, PersonaTemplateUncheckedUpdateWithoutCreatedByInput>
  }

  export type PersonaTemplateUpdateManyWithWhereWithoutCreatedByInput = {
    where: PersonaTemplateScalarWhereInput
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type PersonaTemplateScalarWhereInput = {
    AND?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
    OR?: PersonaTemplateScalarWhereInput[]
    NOT?: PersonaTemplateScalarWhereInput | PersonaTemplateScalarWhereInput[]
    id?: UuidFilter<"PersonaTemplate"> | string
    name?: StringFilter<"PersonaTemplate"> | string
    emoji?: StringNullableFilter<"PersonaTemplate"> | string | null
    avatarFileId?: UuidNullableFilter<"PersonaTemplate"> | string | null
    tagline?: StringFilter<"PersonaTemplate"> | string
    soulMarkdown?: StringFilter<"PersonaTemplate"> | string
    soulPreview?: StringNullableFilter<"PersonaTemplate"> | string | null
    isSystem?: BoolFilter<"PersonaTemplate"> | boolean
    createdById?: UuidNullableFilter<"PersonaTemplate"> | string | null
    isDeleted?: BoolFilter<"PersonaTemplate"> | boolean
    createdAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    updatedAt?: DateTimeFilter<"PersonaTemplate"> | Date | string
    deletedAt?: DateTimeNullableFilter<"PersonaTemplate"> | Date | string | null
  }

  export type OperateLogUpsertWithWhereUniqueWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    update: XOR<OperateLogUpdateWithoutUserInput, OperateLogUncheckedUpdateWithoutUserInput>
    create: XOR<OperateLogCreateWithoutUserInput, OperateLogUncheckedCreateWithoutUserInput>
  }

  export type OperateLogUpdateWithWhereUniqueWithoutUserInput = {
    where: OperateLogWhereUniqueInput
    data: XOR<OperateLogUpdateWithoutUserInput, OperateLogUncheckedUpdateWithoutUserInput>
  }

  export type OperateLogUpdateManyWithWhereWithoutUserInput = {
    where: OperateLogScalarWhereInput
    data: XOR<OperateLogUpdateManyMutationInput, OperateLogUncheckedUpdateManyWithoutUserInput>
  }

  export type OperateLogScalarWhereInput = {
    AND?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
    OR?: OperateLogScalarWhereInput[]
    NOT?: OperateLogScalarWhereInput | OperateLogScalarWhereInput[]
    id?: UuidFilter<"OperateLog"> | string
    userId?: UuidFilter<"OperateLog"> | string
    operateType?: EnumOperateTypeFilter<"OperateLog"> | $Enums.OperateType
    target?: EnumOperateTargetFilter<"OperateLog"> | $Enums.OperateTarget
    targetId?: UuidNullableFilter<"OperateLog"> | string | null
    targetName?: StringNullableFilter<"OperateLog"> | string | null
    detail?: JsonNullableFilter<"OperateLog">
    ipAddress?: StringNullableFilter<"OperateLog"> | string | null
    userAgent?: StringNullableFilter<"OperateLog"> | string | null
    createdAt?: DateTimeFilter<"OperateLog"> | Date | string
  }

  export type UserInfoCreateWithoutPersonaTemplatesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutPersonaTemplatesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutPersonaTemplatesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
  }

  export type FileSourceCreateWithoutPersonaTemplatesInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutPersonaTemplatesInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    botAvatars?: BotUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutPersonaTemplatesInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
  }

  export type BotCreateWithoutPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput>
  }

  export type BotCreateManyPersonaTemplateInputEnvelope = {
    data: BotCreateManyPersonaTemplateInput | BotCreateManyPersonaTemplateInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutPersonaTemplatesInput = {
    update: XOR<UserInfoUpdateWithoutPersonaTemplatesInput, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
    create: XOR<UserInfoCreateWithoutPersonaTemplatesInput, UserInfoUncheckedCreateWithoutPersonaTemplatesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutPersonaTemplatesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutPersonaTemplatesInput, UserInfoUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type UserInfoUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type FileSourceUpsertWithoutPersonaTemplatesInput = {
    update: XOR<FileSourceUpdateWithoutPersonaTemplatesInput, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
    create: XOR<FileSourceCreateWithoutPersonaTemplatesInput, FileSourceUncheckedCreateWithoutPersonaTemplatesInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutPersonaTemplatesInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutPersonaTemplatesInput, FileSourceUncheckedUpdateWithoutPersonaTemplatesInput>
  }

  export type FileSourceUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutPersonaTemplatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    botAvatars?: BotUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type BotUpsertWithWhereUniqueWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutPersonaTemplateInput, BotUncheckedUpdateWithoutPersonaTemplateInput>
    create: XOR<BotCreateWithoutPersonaTemplateInput, BotUncheckedCreateWithoutPersonaTemplateInput>
  }

  export type BotUpdateWithWhereUniqueWithoutPersonaTemplateInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutPersonaTemplateInput, BotUncheckedUpdateWithoutPersonaTemplateInput>
  }

  export type BotUpdateManyWithWhereWithoutPersonaTemplateInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutPersonaTemplateInput>
  }

  export type UserInfoCreateWithoutWechatAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutWechatAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutWechatAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
  }

  export type UserInfoUpsertWithoutWechatAuthInput = {
    update: XOR<UserInfoUpdateWithoutWechatAuthInput, UserInfoUncheckedUpdateWithoutWechatAuthInput>
    create: XOR<UserInfoCreateWithoutWechatAuthInput, UserInfoUncheckedCreateWithoutWechatAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutWechatAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutWechatAuthInput, UserInfoUncheckedUpdateWithoutWechatAuthInput>
  }

  export type UserInfoUpdateWithoutWechatAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutWechatAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutGoogleAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutGoogleAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutGoogleAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
  }

  export type UserInfoUpsertWithoutGoogleAuthInput = {
    update: XOR<UserInfoUpdateWithoutGoogleAuthInput, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
    create: XOR<UserInfoCreateWithoutGoogleAuthInput, UserInfoUncheckedCreateWithoutGoogleAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutGoogleAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutGoogleAuthInput, UserInfoUncheckedUpdateWithoutGoogleAuthInput>
  }

  export type UserInfoUpdateWithoutGoogleAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutGoogleAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutDiscordAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutDiscordAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutDiscordAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
  }

  export type UserInfoUpsertWithoutDiscordAuthInput = {
    update: XOR<UserInfoUpdateWithoutDiscordAuthInput, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
    create: XOR<UserInfoCreateWithoutDiscordAuthInput, UserInfoUncheckedCreateWithoutDiscordAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutDiscordAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutDiscordAuthInput, UserInfoUncheckedUpdateWithoutDiscordAuthInput>
  }

  export type UserInfoUpdateWithoutDiscordAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutDiscordAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutMobileAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutMobileAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutMobileAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
  }

  export type UserInfoUpsertWithoutMobileAuthInput = {
    update: XOR<UserInfoUpdateWithoutMobileAuthInput, UserInfoUncheckedUpdateWithoutMobileAuthInput>
    create: XOR<UserInfoCreateWithoutMobileAuthInput, UserInfoUncheckedCreateWithoutMobileAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutMobileAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutMobileAuthInput, UserInfoUncheckedUpdateWithoutMobileAuthInput>
  }

  export type UserInfoUpdateWithoutMobileAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutMobileAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutEmailAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutEmailAuthInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutEmailAuthInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
  }

  export type UserInfoUpsertWithoutEmailAuthInput = {
    update: XOR<UserInfoUpdateWithoutEmailAuthInput, UserInfoUncheckedUpdateWithoutEmailAuthInput>
    create: XOR<UserInfoCreateWithoutEmailAuthInput, UserInfoUncheckedCreateWithoutEmailAuthInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutEmailAuthInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutEmailAuthInput, UserInfoUncheckedUpdateWithoutEmailAuthInput>
  }

  export type UserInfoUpdateWithoutEmailAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutEmailAuthInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput>
  }

  export type UserInfoCreateManyAvatarFileInputEnvelope = {
    data: UserInfoCreateManyAvatarFileInput | UserInfoCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type PersonaTemplateCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    bots?: BotCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    bots?: BotUncheckedCreateNestedManyWithoutPersonaTemplateInput
  }

  export type PersonaTemplateCreateOrConnectWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput>
  }

  export type PersonaTemplateCreateManyAvatarFileInputEnvelope = {
    data: PersonaTemplateCreateManyAvatarFileInput | PersonaTemplateCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type BotCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput>
  }

  export type BotCreateManyAvatarFileInputEnvelope = {
    data: BotCreateManyAvatarFileInput | BotCreateManyAvatarFileInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    update: XOR<UserInfoUpdateWithoutAvatarFileInput, UserInfoUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<UserInfoCreateWithoutAvatarFileInput, UserInfoUncheckedCreateWithoutAvatarFileInput>
  }

  export type UserInfoUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: UserInfoWhereUniqueInput
    data: XOR<UserInfoUpdateWithoutAvatarFileInput, UserInfoUncheckedUpdateWithoutAvatarFileInput>
  }

  export type UserInfoUpdateManyWithWhereWithoutAvatarFileInput = {
    where: UserInfoScalarWhereInput
    data: XOR<UserInfoUpdateManyMutationInput, UserInfoUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type UserInfoScalarWhereInput = {
    AND?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
    OR?: UserInfoScalarWhereInput[]
    NOT?: UserInfoScalarWhereInput | UserInfoScalarWhereInput[]
    id?: UuidFilter<"UserInfo"> | string
    nickname?: StringFilter<"UserInfo"> | string
    code?: StringNullableFilter<"UserInfo"> | string | null
    avatarFileId?: UuidNullableFilter<"UserInfo"> | string | null
    sex?: EnumSexTypeFilter<"UserInfo"> | $Enums.SexType
    locale?: StringNullableFilter<"UserInfo"> | string | null
    isAnonymity?: BoolFilter<"UserInfo"> | boolean
    isAdmin?: BoolFilter<"UserInfo"> | boolean
    isDeleted?: BoolFilter<"UserInfo"> | boolean
    createdAt?: DateTimeFilter<"UserInfo"> | Date | string
    updatedAt?: DateTimeFilter<"UserInfo"> | Date | string
    deletedAt?: DateTimeNullableFilter<"UserInfo"> | Date | string | null
    deviceId?: StringNullableFilter<"UserInfo"> | string | null
    wechatOpenid?: StringNullableFilter<"UserInfo"> | string | null
    wechatUnionId?: StringNullableFilter<"UserInfo"> | string | null
    googleSub?: StringNullableFilter<"UserInfo"> | string | null
    discordId?: StringNullableFilter<"UserInfo"> | string | null
    mobile?: StringNullableFilter<"UserInfo"> | string | null
    email?: StringNullableFilter<"UserInfo"> | string | null
  }

  export type PersonaTemplateUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    update: XOR<PersonaTemplateUpdateWithoutAvatarFileInput, PersonaTemplateUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<PersonaTemplateCreateWithoutAvatarFileInput, PersonaTemplateUncheckedCreateWithoutAvatarFileInput>
  }

  export type PersonaTemplateUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: PersonaTemplateWhereUniqueInput
    data: XOR<PersonaTemplateUpdateWithoutAvatarFileInput, PersonaTemplateUncheckedUpdateWithoutAvatarFileInput>
  }

  export type PersonaTemplateUpdateManyWithWhereWithoutAvatarFileInput = {
    where: PersonaTemplateScalarWhereInput
    data: XOR<PersonaTemplateUpdateManyMutationInput, PersonaTemplateUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type BotUpsertWithWhereUniqueWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    update: XOR<BotUpdateWithoutAvatarFileInput, BotUncheckedUpdateWithoutAvatarFileInput>
    create: XOR<BotCreateWithoutAvatarFileInput, BotUncheckedCreateWithoutAvatarFileInput>
  }

  export type BotUpdateWithWhereUniqueWithoutAvatarFileInput = {
    where: BotWhereUniqueInput
    data: XOR<BotUpdateWithoutAvatarFileInput, BotUncheckedUpdateWithoutAvatarFileInput>
  }

  export type BotUpdateManyWithWhereWithoutAvatarFileInput = {
    where: BotScalarWhereInput
    data: XOR<BotUpdateManyMutationInput, BotUncheckedUpdateManyWithoutAvatarFileInput>
  }

  export type UserInfoCreateWithoutBotsInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutBotsInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutBotsInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
  }

  export type PersonaTemplateCreateWithoutBotsInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy?: UserInfoCreateNestedOneWithoutPersonaTemplatesInput
    avatarFile?: FileSourceCreateNestedOneWithoutPersonaTemplatesInput
  }

  export type PersonaTemplateUncheckedCreateWithoutBotsInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateCreateOrConnectWithoutBotsInput = {
    where: PersonaTemplateWhereUniqueInput
    create: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
  }

  export type FileSourceCreateWithoutBotAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceUncheckedCreateWithoutBotAvatarsInput = {
    id?: string
    isUploaded?: boolean
    bucket: string
    key: string
    hash?: string | null
    thumbImg?: string | null
    fsize?: number
    mimeType?: string
    type?: number
    endUser?: string | null
    status?: number
    sha256?: string | null
    parts?: FileSourceCreatepartsInput | number[]
    ext?: string
    expireAt?: Date | string | null
    transitionToIaAt?: Date | string | null
    transitionToArchiveAt?: Date | string | null
    transitionToDeepArchiveAt?: Date | string | null
    transitionToArchiveIRAt?: Date | string | null
    env?: $Enums.FileEnvType
    vendor?: $Enums.FileBucketVendor
    region?: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    userAvatars?: UserInfoUncheckedCreateNestedManyWithoutAvatarFileInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutAvatarFileInput
  }

  export type FileSourceCreateOrConnectWithoutBotAvatarsInput = {
    where: FileSourceWhereUniqueInput
    create: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
  }

  export type BotProviderKeyCreateWithoutBotInput = {
    id?: string
    isPrimary?: boolean
    createdAt?: Date | string
    providerKey: ProviderKeyCreateNestedOneWithoutBotProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateWithoutBotInput = {
    id?: string
    providerKeyId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotProviderKeyCreateOrConnectWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    create: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput>
  }

  export type BotProviderKeyCreateManyBotInputEnvelope = {
    data: BotProviderKeyCreateManyBotInput | BotProviderKeyCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type BotUsageLogCreateWithoutBotInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    providerKey?: ProviderKeyCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateWithoutBotInput = {
    id?: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type BotUsageLogCreateOrConnectWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    create: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput>
  }

  export type BotUsageLogCreateManyBotInputEnvelope = {
    data: BotUsageLogCreateManyBotInput | BotUsageLogCreateManyBotInput[]
    skipDuplicates?: boolean
  }

  export type ProxyTokenCreateWithoutBotInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    providerKey: ProviderKeyCreateNestedOneWithoutProxyTokensInput
  }

  export type ProxyTokenUncheckedCreateWithoutBotInput = {
    id?: string
    tokenHash: string
    vendor: string
    keyId: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenCreateOrConnectWithoutBotInput = {
    where: ProxyTokenWhereUniqueInput
    create: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
  }

  export type UserInfoUpsertWithoutBotsInput = {
    update: XOR<UserInfoUpdateWithoutBotsInput, UserInfoUncheckedUpdateWithoutBotsInput>
    create: XOR<UserInfoCreateWithoutBotsInput, UserInfoUncheckedCreateWithoutBotsInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutBotsInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutBotsInput, UserInfoUncheckedUpdateWithoutBotsInput>
  }

  export type UserInfoUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type PersonaTemplateUpsertWithoutBotsInput = {
    update: XOR<PersonaTemplateUpdateWithoutBotsInput, PersonaTemplateUncheckedUpdateWithoutBotsInput>
    create: XOR<PersonaTemplateCreateWithoutBotsInput, PersonaTemplateUncheckedCreateWithoutBotsInput>
    where?: PersonaTemplateWhereInput
  }

  export type PersonaTemplateUpdateToOneWithWhereWithoutBotsInput = {
    where?: PersonaTemplateWhereInput
    data: XOR<PersonaTemplateUpdateWithoutBotsInput, PersonaTemplateUncheckedUpdateWithoutBotsInput>
  }

  export type PersonaTemplateUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutBotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type FileSourceUpsertWithoutBotAvatarsInput = {
    update: XOR<FileSourceUpdateWithoutBotAvatarsInput, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
    create: XOR<FileSourceCreateWithoutBotAvatarsInput, FileSourceUncheckedCreateWithoutBotAvatarsInput>
    where?: FileSourceWhereInput
  }

  export type FileSourceUpdateToOneWithWhereWithoutBotAvatarsInput = {
    where?: FileSourceWhereInput
    data: XOR<FileSourceUpdateWithoutBotAvatarsInput, FileSourceUncheckedUpdateWithoutBotAvatarsInput>
  }

  export type FileSourceUpdateWithoutBotAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutAvatarFileNestedInput
  }

  export type FileSourceUncheckedUpdateWithoutBotAvatarsInput = {
    id?: StringFieldUpdateOperationsInput | string
    isUploaded?: BoolFieldUpdateOperationsInput | boolean
    bucket?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    hash?: NullableStringFieldUpdateOperationsInput | string | null
    thumbImg?: NullableStringFieldUpdateOperationsInput | string | null
    fsize?: FloatFieldUpdateOperationsInput | number
    mimeType?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    endUser?: NullableStringFieldUpdateOperationsInput | string | null
    status?: IntFieldUpdateOperationsInput | number
    sha256?: NullableStringFieldUpdateOperationsInput | string | null
    parts?: FileSourceUpdatepartsInput | number[]
    ext?: StringFieldUpdateOperationsInput | string
    expireAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToIaAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToDeepArchiveAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    transitionToArchiveIRAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    env?: EnumFileEnvTypeFieldUpdateOperationsInput | $Enums.FileEnvType
    vendor?: EnumFileBucketVendorFieldUpdateOperationsInput | $Enums.FileBucketVendor
    region?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userAvatars?: UserInfoUncheckedUpdateManyWithoutAvatarFileNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutAvatarFileNestedInput
  }

  export type BotProviderKeyUpsertWithWhereUniqueWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    update: XOR<BotProviderKeyUpdateWithoutBotInput, BotProviderKeyUncheckedUpdateWithoutBotInput>
    create: XOR<BotProviderKeyCreateWithoutBotInput, BotProviderKeyUncheckedCreateWithoutBotInput>
  }

  export type BotProviderKeyUpdateWithWhereUniqueWithoutBotInput = {
    where: BotProviderKeyWhereUniqueInput
    data: XOR<BotProviderKeyUpdateWithoutBotInput, BotProviderKeyUncheckedUpdateWithoutBotInput>
  }

  export type BotProviderKeyUpdateManyWithWhereWithoutBotInput = {
    where: BotProviderKeyScalarWhereInput
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyWithoutBotInput>
  }

  export type BotProviderKeyScalarWhereInput = {
    AND?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
    OR?: BotProviderKeyScalarWhereInput[]
    NOT?: BotProviderKeyScalarWhereInput | BotProviderKeyScalarWhereInput[]
    id?: UuidFilter<"BotProviderKey"> | string
    botId?: UuidFilter<"BotProviderKey"> | string
    providerKeyId?: UuidFilter<"BotProviderKey"> | string
    isPrimary?: BoolFilter<"BotProviderKey"> | boolean
    createdAt?: DateTimeFilter<"BotProviderKey"> | Date | string
  }

  export type BotUsageLogUpsertWithWhereUniqueWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    update: XOR<BotUsageLogUpdateWithoutBotInput, BotUsageLogUncheckedUpdateWithoutBotInput>
    create: XOR<BotUsageLogCreateWithoutBotInput, BotUsageLogUncheckedCreateWithoutBotInput>
  }

  export type BotUsageLogUpdateWithWhereUniqueWithoutBotInput = {
    where: BotUsageLogWhereUniqueInput
    data: XOR<BotUsageLogUpdateWithoutBotInput, BotUsageLogUncheckedUpdateWithoutBotInput>
  }

  export type BotUsageLogUpdateManyWithWhereWithoutBotInput = {
    where: BotUsageLogScalarWhereInput
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyWithoutBotInput>
  }

  export type BotUsageLogScalarWhereInput = {
    AND?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
    OR?: BotUsageLogScalarWhereInput[]
    NOT?: BotUsageLogScalarWhereInput | BotUsageLogScalarWhereInput[]
    id?: UuidFilter<"BotUsageLog"> | string
    botId?: UuidFilter<"BotUsageLog"> | string
    vendor?: StringFilter<"BotUsageLog"> | string
    providerKeyId?: UuidNullableFilter<"BotUsageLog"> | string | null
    statusCode?: IntNullableFilter<"BotUsageLog"> | number | null
    requestTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    responseTokens?: IntNullableFilter<"BotUsageLog"> | number | null
    createdAt?: DateTimeFilter<"BotUsageLog"> | Date | string
  }

  export type ProxyTokenUpsertWithoutBotInput = {
    update: XOR<ProxyTokenUpdateWithoutBotInput, ProxyTokenUncheckedUpdateWithoutBotInput>
    create: XOR<ProxyTokenCreateWithoutBotInput, ProxyTokenUncheckedCreateWithoutBotInput>
    where?: ProxyTokenWhereInput
  }

  export type ProxyTokenUpdateToOneWithWhereWithoutBotInput = {
    where?: ProxyTokenWhereInput
    data: XOR<ProxyTokenUpdateWithoutBotInput, ProxyTokenUncheckedUpdateWithoutBotInput>
  }

  export type ProxyTokenUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerKey?: ProviderKeyUpdateOneRequiredWithoutProxyTokensNestedInput
  }

  export type ProxyTokenUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    keyId?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserInfoCreateWithoutProviderKeysInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutProviderKeysInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutProviderKeysInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
  }

  export type BotProviderKeyCreateWithoutProviderKeyInput = {
    id?: string
    isPrimary?: boolean
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutProviderKeysInput
  }

  export type BotProviderKeyUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotProviderKeyCreateOrConnectWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    create: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotProviderKeyCreateManyProviderKeyInputEnvelope = {
    data: BotProviderKeyCreateManyProviderKeyInput | BotProviderKeyCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type BotUsageLogCreateWithoutProviderKeyInput = {
    id?: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
    bot: BotCreateNestedOneWithoutUsageLogsInput
  }

  export type BotUsageLogUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type BotUsageLogCreateOrConnectWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    create: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotUsageLogCreateManyProviderKeyInputEnvelope = {
    data: BotUsageLogCreateManyProviderKeyInput | BotUsageLogCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type ProxyTokenCreateWithoutProviderKeyInput = {
    id?: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bot: BotCreateNestedOneWithoutProxyTokenInput
  }

  export type ProxyTokenUncheckedCreateWithoutProviderKeyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ProxyTokenCreateOrConnectWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    create: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput>
  }

  export type ProxyTokenCreateManyProviderKeyInputEnvelope = {
    data: ProxyTokenCreateManyProviderKeyInput | ProxyTokenCreateManyProviderKeyInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutProviderKeysInput = {
    update: XOR<UserInfoUpdateWithoutProviderKeysInput, UserInfoUncheckedUpdateWithoutProviderKeysInput>
    create: XOR<UserInfoCreateWithoutProviderKeysInput, UserInfoUncheckedCreateWithoutProviderKeysInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutProviderKeysInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutProviderKeysInput, UserInfoUncheckedUpdateWithoutProviderKeysInput>
  }

  export type UserInfoUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type BotProviderKeyUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    update: XOR<BotProviderKeyUpdateWithoutProviderKeyInput, BotProviderKeyUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<BotProviderKeyCreateWithoutProviderKeyInput, BotProviderKeyUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotProviderKeyUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: BotProviderKeyWhereUniqueInput
    data: XOR<BotProviderKeyUpdateWithoutProviderKeyInput, BotProviderKeyUncheckedUpdateWithoutProviderKeyInput>
  }

  export type BotProviderKeyUpdateManyWithWhereWithoutProviderKeyInput = {
    where: BotProviderKeyScalarWhereInput
    data: XOR<BotProviderKeyUpdateManyMutationInput, BotProviderKeyUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type BotUsageLogUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    update: XOR<BotUsageLogUpdateWithoutProviderKeyInput, BotUsageLogUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<BotUsageLogCreateWithoutProviderKeyInput, BotUsageLogUncheckedCreateWithoutProviderKeyInput>
  }

  export type BotUsageLogUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: BotUsageLogWhereUniqueInput
    data: XOR<BotUsageLogUpdateWithoutProviderKeyInput, BotUsageLogUncheckedUpdateWithoutProviderKeyInput>
  }

  export type BotUsageLogUpdateManyWithWhereWithoutProviderKeyInput = {
    where: BotUsageLogScalarWhereInput
    data: XOR<BotUsageLogUpdateManyMutationInput, BotUsageLogUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type ProxyTokenUpsertWithWhereUniqueWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    update: XOR<ProxyTokenUpdateWithoutProviderKeyInput, ProxyTokenUncheckedUpdateWithoutProviderKeyInput>
    create: XOR<ProxyTokenCreateWithoutProviderKeyInput, ProxyTokenUncheckedCreateWithoutProviderKeyInput>
  }

  export type ProxyTokenUpdateWithWhereUniqueWithoutProviderKeyInput = {
    where: ProxyTokenWhereUniqueInput
    data: XOR<ProxyTokenUpdateWithoutProviderKeyInput, ProxyTokenUncheckedUpdateWithoutProviderKeyInput>
  }

  export type ProxyTokenUpdateManyWithWhereWithoutProviderKeyInput = {
    where: ProxyTokenScalarWhereInput
    data: XOR<ProxyTokenUpdateManyMutationInput, ProxyTokenUncheckedUpdateManyWithoutProviderKeyInput>
  }

  export type ProxyTokenScalarWhereInput = {
    AND?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
    OR?: ProxyTokenScalarWhereInput[]
    NOT?: ProxyTokenScalarWhereInput | ProxyTokenScalarWhereInput[]
    id?: UuidFilter<"ProxyToken"> | string
    botId?: UuidFilter<"ProxyToken"> | string
    tokenHash?: StringFilter<"ProxyToken"> | string
    vendor?: StringFilter<"ProxyToken"> | string
    keyId?: UuidFilter<"ProxyToken"> | string
    tags?: StringNullableListFilter<"ProxyToken">
    expiresAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    revokedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    lastUsedAt?: DateTimeNullableFilter<"ProxyToken"> | Date | string | null
    requestCount?: IntFilter<"ProxyToken"> | number
    createdAt?: DateTimeFilter<"ProxyToken"> | Date | string
    updatedAt?: DateTimeFilter<"ProxyToken"> | Date | string
  }

  export type BotCreateWithoutProviderKeysInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutProviderKeysInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutProviderKeysInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
  }

  export type ProviderKeyCreateWithoutBotProviderKeysInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutBotProviderKeysInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutBotProviderKeysInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
  }

  export type BotUpsertWithoutProviderKeysInput = {
    update: XOR<BotUpdateWithoutProviderKeysInput, BotUncheckedUpdateWithoutProviderKeysInput>
    create: XOR<BotCreateWithoutProviderKeysInput, BotUncheckedCreateWithoutProviderKeysInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutProviderKeysInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutProviderKeysInput, BotUncheckedUpdateWithoutProviderKeysInput>
  }

  export type BotUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutBotProviderKeysInput = {
    update: XOR<ProviderKeyUpdateWithoutBotProviderKeysInput, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
    create: XOR<ProviderKeyCreateWithoutBotProviderKeysInput, ProviderKeyUncheckedCreateWithoutBotProviderKeysInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutBotProviderKeysInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutBotProviderKeysInput, ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput>
  }

  export type ProviderKeyUpdateWithoutBotProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutBotProviderKeysInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type BotCreateWithoutUsageLogsInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenCreateNestedOneWithoutBotInput
  }

  export type BotUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    proxyToken?: ProxyTokenUncheckedCreateNestedOneWithoutBotInput
  }

  export type BotCreateOrConnectWithoutUsageLogsInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
  }

  export type ProviderKeyCreateWithoutUsageLogsInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutUsageLogsInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    proxyTokens?: ProxyTokenUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutUsageLogsInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
  }

  export type BotUpsertWithoutUsageLogsInput = {
    update: XOR<BotUpdateWithoutUsageLogsInput, BotUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<BotCreateWithoutUsageLogsInput, BotUncheckedCreateWithoutUsageLogsInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutUsageLogsInput, BotUncheckedUpdateWithoutUsageLogsInput>
  }

  export type BotUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutUsageLogsInput = {
    update: XOR<ProviderKeyUpdateWithoutUsageLogsInput, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
    create: XOR<ProviderKeyCreateWithoutUsageLogsInput, ProviderKeyUncheckedCreateWithoutUsageLogsInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutUsageLogsInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutUsageLogsInput, ProviderKeyUncheckedUpdateWithoutUsageLogsInput>
  }

  export type ProviderKeyUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutUsageLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type BotCreateWithoutProxyTokenInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutBotsInput
    personaTemplate?: PersonaTemplateCreateNestedOneWithoutBotsInput
    avatarFile?: FileSourceCreateNestedOneWithoutBotAvatarsInput
    providerKeys?: BotProviderKeyCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutBotInput
  }

  export type BotUncheckedCreateWithoutProxyTokenInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    providerKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutBotInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutBotInput
  }

  export type BotCreateOrConnectWithoutProxyTokenInput = {
    where: BotWhereUniqueInput
    create: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
  }

  export type ProviderKeyCreateWithoutProxyTokensInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    createdBy: UserInfoCreateNestedOneWithoutProviderKeysInput
    botProviderKeys?: BotProviderKeyCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyUncheckedCreateWithoutProxyTokensInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    createdById: string
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedCreateNestedManyWithoutProviderKeyInput
    usageLogs?: BotUsageLogUncheckedCreateNestedManyWithoutProviderKeyInput
  }

  export type ProviderKeyCreateOrConnectWithoutProxyTokensInput = {
    where: ProviderKeyWhereUniqueInput
    create: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
  }

  export type BotUpsertWithoutProxyTokenInput = {
    update: XOR<BotUpdateWithoutProxyTokenInput, BotUncheckedUpdateWithoutProxyTokenInput>
    create: XOR<BotCreateWithoutProxyTokenInput, BotUncheckedCreateWithoutProxyTokenInput>
    where?: BotWhereInput
  }

  export type BotUpdateToOneWithWhereWithoutProxyTokenInput = {
    where?: BotWhereInput
    data: XOR<BotUpdateWithoutProxyTokenInput, BotUncheckedUpdateWithoutProxyTokenInput>
  }

  export type BotUpdateWithoutProxyTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutProxyTokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
  }

  export type ProviderKeyUpsertWithoutProxyTokensInput = {
    update: XOR<ProviderKeyUpdateWithoutProxyTokensInput, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
    create: XOR<ProviderKeyCreateWithoutProxyTokensInput, ProviderKeyUncheckedCreateWithoutProxyTokensInput>
    where?: ProviderKeyWhereInput
  }

  export type ProviderKeyUpdateToOneWithWhereWithoutProxyTokensInput = {
    where?: ProviderKeyWhereInput
    data: XOR<ProviderKeyUpdateWithoutProxyTokensInput, ProviderKeyUncheckedUpdateWithoutProxyTokensInput>
  }

  export type ProviderKeyUpdateWithoutProxyTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutProviderKeysNestedInput
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutProxyTokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdById?: StringFieldUpdateOperationsInput | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type UserInfoCreateWithoutSentMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutSentMessagesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
  }

  export type MessageRecipientCreateWithoutMessageInput = {
    id?: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    user: UserInfoCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageRecipientUncheckedCreateWithoutMessageInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateOrConnectWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    create: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientCreateManyMessageInputEnvelope = {
    data: MessageRecipientCreateManyMessageInput | MessageRecipientCreateManyMessageInput[]
    skipDuplicates?: boolean
  }

  export type UserInfoUpsertWithoutSentMessagesInput = {
    update: XOR<UserInfoUpdateWithoutSentMessagesInput, UserInfoUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserInfoCreateWithoutSentMessagesInput, UserInfoUncheckedCreateWithoutSentMessagesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutSentMessagesInput, UserInfoUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserInfoUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MessageRecipientUpsertWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    update: XOR<MessageRecipientUpdateWithoutMessageInput, MessageRecipientUncheckedUpdateWithoutMessageInput>
    create: XOR<MessageRecipientCreateWithoutMessageInput, MessageRecipientUncheckedCreateWithoutMessageInput>
  }

  export type MessageRecipientUpdateWithWhereUniqueWithoutMessageInput = {
    where: MessageRecipientWhereUniqueInput
    data: XOR<MessageRecipientUpdateWithoutMessageInput, MessageRecipientUncheckedUpdateWithoutMessageInput>
  }

  export type MessageRecipientUpdateManyWithWhereWithoutMessageInput = {
    where: MessageRecipientScalarWhereInput
    data: XOR<MessageRecipientUpdateManyMutationInput, MessageRecipientUncheckedUpdateManyWithoutMessageInput>
  }

  export type MessageCreateWithoutRecipientsInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
    sender?: UserInfoCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutRecipientsInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    senderId?: string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageCreateOrConnectWithoutRecipientsInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
  }

  export type UserInfoCreateWithoutReceivedMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogCreateNestedManyWithoutUserInput
  }

  export type UserInfoUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
    operateLogs?: OperateLogUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserInfoCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type MessageUpsertWithoutRecipientsInput = {
    update: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
    create: XOR<MessageCreateWithoutRecipientsInput, MessageUncheckedCreateWithoutRecipientsInput>
    where?: MessageWhereInput
  }

  export type MessageUpdateToOneWithWhereWithoutRecipientsInput = {
    where?: MessageWhereInput
    data: XOR<MessageUpdateWithoutRecipientsInput, MessageUncheckedUpdateWithoutRecipientsInput>
  }

  export type MessageUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    sender?: UserInfoUpdateOneWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutRecipientsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    senderId?: NullableStringFieldUpdateOperationsInput | string | null
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserInfoUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserInfoUpdateWithoutReceivedMessagesInput, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserInfoCreateWithoutReceivedMessagesInput, UserInfoUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutReceivedMessagesInput, UserInfoUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserInfoUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoCreateWithoutOperateLogsInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    avatarFile?: FileSourceCreateNestedOneWithoutUserAvatarsInput
    wechatAuth?: WechatAuthCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthCreateNestedOneWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientCreateNestedManyWithoutUserInput
    bots?: BotCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateCreateNestedManyWithoutCreatedByInput
  }

  export type UserInfoUncheckedCreateWithoutOperateLogsInput = {
    id?: string
    nickname?: string
    code?: string | null
    avatarFileId?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
    wechatAuth?: WechatAuthUncheckedCreateNestedOneWithoutUserInput
    googleAuth?: GoogleAuthUncheckedCreateNestedOneWithoutUserInput
    discordAuth?: DiscordAuthUncheckedCreateNestedOneWithoutUserInput
    mobileAuth?: MobileAuthUncheckedCreateNestedOneWithoutUserInput
    emailAuth?: EmailAuthUncheckedCreateNestedOneWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageRecipientUncheckedCreateNestedManyWithoutUserInput
    bots?: BotUncheckedCreateNestedManyWithoutCreatedByInput
    providerKeys?: ProviderKeyUncheckedCreateNestedManyWithoutCreatedByInput
    personaTemplates?: PersonaTemplateUncheckedCreateNestedManyWithoutCreatedByInput
  }

  export type UserInfoCreateOrConnectWithoutOperateLogsInput = {
    where: UserInfoWhereUniqueInput
    create: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
  }

  export type UserInfoUpsertWithoutOperateLogsInput = {
    update: XOR<UserInfoUpdateWithoutOperateLogsInput, UserInfoUncheckedUpdateWithoutOperateLogsInput>
    create: XOR<UserInfoCreateWithoutOperateLogsInput, UserInfoUncheckedCreateWithoutOperateLogsInput>
    where?: UserInfoWhereInput
  }

  export type UserInfoUpdateToOneWithWhereWithoutOperateLogsInput = {
    where?: UserInfoWhereInput
    data: XOR<UserInfoUpdateWithoutOperateLogsInput, UserInfoUncheckedUpdateWithoutOperateLogsInput>
  }

  export type UserInfoUpdateWithoutOperateLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFile?: FileSourceUpdateOneWithoutUserAvatarsNestedInput
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutOperateLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
  }

  export type ChannelCredentialFieldCreateWithoutChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUncheckedCreateWithoutChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldCreateOrConnectWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    create: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCredentialFieldCreateManyChannelInputEnvelope = {
    data: ChannelCredentialFieldCreateManyChannelInput | ChannelCredentialFieldCreateManyChannelInput[]
    skipDuplicates?: boolean
  }

  export type ChannelCredentialFieldUpsertWithWhereUniqueWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    update: XOR<ChannelCredentialFieldUpdateWithoutChannelInput, ChannelCredentialFieldUncheckedUpdateWithoutChannelInput>
    create: XOR<ChannelCredentialFieldCreateWithoutChannelInput, ChannelCredentialFieldUncheckedCreateWithoutChannelInput>
  }

  export type ChannelCredentialFieldUpdateWithWhereUniqueWithoutChannelInput = {
    where: ChannelCredentialFieldWhereUniqueInput
    data: XOR<ChannelCredentialFieldUpdateWithoutChannelInput, ChannelCredentialFieldUncheckedUpdateWithoutChannelInput>
  }

  export type ChannelCredentialFieldUpdateManyWithWhereWithoutChannelInput = {
    where: ChannelCredentialFieldScalarWhereInput
    data: XOR<ChannelCredentialFieldUpdateManyMutationInput, ChannelCredentialFieldUncheckedUpdateManyWithoutChannelInput>
  }

  export type ChannelCredentialFieldScalarWhereInput = {
    AND?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
    OR?: ChannelCredentialFieldScalarWhereInput[]
    NOT?: ChannelCredentialFieldScalarWhereInput | ChannelCredentialFieldScalarWhereInput[]
    id?: UuidFilter<"ChannelCredentialField"> | string
    channelId?: StringFilter<"ChannelCredentialField"> | string
    key?: StringFilter<"ChannelCredentialField"> | string
    label?: StringFilter<"ChannelCredentialField"> | string
    placeholder?: StringFilter<"ChannelCredentialField"> | string
    fieldType?: StringFilter<"ChannelCredentialField"> | string
    required?: BoolFilter<"ChannelCredentialField"> | boolean
    sortOrder?: IntFilter<"ChannelCredentialField"> | number
    isDeleted?: BoolFilter<"ChannelCredentialField"> | boolean
    createdAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    updatedAt?: DateTimeFilter<"ChannelCredentialField"> | Date | string
    deletedAt?: DateTimeNullableFilter<"ChannelCredentialField"> | Date | string | null
  }

  export type ChannelDefinitionCreateWithoutCredentialFieldsInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput = {
    id: string
    label: string
    icon: string
    popular?: boolean
    tokenHint: string
    tokenPlaceholder: string
    helpUrl?: string | null
    helpText?: string | null
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelDefinitionCreateOrConnectWithoutCredentialFieldsInput = {
    where: ChannelDefinitionWhereUniqueInput
    create: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
  }

  export type ChannelDefinitionUpsertWithoutCredentialFieldsInput = {
    update: XOR<ChannelDefinitionUpdateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
    create: XOR<ChannelDefinitionCreateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedCreateWithoutCredentialFieldsInput>
    where?: ChannelDefinitionWhereInput
  }

  export type ChannelDefinitionUpdateToOneWithWhereWithoutCredentialFieldsInput = {
    where?: ChannelDefinitionWhereInput
    data: XOR<ChannelDefinitionUpdateWithoutCredentialFieldsInput, ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput>
  }

  export type ChannelDefinitionUpdateWithoutCredentialFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelDefinitionUncheckedUpdateWithoutCredentialFieldsInput = {
    id?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    icon?: StringFieldUpdateOperationsInput | string
    popular?: BoolFieldUpdateOperationsInput | boolean
    tokenHint?: StringFieldUpdateOperationsInput | string
    tokenPlaceholder?: StringFieldUpdateOperationsInput | string
    helpUrl?: NullableStringFieldUpdateOperationsInput | string | null
    helpText?: NullableStringFieldUpdateOperationsInput | string | null
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageCreateManySenderInput = {
    id?: string
    type: string
    title?: string | null
    content: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientCreateManyUserInput = {
    id?: string
    messageId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type BotCreateManyCreatedByInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    personaTemplateId?: string | null
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ProviderKeyCreateManyCreatedByInput = {
    id?: string
    vendor: string
    apiType?: string | null
    secretEncrypted: Bytes
    label: string
    tag?: string | null
    baseUrl?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type PersonaTemplateCreateManyCreatedByInput = {
    id?: string
    name: string
    emoji?: string | null
    avatarFileId?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type OperateLogCreateManyUserInput = {
    id?: string
    operateType: $Enums.OperateType
    target: $Enums.OperateTarget
    targetId?: string | null
    targetName?: string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    recipients?: MessageRecipientUncheckedUpdateManyWithoutMessageNestedInput
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    content?: JsonNullValueInput | InputJsonValue
    metadata?: NullableJsonNullValueInput | InputJsonValue
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    message?: MessageUpdateOneRequiredWithoutRecipientsNestedInput
  }

  export type MessageRecipientUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    messageId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProviderKeyUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    botProviderKeys?: BotProviderKeyUncheckedUpdateManyWithoutProviderKeyNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutProviderKeyNestedInput
    proxyTokens?: ProxyTokenUncheckedUpdateManyWithoutProviderKeyNestedInput
  }

  export type ProviderKeyUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    apiType?: NullableStringFieldUpdateOperationsInput | string | null
    secretEncrypted?: BytesFieldUpdateOperationsInput | Bytes
    label?: StringFieldUpdateOperationsInput | string
    tag?: NullableStringFieldUpdateOperationsInput | string | null
    baseUrl?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type PersonaTemplateUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    avatarFile?: FileSourceUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type OperateLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OperateLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    operateType?: EnumOperateTypeFieldUpdateOperationsInput | $Enums.OperateType
    target?: EnumOperateTargetFieldUpdateOperationsInput | $Enums.OperateTarget
    targetId?: NullableStringFieldUpdateOperationsInput | string | null
    targetName?: NullableStringFieldUpdateOperationsInput | string | null
    detail?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotCreateManyPersonaTemplateInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    emoji?: string | null
    avatarFileId?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotUpdateWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    avatarFile?: FileSourceUpdateOneWithoutBotAvatarsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutPersonaTemplateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    avatarFileId?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserInfoCreateManyAvatarFileInput = {
    id?: string
    nickname?: string
    code?: string | null
    sex?: $Enums.SexType
    locale?: string | null
    isAnonymity?: boolean
    isAdmin?: boolean
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
    deviceId?: string | null
    wechatOpenid?: string | null
    wechatUnionId?: string | null
    googleSub?: string | null
    discordId?: string | null
    mobile?: string | null
    email?: string | null
  }

  export type PersonaTemplateCreateManyAvatarFileInput = {
    id?: string
    name: string
    emoji?: string | null
    tagline: string
    soulMarkdown: string
    soulPreview?: string | null
    isSystem?: boolean
    createdById?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type BotCreateManyAvatarFileInput = {
    id?: string
    name: string
    hostname: string
    aiProvider: string
    model: string
    channelType: string
    containerId?: string | null
    port?: number | null
    gatewayToken?: string | null
    proxyTokenHash?: string | null
    tags?: BotCreatetagsInput | string[]
    status?: $Enums.BotStatus
    createdById: string
    personaTemplateId?: string | null
    emoji?: string | null
    soulMarkdown?: string | null
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type UserInfoUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUpdateManyWithoutUserNestedInput
    bots?: BotUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    wechatAuth?: WechatAuthUncheckedUpdateOneWithoutUserNestedInput
    googleAuth?: GoogleAuthUncheckedUpdateOneWithoutUserNestedInput
    discordAuth?: DiscordAuthUncheckedUpdateOneWithoutUserNestedInput
    mobileAuth?: MobileAuthUncheckedUpdateOneWithoutUserNestedInput
    emailAuth?: EmailAuthUncheckedUpdateOneWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageRecipientUncheckedUpdateManyWithoutUserNestedInput
    bots?: BotUncheckedUpdateManyWithoutCreatedByNestedInput
    providerKeys?: ProviderKeyUncheckedUpdateManyWithoutCreatedByNestedInput
    personaTemplates?: PersonaTemplateUncheckedUpdateManyWithoutCreatedByNestedInput
    operateLogs?: OperateLogUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserInfoUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: StringFieldUpdateOperationsInput | string
    code?: NullableStringFieldUpdateOperationsInput | string | null
    sex?: EnumSexTypeFieldUpdateOperationsInput | $Enums.SexType
    locale?: NullableStringFieldUpdateOperationsInput | string | null
    isAnonymity?: BoolFieldUpdateOperationsInput | boolean
    isAdmin?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    wechatOpenid?: NullableStringFieldUpdateOperationsInput | string | null
    wechatUnionId?: NullableStringFieldUpdateOperationsInput | string | null
    googleSub?: NullableStringFieldUpdateOperationsInput | string | null
    discordId?: NullableStringFieldUpdateOperationsInput | string | null
    mobile?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PersonaTemplateUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneWithoutPersonaTemplatesNestedInput
    bots?: BotUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    bots?: BotUncheckedUpdateManyWithoutPersonaTemplateNestedInput
  }

  export type PersonaTemplateUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    tagline?: StringFieldUpdateOperationsInput | string
    soulMarkdown?: StringFieldUpdateOperationsInput | string
    soulPreview?: NullableStringFieldUpdateOperationsInput | string | null
    isSystem?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdBy?: UserInfoUpdateOneRequiredWithoutBotsNestedInput
    personaTemplate?: PersonaTemplateUpdateOneWithoutBotsNestedInput
    providerKeys?: BotProviderKeyUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    providerKeys?: BotProviderKeyUncheckedUpdateManyWithoutBotNestedInput
    usageLogs?: BotUsageLogUncheckedUpdateManyWithoutBotNestedInput
    proxyToken?: ProxyTokenUncheckedUpdateOneWithoutBotNestedInput
  }

  export type BotUncheckedUpdateManyWithoutAvatarFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    hostname?: StringFieldUpdateOperationsInput | string
    aiProvider?: StringFieldUpdateOperationsInput | string
    model?: StringFieldUpdateOperationsInput | string
    channelType?: StringFieldUpdateOperationsInput | string
    containerId?: NullableStringFieldUpdateOperationsInput | string | null
    port?: NullableIntFieldUpdateOperationsInput | number | null
    gatewayToken?: NullableStringFieldUpdateOperationsInput | string | null
    proxyTokenHash?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: BotUpdatetagsInput | string[]
    status?: EnumBotStatusFieldUpdateOperationsInput | $Enums.BotStatus
    createdById?: StringFieldUpdateOperationsInput | string
    personaTemplateId?: NullableStringFieldUpdateOperationsInput | string | null
    emoji?: NullableStringFieldUpdateOperationsInput | string | null
    soulMarkdown?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type BotProviderKeyCreateManyBotInput = {
    id?: string
    providerKeyId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotUsageLogCreateManyBotInput = {
    id?: string
    vendor: string
    providerKeyId?: string | null
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type BotProviderKeyUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerKey?: ProviderKeyUpdateOneRequiredWithoutBotProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    providerKeyId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providerKey?: ProviderKeyUpdateOneWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUncheckedUpdateManyWithoutBotInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    providerKeyId?: NullableStringFieldUpdateOperationsInput | string | null
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyCreateManyProviderKeyInput = {
    id?: string
    botId: string
    isPrimary?: boolean
    createdAt?: Date | string
  }

  export type BotUsageLogCreateManyProviderKeyInput = {
    id?: string
    botId: string
    vendor: string
    statusCode?: number | null
    requestTokens?: number | null
    responseTokens?: number | null
    createdAt?: Date | string
  }

  export type ProxyTokenCreateManyProviderKeyInput = {
    id?: string
    botId: string
    tokenHash: string
    vendor: string
    tags?: ProxyTokenCreatetagsInput | string[]
    expiresAt?: Date | string | null
    revokedAt?: Date | string | null
    lastUsedAt?: Date | string | null
    requestCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type BotProviderKeyUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProviderKeysNestedInput
  }

  export type BotProviderKeyUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotProviderKeyUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    isPrimary?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutUsageLogsNestedInput
  }

  export type BotUsageLogUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BotUsageLogUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    statusCode?: NullableIntFieldUpdateOperationsInput | number | null
    requestTokens?: NullableIntFieldUpdateOperationsInput | number | null
    responseTokens?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bot?: BotUpdateOneRequiredWithoutProxyTokenNestedInput
  }

  export type ProxyTokenUncheckedUpdateWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProxyTokenUncheckedUpdateManyWithoutProviderKeyInput = {
    id?: StringFieldUpdateOperationsInput | string
    botId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    vendor?: StringFieldUpdateOperationsInput | string
    tags?: ProxyTokenUpdatetagsInput | string[]
    expiresAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    revokedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    lastUsedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    requestCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageRecipientCreateManyMessageInput = {
    id?: string
    userId: string
    isRead?: boolean
    readAt?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    isDeleted?: boolean
    deletedAt?: Date | string | null
  }

  export type MessageRecipientUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserInfoUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageRecipientUncheckedUpdateWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageRecipientUncheckedUpdateManyWithoutMessageInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldCreateManyChannelInput = {
    id?: string
    key: string
    label: string
    placeholder: string
    fieldType?: string
    required?: boolean
    sortOrder?: number
    isDeleted?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    deletedAt?: Date | string | null
  }

  export type ChannelCredentialFieldUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChannelCredentialFieldUncheckedUpdateManyWithoutChannelInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    label?: StringFieldUpdateOperationsInput | string
    placeholder?: StringFieldUpdateOperationsInput | string
    fieldType?: StringFieldUpdateOperationsInput | string
    required?: BoolFieldUpdateOperationsInput | boolean
    sortOrder?: IntFieldUpdateOperationsInput | number
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}