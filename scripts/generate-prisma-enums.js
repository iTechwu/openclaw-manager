#!/usr/bin/env node
/**
 * Prisma Enum Generator
 *
 * ä» Prisma schema ä¸­æå–æ‰€æœ‰ enum å®šä¹‰ï¼Œç”Ÿæˆ Zod schema æ–‡ä»¶
 * ä¾› @repo/contracts ä½¿ç”¨ï¼Œå®ç°å‰åç«¯ enum ç±»å‹å…±äº«
 *
 * ä½¿ç”¨æ–¹æ³•:
 *   pnpm generate:enums
 *
 * è¾“å‡ºæ–‡ä»¶:
 *   packages/contracts/src/schemas/prisma-enums.generated.ts
 */

const fs = require('fs');
const path = require('path');

// é…ç½®
const PRISMA_SCHEMA_PATH = path.resolve(__dirname, '../apps/api/prisma/schema.prisma');
const OUTPUT_PATH = path.resolve(__dirname, '../packages/contracts/src/schemas/prisma-enums.generated.ts');

/**
 * è§£æ Prisma schema æ–‡ä»¶ï¼Œæå–æ‰€æœ‰ enum å®šä¹‰
 * @param {string} schemaContent
 * @returns {Array<{name: string, values: string[], comment?: string}>}
 */
function parsePrismaEnums(schemaContent) {
  const enums = [];
  const lines = schemaContent.split('\n');

  let currentEnum = null;
  let previousComment = '';

  for (let i = 0; i < lines.length; i++) {
    const line = lines[i].trim();

    // æ”¶é›†æ³¨é‡Š
    if (line.startsWith('//')) {
      previousComment = line.substring(2).trim();
      continue;
    }

    // æ£€æµ‹ enum å¼€å§‹
    const enumMatch = line.match(/^enum\s+(\w+)\s*\{/);
    if (enumMatch) {
      currentEnum = {
        name: enumMatch[1],
        values: [],
        comment: previousComment || undefined,
      };
      previousComment = '';
      continue;
    }

    // æ£€æµ‹ enum ç»“æŸ
    if (currentEnum && line === '}') {
      enums.push(currentEnum);
      currentEnum = null;
      continue;
    }

    // æ”¶é›† enum å€¼ï¼ˆæ’é™¤ @@map ç­‰ Prisma æŒ‡ä»¤ï¼‰
    if (currentEnum && line && !line.startsWith('//')) {
      // è·³è¿‡ @@map ç­‰ model-level æŒ‡ä»¤
      if (line.startsWith('@@')) continue;

      // ç§»é™¤å¯èƒ½çš„æ³¨é‡Š
      const withoutComment = line.split('//')[0].trim();
      if (!withoutComment) continue;

      // æ£€æŸ¥ @map("value") æŒ‡ä»¤ â€” ä½¿ç”¨æ˜ å°„å€¼ä½œä¸ºå®é™… enum å€¼
      const mapMatch = withoutComment.match(/@map\("([^"]+)"\)/);
      if (mapMatch) {
        currentEnum.values.push(mapMatch[1]);
      } else {
        // æ—  @map æ—¶å–ç¬¬ä¸€ä¸ª tokenï¼ˆenum åç§°ï¼‰
        const value = withoutComment.split(/\s+/)[0];
        if (value) {
          currentEnum.values.push(value);
        }
      }
    }

    // é‡ç½®æ³¨é‡Šï¼ˆå¦‚æœä¸æ˜¯ç´§è·Ÿç€ enumï¼‰
    if (!line.startsWith('//') && !enumMatch) {
      previousComment = '';
    }
  }

  return enums;
}

/**
 * ç”Ÿæˆ Zod enum schema ä»£ç 
 * @param {Array<{name: string, values: string[], comment?: string}>} enums
 * @returns {string}
 */
function generateZodEnums(enums) {
  const imports = `/**
 * Prisma Enums - Auto-generated from Prisma schema
 *
 * DO NOT EDIT THIS FILE MANUALLY!
 *
 * This file is auto-generated by scripts/generate-prisma-enums.js
 * Run \`pnpm generate:enums\` to regenerate.
 *
 * @generated
 */

import { z } from 'zod';

`;

  const enumCode = enums.map(enumDef => {
    const { name, values, comment } = enumDef;
    const schemaName = `${name}Schema`;

    // ç”Ÿæˆå€¼æ•°ç»„
    const valuesStr = values.map(v => `'${v}'`).join(', ');

    // ç”Ÿæˆæ³¨é‡Š
    const commentStr = comment ? `/** ${comment} */\n` : '';

    return `${commentStr}export const ${schemaName} = z.enum([${valuesStr}]);
export type ${name} = z.infer<typeof ${schemaName}>;
`;
  }).join('\n');

  // ç”Ÿæˆå¯¼å‡ºæ±‡æ€»
  const exportSummary = `
// ============================================================================
// Enum value arrays (for iteration/validation)
// ============================================================================

${enums.map(e => `export const ${e.name}Values = ${e.name}Schema.options;`).join('\n')}

// ============================================================================
// Type guards
// ============================================================================

${enums.map(e => `export const is${e.name} = (value: unknown): value is ${e.name} => ${e.name}Schema.safeParse(value).success;`).join('\n')}
`;

  return imports + enumCode + exportSummary;
}

/**
 * ä¸»å‡½æ•°
 */
function main() {
  console.log('ğŸ“¦ Generating Prisma enums...');
  console.log(`   Source: ${PRISMA_SCHEMA_PATH}`);
  console.log(`   Output: ${OUTPUT_PATH}`);

  // è¯»å– Prisma schema
  if (!fs.existsSync(PRISMA_SCHEMA_PATH)) {
    console.error(`âŒ Prisma schema not found: ${PRISMA_SCHEMA_PATH}`);
    process.exit(1);
  }

  const schemaContent = fs.readFileSync(PRISMA_SCHEMA_PATH, 'utf-8');

  // è§£æ enums
  const enums = parsePrismaEnums(schemaContent);
  console.log(`   Found ${enums.length} enums`);

  // ç”Ÿæˆä»£ç 
  const code = generateZodEnums(enums);

  // ç¡®ä¿è¾“å‡ºç›®å½•å­˜åœ¨
  const outputDir = path.dirname(OUTPUT_PATH);
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  // å†™å…¥æ–‡ä»¶
  fs.writeFileSync(OUTPUT_PATH, code, 'utf-8');

  console.log(`âœ… Generated ${enums.length} enum schemas`);
  console.log('   Enums:', enums.map(e => e.name).join(', '));
}

main();
